<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <link rel="stylesheet" href="pandoc.css" type="text/css" />
</head>
<body>
<p>morphic.js</p>
<p>a lively Web-GUI</p>
<p>inspired by Squeak</p>
<p>written by Jens Mönig</p>
<p>jens@moenig.org</p>
<p>Copyright (C) 2012 by Jens Mönig</p>
<p>This file is part of Snap!.</p>
<p>Snap! is free software: you can redistribute it and/or modify</p>
<p>it under the terms of the GNU Affero General Public License as</p>
<p>published by the Free Software Foundation, either version 3 of</p>
<p>the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful,</p>
<p>but WITHOUT ANY WARRANTY; without even the implied warranty of</p>
<p>MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</p>
<p>GNU Affero General Public License for more details.</p>
<p>You should have received a copy of the GNU Affero General Public License</p>
<p>along with this program. If not, see <a href="http://www.gnu.org/licenses/"><code class="url">http://www.gnu.org/licenses/</code></a>.</p>
<p>documentation contents</p>
<hr />
<p>I. inheritance hierarchy</p>
<ol start="2" style="list-style-type: upper-roman">
<li><p>object definition toc</p></li>
<li><p>yet to implement</p></li>
<li><p>open issues</p></li>
<li><p>browser compatibility</p></li>
<li><p>the big picture</p></li>
<li><p>programming guide</p></li>
</ol>
<ol style="list-style-type: decimal">
<li><p>setting up a web page</p>
<ol style="list-style-type: lower-alpha">
<li><p>single world</p></li>
<li><p>multiple worlds</p></li>
<li><p>an application</p></li>
</ol></li>
<li><p>manipulating morphs</p></li>
<li><p>events</p>
<ol style="list-style-type: lower-alpha">
<li><p>mouse events</p></li>
<li><p>context menu</p></li>
<li><p>dragging</p></li>
<li><p>dropping</p></li>
<li><p>keyboard events</p></li>
<li><p>resize event</p>
<ol start="7" style="list-style-type: lower-alpha">
<li>combined mouse-keyboard events</li>
</ol></li>
</ol></li>
<li><p>stepping</p></li>
<li><p>creating new kinds of morphs</p></li>
<li><p>development and user modes</p></li>
<li><p>turtle graphics</p></li>
<li><p>damage list housekeeping</p></li>
<li><p>minifying morphic.js</p></li>
</ol>
<ol start="8" style="list-style-type: upper-roman">
<li><p>acknowledgements</p></li>
<li><p>contributors</p></li>
<li><p>hierarchy</p></li>
</ol>
<hr />
<p>the following tree lists all constructors hierarchically,</p>
<p>indentation indicating inheritance. Refer to this list to get a</p>
<p>contextual overview:</p>
<p>Color</p>
<p>Node</p>
<p>Morph</p>
<pre><code>BlinkerMorph

  CursorMorph

BouncerMorph*

BoxMorph

  InspectorMorph

  MenuMorph

  MouseSensorMorph*

  SpeechBubbleMorph

CircleBoxMorph

  SliderButtonMorph

  SliderMorph

ColorPaletteMorph

  GrayPaletteMorph

ColorPickerMorph

FrameMorph

  ScrollFrameMorph

    ListMorph

  StringFieldMorph

  WorldMorph

HandleMorph

HandMorph

PenMorph

ShadowMorph

StringMorph

TextMorph

TriggerMorph

  MenuItemMorph</code></pre>
<p>Point</p>
<p>Rectangle</p>
<ol start="2" style="list-style-type: upper-roman">
<li>toc</li>
</ol>
<hr />
<p>the following list shows the order in which all constructors are</p>
<p>defined. Use this list to locate code in this document:</p>
<p>Global settings</p>
<p>Global functions</p>
<p>Color</p>
<p>Point</p>
<p>Rectangle</p>
<p>Node</p>
<p>Morph</p>
<p>ShadowMorph</p>
<p>HandleMorph</p>
<p>PenMorph</p>
<p>ColorPaletteMorph</p>
<p>GrayPaletteMorph</p>
<p>ColorPickerMorph</p>
<p>BlinkerMorph</p>
<p>CursorMorph</p>
<p>BoxMorph</p>
<p>SpeechBubbleMorph</p>
<p>CircleBoxMorph</p>
<p>SliderButtonMorph</p>
<p>SliderMorph</p>
<p>MouseSensorMorph*</p>
<p>InspectorMorph</p>
<p>MenuMorph</p>
<p>StringMorph</p>
<p>TextMorph</p>
<p>TriggerMorph</p>
<p>MenuItemMorph</p>
<p>FrameMorph</p>
<p>ScrollFrameMorph</p>
<p>ListMorph</p>
<p>StringFieldMorph</p>
<p>BouncerMorph*</p>
<p>HandMorph</p>
<p>WorldMorph</p>
<ul>
<li>included only for demo purposes</li>
</ul>
<ol start="3" style="list-style-type: upper-roman">
<li>yet to implement</li>
</ol>
<hr />
<ul>
<li>keyboard support for scroll frames and lists</li>
</ul>
<ol start="4" style="list-style-type: upper-roman">
<li>open issues</li>
</ol>
<hr />
<ul>
<li>blurry shadows don’t work well in Chrome</li>
</ul>
<p>V. browser compatibility</p>
<hr />
<p>I have taken great care and considerable effort to make morphic.js</p>
<p>runnable and appearing exactly the same on all current browsers</p>
<p>available to me:</p>
<ul>
<li><p>Firefox for Windows</p></li>
<li><p>Firefox for Mac</p></li>
<li><p>Chrome for Windows (blurry shadows have some issues)</p></li>
<li><p>Chrome for Mac</p></li>
<li><p>Safari for Windows</p></li>
<li><p>safari for Mac</p></li>
<li><p>Safari for iOS (mobile)</p></li>
<li><p>IE for Windows</p></li>
<li><p>Opera for Windows</p></li>
<li><p>Opera for Mac</p></li>
</ul>
<ol start="6" style="list-style-type: upper-roman">
<li>the big picture</li>
</ol>
<hr />
<p>Morphic.js is completely based on Canvas and JavaScript, it is just</p>
<p>Morphic, nothing else. Morphic.js is very basic and covers only the</p>
<p>bare essentials:</p>
<pre><code>  * a stepping mechanism (a time-sharing multiplexer for lively

    user interaction ontop of a single OS/browser thread)</code></pre>
<ul>
<li><p>progressive display updates (only dirty rectangles are</p>
<pre><code>redrawn in each display cycle)</code></pre></li>
<li><p>a tree structure</p></li>
<li><p>a single World per Canvas element (although you can have</p>
<pre><code>multiple worlds in multiple Canvas elements on the same web

page)</code></pre></li>
<li><p>a single Hand per World (but you can support multi-touch</p>
<pre><code>events)</code></pre></li>
<li><p>a single text entry focus per World</p></li>
</ul>
<p>In its current state morphic.js doesn’t support Transforms (you</p>
<p>cannot rotate Morphs), but with PenMorph there already is a simple</p>
<p>LOGO-like turtle that you can use to draw onto any Morph it is</p>
<p>attached to. I’m planning to add special Morphs that support these</p>
<p>operations later on, but not for every Morph in the system.</p>
<p>Therefore these additions (“sprites” etc.) are likely to be part of</p>
<p>other libraries (“microworld.js”) in separate files.</p>
<p>the purpose of morphic.js is to provide a malleable framework that</p>
<p>will let me experiment with lively GUIs for my hobby horse, which</p>
<p>is drag-and-drop, blocks based programming languages. Those things</p>
<p>(BYOB4 - http://byob.berkeley.edu) will be written using morphic.js</p>
<p>as a library.</p>
<ol start="7" style="list-style-type: upper-roman">
<li>programming guide</li>
</ol>
<hr />
<p>Morphic.js provides a library for lively GUIs inside single HTML</p>
<p>Canvas elements. Each such canvas element functions as a “world” in</p>
<p>which other visible shapes (“morphs”) can be positioned and</p>
<p>manipulated, often directly and interactively by the user. Morphs</p>
<p>are tree nodes and may contain any number of submorphs (“children”).</p>
<p>All things visible in a morphic World are morphs themselves, i.e.</p>
<p>all text rendering, blinking cursors, entry fields, menus, buttons,</p>
<p>sliders, windows and dialog boxes etc. are created with morphic.js</p>
<p>rather than using HTML DOM elements, and as a consequence can be</p>
<p>changed and adjusted by the programmer regardless of proprietary</p>
<p>browser behavior.</p>
<p>Each World has an - invisible - “Hand” resembling the mouse cursor</p>
<p>(or the user’s finger on touch screens) which handles mouse events,</p>
<p>and may also have a keyboardReceiver to handle key events.</p>
<p>The basic idea of Morphic is to continuously run display cycles and</p>
<p>to incrementally update the screen by only redrawing those World</p>
<p>regions which have been “dirtied” since the last redraw. Before</p>
<p>each shape is processed for redisplay it gets the chance to perform</p>
<p>a “step” procedure, thus allowing for an illusion of concurrency.</p>
<ol style="list-style-type: decimal">
<li>setting up a web page</li>
</ol>
<hr />
<p>Setting up a web page for Morphic always involves three steps:</p>
<p>adding one or more Canvas elements, defining one or more worlds,</p>
<p>initializing and starting the main loop.</p>
<ol style="list-style-type: lower-alpha">
<li>single world</li>
</ol>
<hr />
<p>Most commonly you will want your World to fill the browsers’s whole</p>
<p>client area. This default situation is easiest and most straight</p>
<p>forward.</p>
<p>example html file:</p>
<!DOCTYPE html>
<html>


<head>

<pre><code>&lt;title&gt;Morphic!&lt;/title&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;morphic.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

  var world;



  window.onload = function () {

    world = new WorldMorph(

      document.getElementById(&#39;world&#39;));

    setInterval(loop, 50);

  };



  function loop() {

    world.doOneCycle();

  }

&lt;/script&gt;</code></pre>

</head>


<body>

<pre><code>&lt;canvas id=&quot;world&quot; tabindex=&quot;1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;

  &lt;p&gt;Your browser doesn&#39;t support canvas.&lt;/p&gt;

&lt;/canvas&gt;</code></pre>

</body>

</html>



<p>if you use ScrollFrames or otherwise plan to support mouse wheel</p>
<p>scrolling events, you might also add the following inline-CSS</p>
<p>attribute to the Canvas element:</p>
<p>style=“position: absolute;”</p>
<p>which will prevent the World to be scrolled around instead of the</p>
<p>elements inside of it in some browsers.</p>
<ol start="2" style="list-style-type: lower-alpha">
<li>multiple worlds</li>
</ol>
<hr />
<p>If you wish to create a web page with more than one world, make</p>
<p>sure to prevent each world from auto-filling the whole page and</p>
<p>include it in the main loop. It’s also a good idea to give each</p>
<p>world its own tabindex:</p>
<p>example html file:</p>
<!DOCTYPE html>
<html>


<head>

<pre><code>&lt;title&gt;Morphic!&lt;/title&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;morphic.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

  var world1, world2;



  window.onload = function () {

    world1 = new WorldMorph(

      document.getElementById(&#39;world1&#39;), false);

    world2 = new WorldMorph(

      document.getElementById(&#39;world2&#39;), false);

    setInterval(loop, 50);

  };



  function loop() {

    world1.doOneCycle();

    world2.doOneCycle();

  }

&lt;/script&gt;</code></pre>

</head>


<body>

<pre><code>&lt;p&gt;first world:&lt;/p&gt;

&lt;canvas id=&quot;world1&quot; tabindex=&quot;1&quot; width=&quot;600&quot; height=&quot;400&quot;&gt;

  &lt;p&gt;Your browser doesn&#39;t support canvas.&lt;/p&gt;

&lt;/canvas&gt;

&lt;p&gt;second world:&lt;/p&gt;

&lt;canvas id=&quot;world2&quot; tabindex=&quot;2&quot; width=&quot;400&quot; height=&quot;600&quot;&gt;

  &lt;p&gt;Your browser doesn&#39;t support canvas.&lt;/p&gt;

&lt;/canvas&gt;</code></pre>

</body>

</html>





<ol start="3" style="list-style-type: lower-alpha">
<li>an application</li>
</ol>
<hr />
<p>Of course, most of the time you don’t want to just plain use the</p>
<p>standard Morhic World “as is” out of the box, but write your own</p>
<p>application (something like Scratch!) in it. For such an</p>
<p>application you’ll create your own morph prototypes, perhaps</p>
<p>assemble your own “window frame” and bring it all to life in a</p>
<p>customized World state. the following example creates a simple</p>
<p>snake-like mouse drawing game.</p>
<p>example html file:</p>
<!DOCTYPE html>
<html>


<head>

<pre><code>&lt;title&gt;touch me!&lt;/title&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;morphic.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;&gt;

  var worldCanvas, sensor;



  window.onload = function () {

    var x, y, w, h;



    worldCanvas = document.getElementById(&#39;world&#39;);

    world = new WorldMorph(worldCanvas);

    world.isDevMode = false;

    world.color = new Color();



    w = 100;

    h = 100;



    x = 0;

    y = 0;



    while ((y * h) &lt; world.height()) {

      while ((x * w) &lt; world.width()) {

        sensor = new MouseSensorMorph();

        sensor.setPosition(new Point(x * w, y * h));

        sensor.alpha = 0;

        sensor.setExtent(new Point(w, h));

        world.add(sensor);

        x += 1;

      }

      x = 0;

      y += 1;

    }

    setInterval(loop, 50);

  };



  function loop() {

    world.doOneCycle();

  }

&lt;/script&gt;</code></pre>

</head>


<body bgcolor='black'>

<pre><code>&lt;canvas id=&quot;world&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;

  &lt;p&gt;Your browser doesn&#39;t support canvas.&lt;/p&gt;

&lt;/canvas&gt;</code></pre>

</body>

</html>



<p>To get an idea how you can craft your own custom morph prototypes</p>
<p>I’ve included two examples which should give you an idea how to add</p>
<p>properties, override inherited methods and use the stepping</p>
<p>mechanism for “livelyness”:</p>
<p>BouncerMorph</p>
<p>MouseSensorMorph</p>
<p>For the sake of sharing a single file I’ve included those examples</p>
<p>in morphic.js itself. Usually you’ll define your additions in a</p>
<p>separate file and keep morphic.js untouched.</p>
<ol start="2" style="list-style-type: decimal">
<li>manipulating morphs</li>
</ol>
<hr />
<p>There are many methods to programmatically manipulate morphs. Among</p>
<p>the most important and common ones among all morphs are the</p>
<p>following nine:</p>
<ul>
<li><p>hide()</p></li>
<li><p>show()</p></li>
<li><p>setPosition(aPoint)</p></li>
<li><p>setExtent(aPoint)</p></li>
<li><p>setColor(aColor)</p></li>
<li><p>add(submorph) - attaches submorph ontop</p></li>
<li><p>addBack(submorph) - attaches submorph underneath</p></li>
<li><p>fullCopy() - duplication</p></li>
<li><p>destroy() - deletion</p></li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>events</li>
</ol>
<hr />
<p>All user (and system) interaction is triggered by events, which are</p>
<p>passed on from the root element - the World - to its submorphs. The</p>
<p>World contains a list of system (browser) events it reacts to in its</p>
<p>initEventListeners()</p>
<p>method. Currently there are</p>
<ul>
<li><p>mouse</p>
<ul>
<li>drop</li>
</ul></li>
<li><p>keyboard</p></li>
<li><p>(window) resize</p></li>
</ul>
<p>events.</p>
<p>These system events are dispatched within the morphic World by the</p>
<p>World’s Hand and its keyboardReceiver (usually the active text</p>
<p>cursor).</p>
<ol style="list-style-type: lower-alpha">
<li>mouse events:</li>
</ol>
<hr />
<p>The Hand dispatches the following mouse events to relevant morphs:</p>
<p>mouseDownLeft</p>
<p>mouseDownRight</p>
<p>mouseClickLeft</p>
<p>mouseClickRight</p>
<p>mouseEnter</p>
<p>mouseLeave</p>
<p>mouseEnterDragging</p>
<p>mouseLeaveDragging</p>
<p>mouseMove</p>
<p>mouseScroll</p>
<p>If you wish your morph to react to any such event, simply add a</p>
<p>method of the same name as the event, e.g:</p>
<p>MyMorph.prototype.mouseMove = function(pos) {};</p>
<p>The only optional parameter of such a method is a Point object</p>
<p>indicating the current position of the Hand inside the World’s</p>
<p>coordinate system.</p>
<p>Events may be “bubbled” up a morph’s owner chain by calling</p>
<p>this.escalateEvent(functionName, arg)</p>
<p>in the event handler method’s code.</p>
<p>Likewise, removing the event handler method will render your morph</p>
<p>passive to the event in question.</p>
<ol start="2" style="list-style-type: lower-alpha">
<li>context menu:</li>
</ol>
<hr />
<p>By default right-clicking (or single-finger tap-and-hold) on a morph</p>
<p>also invokes its context menu (in addition to firing the</p>
<p>mouseClickRight event). A morph’s context menu can be customized by</p>
<p>assigning a Menu instance to its</p>
<p>customContextMenu</p>
<p>property, or altogether suppressed by overriding its inherited</p>
<p>contextMenu()</p>
<p>method.</p>
<ol start="3" style="list-style-type: lower-alpha">
<li>dragging:</li>
</ol>
<hr />
<p>Dragging a morph is initiated when the left mouse button is pressed,</p>
<p>held and the mouse is moved.</p>
<p>You can control whether a morph is draggable by setting its</p>
<p>isDraggable</p>
<p>property either to false or true. If a morph isn’t draggable itself</p>
<p>it will pass the pick-up request up its owner chain. This lets you</p>
<p>create draggable composite morphs like Windows, DialogBoxes,</p>
<p>Sliders etc.</p>
<p>Sometimes it is desireable to make “template” shapes which cannot be</p>
<p>moved themselves, but from which instead duplicates can be peeled</p>
<p>off. This is especially useful for building blocks in construction</p>
<p>kits, e.g. the MIT-Scratch palette. Morphic.js lets you control this</p>
<p>functionality by setting the</p>
<p>isTemplate</p>
<p>property flag to true for any morph whose “isDraggable” property is</p>
<p>turned off. When dragging such a Morph the hand will instead grab</p>
<p>a duplicate of the template whose “isDraggable” flag is true and</p>
<p>whose “isTemplate” flag is false, in other words: a non-template.</p>
<p>Dragging is indicated by adding a drop shadow to the morph in hand.</p>
<p>If a morph follows the hand without displaying a drop shadow it is</p>
<p>merely being moved about without changing its parent (owner morph),</p>
<p>e.g. when “dragging” a morph handle to resize its owner, or when</p>
<p>“dragging” a slider button.</p>
<p>Right before a morph is picked up its</p>
<p>prepareToBeGrabbed(handMorph)</p>
<p>method is invoked, if it is present. Immediately after the pick-up</p>
<p>the former parent’s</p>
<p>reactToGrabOf(grabbedMorph)</p>
<p>method is called, again only if it exists.</p>
<p>Similar to events, these methods are optional and don’t exist by</p>
<p>default. For a simple example of how they can be used to adjust</p>
<p>scroll bars in a scroll frame please have a look at their</p>
<p>implementation in FrameMorph.</p>
<ol start="4" style="list-style-type: lower-alpha">
<li>dropping:</li>
</ol>
<hr />
<p>Dropping is triggered when the left mouse button is either pressed</p>
<p>or released while the Hand is dragging a morph.</p>
<p>Dropping a morph causes it to become embedded in a new owner morph.</p>
<p>You can control this embedding behavior by setting the prospective</p>
<p>drop target’s</p>
<p>acceptsDrops</p>
<p>property to either true or false, or by overriding its inherited</p>
<p>wantsDropOf(aMorph)</p>
<p>method.</p>
<p>Right after a morph has been dropped its</p>
<p>justDropped(handMorph)</p>
<p>method is called, and its new parent’s</p>
<p>reactToDropOf(droppedMorph, handMorph)</p>
<p>method is invoked, again only if each method exists.</p>
<p>Similar to events, these methods are optional and by default are</p>
<p>not present in morphs by default (watch out for inheritance,</p>
<p>though!). For a simple example of how they can be used to adjust</p>
<p>scroll bars in a scroll frame please have a look at their</p>
<p>implementation in FrameMorph.</p>
<p>Drops of image elements from outside the world canvas are dispatched as</p>
<p>droppedImage(aCanvas, name)</p>
<p>events to interested Morphs at the mouse pointer. If you want you Morph</p>
<p>to e.g. import outside images you can add the droppedImage() method to</p>
<p>it. The parameter passed to the event handles is a new offscreen</p>
<p>canvas element representing a copy of the original image element which</p>
<p>can be directly used, e.g. by assigning it to another Morph’s image</p>
<p>property.</p>
<p>The same applies to drops of audio or text files from outside the world</p>
<p>canvas.</p>
<p>Those are dispatched as</p>
<p>droppedAudio(anAudio, name)</p>
<p>droppedText(aString, name)</p>
<p>events to interested Morphs at the mouse pointer.</p>
<ol start="5" style="list-style-type: lower-alpha">
<li>keyboard events</li>
</ol>
<hr />
<p>The World dispatches the following key events to its active</p>
<p>keyboardReceiver:</p>
<p>keypress</p>
<p>keydown</p>
<pre><code>  keyup</code></pre>
<p>Currently the only morph which acts as keyboard receiver is</p>
<p>CursorMorph, the basic text editing widget. If you wish to add</p>
<p>keyboard support to your morph you need to add event handling</p>
<p>methods for</p>
<p>processKeyPress(event)</p>
<p>processKeyDown(event)</p>
<p>processKeyUp(event)</p>
<p>and activate them by assigning your morph to the World’s</p>
<p>keyboardReceiver</p>
<p>property.</p>
<p>Note that processKeyUp() is optional and doesn’t have to be present</p>
<p>if your morph doesn’t require it.</p>
<ol start="6" style="list-style-type: lower-alpha">
<li>resize event</li>
</ol>
<hr />
<p>The Window resize event is handled by the World and allows the</p>
<p>World’s extent to be adjusted so that it always completely fills</p>
<p>the browser’s visible page. You can turn off this default behavior</p>
<p>by setting the World’s</p>
<p>useFillPage</p>
<p>property to false.</p>
<p>Alternatively you can also initialize the World with the</p>
<p>useFillPage switch turned off from the beginning by passing the</p>
<p>false value as second parameter to the World’s constructor:</p>
<p>world = new World(aCanvas, false);</p>
<p>Use this when creating a web page with multiple Worlds.</p>
<p>if “useFillPage” is turned on the World dispatches an</p>
<p>reactToWorldResize(newBounds)</p>
<p>events to all of its children (toplevel only), allowing each to</p>
<p>adjust to the new World bounds by implementing a corresponding</p>
<p>method, the passed argument being the World’s new dimensions after</p>
<p>completing the resize. By default, the “reactToWorldResize” Method</p>
<p>does not exist.</p>
<p>Example:</p>
<p>Add the following method to your Morph to let it automatically</p>
<p>fill the whole World, but leave a 10 pixel border uncovered:</p>
<p>MyMorph.prototype.reactToWorldResize = function (rect) {</p>
<pre><code>this.changed();

this.bounds = rect.insetBy(10);

this.drawNew();

this.changed();</code></pre>
<p>};</p>
<ol start="7" style="list-style-type: lower-alpha">
<li>combined mouse-keyboard events</li>
</ol>
<hr />
<p>Occasionally you’ll want an object to react differently to a mouse</p>
<p>click or to some other mouse event while the user holds down a key</p>
<p>on the keyboard. Such “shift-click”, “ctl-click”, or “alt-click”</p>
<p>events can be implemented by querying the World’s</p>
<p>currentKey</p>
<p>property inside the function that reacts to the mouse event. This</p>
<p>property stores the keyCode of the key that’s currently pressed.</p>
<p>Once the key is released by the user it reverts to null.</p>
<ol start="4" style="list-style-type: decimal">
<li>stepping</li>
</ol>
<hr />
<p>Stepping is what makes Morphic “magical”. Two properties control</p>
<p>a morph’s stepping behavior: the fps attribute and the step()</p>
<p>method.</p>
<p>By default the</p>
<p>step()</p>
<p>method does nothing. As you can see in the examples of BouncerMorph</p>
<p>and MouseSensorMorph you can easily override this inherited method</p>
<p>to suit your needs.</p>
<p>By default the step() method is called once per display cycle.</p>
<p>Depending on the number of actively stepping morphs and the</p>
<p>complexity of your step() methods this can cause quite a strain on</p>
<p>your CPU, and also result in your application behaving differently</p>
<p>on slower computers than on fast ones.</p>
<p>setting</p>
<p>myMorph.fps</p>
<p>to a number lower than the interval for the main loop lets you free</p>
<p>system resources (albeit at the cost of a less responsive or slower</p>
<p>behavior for this particular morph).</p>
<ol start="5" style="list-style-type: decimal">
<li>creating new kinds of morphs</li>
</ol>
<hr />
<p>The real fun begins when you start to create new kinds of morphs</p>
<p>with customized shapes. Imagine, e.g. jigsaw puzzle pieces or</p>
<p>musical notes. For this you have to override the default</p>
<p>drawNew()</p>
<p>method.</p>
<p>This method creates a new offscreen Canvas and stores it in</p>
<p>the morph’s</p>
<p>image</p>
<p>property.</p>
<p>Use the following template for a start:</p>
<p>MyMorph.prototype.drawNew = function() {</p>
<pre><code>var context;

this.image = newCanvas(this.extent());

context = this.image.getContext(&#39;2d&#39;);

// use context to paint stuff here</code></pre>
<p>};</p>
<p>If your new morph stores or references other morphs outside of the</p>
<p>submorph tree in other properties, be sure to also override the</p>
<p>default</p>
<p>copyRecordingReferences()</p>
<p>method accordingly if you want it to support duplication.</p>
<ol start="6" style="list-style-type: decimal">
<li>development and user modes</li>
</ol>
<hr />
<p>When working with Squeak on Scratch or BYOB among the features I</p>
<p>like the best and use the most is inspecting what’s going on in</p>
<p>the World while it is up and running. That’s what development mode</p>
<p>is for (you could also call it debug mode). In essence development</p>
<p>mode controls which context menu shows up. In user mode right</p>
<p>clicking (or double finger tapping) a morph invokes its</p>
<p>customContextMenu</p>
<p>property, whereas in development mode only the general</p>
<p>developersMenu()</p>
<p>method is called and the resulting menu invoked. The developers’</p>
<p>menu features Gui-Builder-wise functionality to directly inspect,</p>
<p>take apart, reassamble and otherwise manipulate morphs and their</p>
<p>contents.</p>
<p>Instead of using the “customContextMenu” property you can also</p>
<p>assign a more dynamic contextMenu by overriding the general</p>
<p>userMenu()</p>
<p>method with a customized menu constructor. The difference between</p>
<p>the customContextMenu property and the userMenu() method is that</p>
<p>the former is also present in development mode and overrides the</p>
<p>developersMenu() result. For an example of how to use the</p>
<p>customContextMenu property have a look at TextMorph’s evaluation</p>
<p>menu, which is used for the Inspector’s evaluation pane.</p>
<p>When in development mode you can inspect every Morph’s properties</p>
<p>with the inspector, including all of its methods. The inspector</p>
<p>also lets you add, remove and rename properties, and even edit</p>
<p>their values at runtime. Like in a Smalltalk environment the inspect</p>
<p>features an evaluation pane into which you can type in arbitrary</p>
<p>JavaScript code and evaluate it in the context of the inspectee.</p>
<p>Use switching between user and development modes while you are</p>
<p>developing an application and disable switching to development once</p>
<p>you’re done and deploying, because generally you don’t want to</p>
<p>confuse end-users with inspectors and meta-level stuff.</p>
<ol start="7" style="list-style-type: decimal">
<li>turtle graphics</li>
</ol>
<hr />
<p>The basic Morphic kernel features a simple LOGO turtle constructor</p>
<p>called</p>
<p>PenMorph</p>
<p>which you can use to draw onto its parent Morph. By default every</p>
<p>Morph in the system (including the World) is able to act as turtle</p>
<p>canvas and can display pen trails. Pen trails will be lost whenever</p>
<p>the trails morph (the pen’s parent) performs a “drawNew()”</p>
<p>operation. If you want to create your own pen trails canvas, you</p>
<p>may wish to modify its</p>
<p>penTrails()</p>
<p>property, so that it keeps a separate offscreen canvas for pen</p>
<p>trails (and doesn’t loose these on redraw).</p>
<p>the following properties of PenMorph are relevant for turtle</p>
<p>graphics:</p>
<p>color - a Color</p>
<p>size - line width of pen trails</p>
<p>heading - degrees</p>
<p>isDown - drawing state</p>
<p>the following commands can be used to actually draw something:</p>
<p>up() - lift the pen up, further movements leave no trails</p>
<p>down() - set down, further movements leave trails</p>
<p>clear() - remove all trails from the current parent</p>
<p>forward(n) - move n steps in the current direction (heading)</p>
<p>turn(n) - turn right n degrees</p>
<p>Turtle graphics can best be explored interactively by creating a</p>
<p>new PenMorph object and by manipulating it with the inspector</p>
<p>widget.</p>
<p>NOTE: PenMorph has a special optimization for recursive operations</p>
<p>called</p>
<p>warp(function)</p>
<p>You can significantly speed up recursive ops and increase the depth</p>
<p>of recursion that’s displayable by wrapping WARP around your</p>
<p>recursive function call:</p>
<p>example:</p>
<p>myPen.warp(function () {</p>
<pre><code>myPen.tree(12, 120, 20);</code></pre>
<p>})</p>
<p>will be much faster than just invoking the tree function, because it</p>
<p>prevents the parent’s parent from keeping track of every single line</p>
<p>segment and instead redraws the outcome in a single pass.</p>
<ol start="8" style="list-style-type: decimal">
<li>damage list housekeeping</li>
</ol>
<hr />
<p>Morphic’s progressive display update comes at the cost of having to</p>
<p>cycle through a list of “broken rectangles” every display cycle. If</p>
<p>this list gets very long working this damage list can lead to a</p>
<p>seemingly dramatic slow-down of the Morphic system. Typically this</p>
<p>occurs when updating the layout of complex Morphs with very many</p>
<p>submorphs, e.g. when resizing an inspector window.</p>
<p>An effective strategy to cope with this is to use the inherited</p>
<p>trackChanges</p>
<p>property of the Morph prototype for damage list housekeeping.</p>
<p>The trackChanges property of the Morph prototype is a Boolean switch</p>
<p>that determines whether the World’s damage list (‘broken’ rectangles)</p>
<p>tracks changes. By default the switch is always on. If set to false</p>
<p>changes are not stored. This can be very useful for housekeeping of</p>
<p>the damage list in situations where a large number of (sub-) morphs</p>
<p>are changed more or less at once. Instead of keeping track of every</p>
<p>single submorph’s changes tremendous performance improvements can be</p>
<p>achieved by setting the trackChanges flag to false before propagating</p>
<p>the layout changes, setting it to true again and then storing the full</p>
<p>bounds of the surrounding morph. An an example refer to the</p>
<p>moveBy()</p>
<p>method of HandMorph, and to the</p>
<p>fixLayout()</p>
<p>method of InspectorMorph, or the</p>
<p>startLayout()</p>
<p>endLayout()</p>
<p>methods of SyntaxElementMorph in the Snap application.</p>
<ol start="9" style="list-style-type: decimal">
<li>minifying morphic.js</li>
</ol>
<hr />
<p>Coming from Smalltalk and being a Squeaker at heart I am a huge fan</p>
<p>of browsing the code itself to make sense of it. Therefore I have</p>
<p>included this documentation and (too little) inline comments so all</p>
<p>you need to get going is this very file.</p>
<p>Nowadays with live streaming HD video even on mobile phones 250 KB</p>
<p>shouldn’t be a big strain on bandwith, still minifying and even</p>
<p>compressing morphic.js down do about 100 KB may sometimes improve</p>
<p>performance in production use.</p>
<p>Being an attorney-at-law myself you programmer folk keep harassing</p>
<p>me with rabulistic nitpickings about free software licenses. I’m</p>
<p>releasing morphic.js under an AGPL license. Therefore please make</p>
<p>sure to adhere to that license in any minified or compressed version.</p>
<ol start="8" style="list-style-type: upper-roman">
<li>acknowledgements</li>
</ol>
<hr />
<p>The original Morphic was designed and written by Randy Smith and</p>
<p>John Maloney for the SELF programming language, and later ported to</p>
<p>Squeak (Smalltalk) by John Maloney and Dan Ingalls, who has also</p>
<p>ported it to JavaScript (the Lively Kernel), once again setting</p>
<p>a “Gold Standard” for self sustaining systems which morphic.js</p>
<p>cannot and does not aspire to meet.</p>
<p>This Morphic implementation for JavaScript is not a direct port of</p>
<p>Squeak’s Morphic, but still many individual functions have been</p>
<p>ported almost literally from Squeak, sometimes even including their</p>
<p>comments, e.g. the morph duplication mechanism fullCopy(). Squeak</p>
<p>has been a treasure trove, and if morphic.js looks, feels and</p>
<p>smells a lot like Squeak, I’ll take it as a compliment.</p>
<p>Evelyn Eastmond has inspired and encouraged me with her wonderful</p>
<p>implementation of DesignBlocksJS. Thanks for sharing code, ideas</p>
<p>and enthusiasm for programming.</p>
<p>John Maloney has been my mentor and my source of inspiration for</p>
<p>these Morphic experiments. Thanks for the critique, the suggestions</p>
<p>and explanations for all things Morphic and for being my all time</p>
<p>programming hero.</p>
<p>I have originally written morphic.js in Florian Balmer’s Notepad2</p>
<p>editor for Windows and later switched to Apple’s Dashcode. I’ve also</p>
<p>come to depend on both Douglas Crockford’s JSLint, Mozilla’s Firebug</p>
<p>and Google’s Chrome to get it right.</p>
<ol start="9" style="list-style-type: upper-roman">
<li>contributors</li>
</ol>
<hr />
<p>Joe Otto found and fixed many early bugs and taught me some tricks.</p>
<p>Nathan Dinsmore contributed mouse wheel scrolling, cached</p>
<p>background texture handling and countless bug fixes.</p>
<p>Ian Reynolds contributed backspace key handling for Chrome.</p>
<ul>
<li>Jens Mönig</li>
</ul>
<p>FrameMorph //////////////////////////////////////////////////////////</p>
<p>I clip my submorphs at my bounds. Which potentially saves a lot of redrawing</p>
<p>and event handling.</p>
</body>
</html>
