<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <link rel="stylesheet" href="pandoc.css" type="text/css" />
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#zombie-kernel">Zombie-Kernel</a><ul>
<li><a href="#contents">Contents</a><ul>
<li><a href="#high-level-view">High-level view</a></li>
<li><a href="#programming-guide">Programming guide</a></li>
<li><a href="#colophon">Colophon</a></li>
</ul></li>
</ul></li>
<li><a href="#hierarchy">1. Hierarchy</a></li>
<li><a href="#yet-to-implement">2. Yet to implement</a></li>
<li><a href="#open-issues">3. Open issues</a></li>
<li><a href="#browser-compatibility">4. Browser compatibility</a></li>
<li><a href="#the-big-picture">5. The big picture</a></li>
<li><a href="#programming-guide-1">6. Programming guide</a><ul>
<li><a href="#setting-up-a-web-page---basics">1. Setting up a web page - basics</a></li>
<li><a href="#setting-up-a-web-page-for-single-world">2. Setting up a web page for single world</a><ul>
<li><a href="#b-multiple-worlds">(b) multiple worlds</a></li>
<li><a href="#c-an-application">(c) an application</a></li>
<li><a href="#manipulating-morphs">(2) manipulating morphs</a></li>
<li><a href="#events">(3) events</a></li>
<li><a href="#a-mouse-events">(a) mouse events:</a></li>
<li><a href="#b-context-menu">(b) context menu:</a></li>
<li><a href="#c-dragging">(c) dragging:</a></li>
<li><a href="#d-dropping">(d) dropping:</a></li>
<li><a href="#e-keyboard-events">(e) keyboard events</a></li>
<li><a href="#f-resize-event">(f) resize event</a></li>
<li><a href="#g-combined-mouse-keyboard-events">(g) combined mouse-keyboard events</a></li>
<li><a href="#stepping">(4) stepping</a></li>
<li><a href="#creating-new-kinds-of-morphs">(5) creating new kinds of morphs</a></li>
<li><a href="#development-and-user-modes">(6) development and user modes</a></li>
<li><a href="#turtle-graphics">(7) turtle graphics</a></li>
<li><a href="#damage-list-housekeeping">(8) damage list housekeeping</a></li>
<li><a href="#minifying-morphic.js">(9) minifying morphic.js</a></li>
</ul></li>
<li><a href="#colophon-1">Colophon</a><ul>
<li><a href="#viii.-acknowledgements">VIII. acknowledgements</a></li>
<li><a href="#ix.-contributors">IX. contributors</a></li>
</ul></li>
</ul></li>
</ul>
</div>
<h1 id="zombie-kernel"><a href="#TOC">Zombie-Kernel</a></h1>
<p>a lively Web-GUI.</p>
<p>Built on Morphic.js, written by Jens Mönig (jens@moenig.org), Copyright (C) 2012 by Jens Mönig.</p>
<p>This document adapted from the original Morphic.js documentation, written by Jens Mönig (jens@moenig.org).</p>
<h2 id="contents"><a href="#TOC">Contents</a></h2>
<h3 id="high-level-view"><a href="#TOC">High-level view</a></h3>
<ol style="list-style-type: decimal">
<li><p>Inheritance hierarchy</p></li>
<li><p>Yet to implement</p></li>
<li><p>Open issues</p></li>
<li><p>Browser compatibility</p></li>
<li><p>The big picture</p></li>
</ol>
<h3 id="programming-guide"><a href="#TOC">Programming guide</a></h3>
<ol style="list-style-type: decimal">
<li><p>setting up a web page - basics</p></li>
<li><p>setting up a web page for single world</p></li>
<li><p>setting up a web page for multiple worlds</p></li>
<li><p>setting up an application</p></li>
<li><p>events into</p></li>
<li><p>mouse events</p></li>
<li><p>mouse events - context menu</p></li>
<li><p>mouse events - dragging</p></li>
<li><p>mouse events - dropping</p></li>
<li><p>mouse events - resize event</p></li>
<li><p>keyboard events</p></li>
<li><p>combined mouse-keyboard events</p></li>
<li><p>stepping</p></li>
<li><p>creating new kinds of morphs</p></li>
<li><p>development and user modes</p></li>
<li><p>turtle graphics</p></li>
<li><p>damage list housekeeping</p></li>
<li><p>minifying morphic.js</p></li>
</ol>
<h3 id="colophon"><a href="#TOC">Colophon</a></h3>
<ol start="18" style="list-style-type: decimal">
<li><p>acknowledgements</p></li>
<li><p>contributors</p></li>
</ol>
<h1 id="hierarchy"><a href="#TOC">1. Hierarchy</a></h1>
<p>The following tree lists all constructors hierarchically, indentation indicating inheritance. Refer to this list to get a contextual overview:</p>
<ul>
<li><p>Point</p></li>
<li><p>Rectangle</p></li>
<li><p>Color</p></li>
<li><p>Node</p></li>
<li><p>Morph</p>
<ul>
<li><p>BlinkerMorph</p></li>
<li><p>CursorMorph</p></li>
<li><p>BouncerMorph*</p></li>
<li><p>BoxMorph</p></li>
<li><p>InspectorMorph</p></li>
<li><p>MenuMorph</p></li>
<li><p>MouseSensorMorph*</p></li>
<li><p>SpeechBubbleMorph</p></li>
<li><p>CircleBoxMorph</p>
<ul>
<li><p>SliderButtonMorph</p></li>
<li><p>SliderMorph</p></li>
</ul></li>
<li><p>ColorPaletteMorph</p>
<ul>
<li>GrayPaletteMorph</li>
</ul></li>
<li><p>ColorPickerMorph</p></li>
<li><p>FrameMorph</p>
<ul>
<li><p>ScrollFrameMorph</p>
<ul>
<li>ListMorph</li>
</ul></li>
<li><p>StringFieldMorph</p></li>
<li><p>WorldMorph</p></li>
</ul></li>
<li><p>HandleMorph</p></li>
<li><p>HandMorph</p></li>
<li><p>PenMorph</p></li>
<li><p>ShadowMorph</p></li>
<li><p>StringMorph</p></li>
<li><p>TextMorph</p></li>
<li><p>TriggerMorph</p>
<ul>
<li>MenuItemMorph</li>
</ul></li>
</ul></li>
</ul>
<h1 id="yet-to-implement"><a href="#TOC">2. Yet to implement</a></h1>
<p>Keyboard support for scroll frames and lists.</p>
<h1 id="open-issues"><a href="#TOC">3. Open issues</a></h1>
<p>Blurry shadows don’t work well in Chrome.</p>
<h1 id="browser-compatibility"><a href="#TOC">4. Browser compatibility</a></h1>
<p>Great care and considerable effort has been taken to make morphic.js runnable and appearing exactly the same on all current browsers:</p>
<ul>
<li><p>Firefox for Windows</p></li>
<li><p>Firefox for Mac</p></li>
<li><p>Chrome for Windows (blurry shadows have some issues)</p></li>
<li><p>Chrome for Mac</p></li>
<li><p>Safari for Windows</p></li>
<li><p>Safari for Mac</p></li>
<li><p>Safari for iOS (mobile)</p></li>
<li><p>IE for Windows</p></li>
<li><p>Opera for Windows</p></li>
<li><p>Opera for Mac</p></li>
</ul>
<h1 id="the-big-picture"><a href="#TOC">5. The big picture</a></h1>
<p>Morphic.js is completely based on Canvas and JavaScript, it is just Morphic, nothing else. Morphic.js is very basic and covers only the bare essentials:</p>
<ul>
<li><p>a stepping mechanism (a time-sharing multiplexer for lively user interaction ontop of a single OS/browser thread)</p></li>
<li><p>progressive display updates (only dirty rectangles are redrawn in each display cycle)</p></li>
<li><p>a tree structure</p></li>
<li><p>a single World per Canvas element (although you can have multiple worlds in multiple Canvas elements on the same web page)</p></li>
<li><p>a single Hand per World (but you can support multi-touch events)</p></li>
<li><p>a single text entry focus per World</p></li>
</ul>
<p>In its current state morphic.js doesn’t support Transforms (you cannot rotate Morphs), but with PenMorph there already is a simple LOGO-like turtle that you can use to draw onto any Morph it is attached to. I’m planning to add special Morphs that support these operations later on, but not for every Morph in the system.</p>
<p>Therefore these additions (“sprites” etc.) are likely to be part of other libraries (“microworld.js”) in separate files.</p>
<p>The purpose of morphic.js is to provide a malleable framework that will let me experiment with lively GUIs for my hobby horse, which is drag-and-drop, blocks based programming languages. Those things (BYOB4 - http://byob.berkeley.edu) will be written using morphic.js as a library.</p>
<h1 id="programming-guide-1"><a href="#TOC">6. Programming guide</a></h1>
<p>Morphic.js provides a library for lively GUIs inside single HTML Canvas elements. Each such canvas element functions as a “world” in which other visible shapes (“morphs”) can be positioned and manipulated, often directly and interactively by the user. Morphs are tree nodes and may contain any number of submorphs (“children”).</p>
<p>All things visible in a morphic World are morphs themselves, i.e. all text rendering, blinking cursors, entry fields, menus, buttons, sliders, windows and dialog boxes etc. are created with morphic.js rather than using HTML DOM elements, and as a consequence can be changed and adjusted by the programmer regardless of proprietary browser behavior.</p>
<p>Each World has an - invisible - “Hand” resembling the mouse cursor (or the user’s finger on touch screens) which handles mouse events, and may also have a keyboardReceiver to handle key events.</p>
<p>The basic idea of Morphic is to continuously run display cycles and to incrementally update the screen by only redrawing those World regions which have been “dirtied” since the last redraw. Before each shape is processed for redisplay it gets the chance to perform a “step” procedure, thus allowing for an illusion of concurrency.</p>
<h2 id="setting-up-a-web-page---basics"><a href="#TOC">1. Setting up a web page - basics</a></h2>
<p>Setting up a web page for Morphic always involves three steps: adding one or more Canvas elements, defining one or more worlds, initializing and starting the main loop.</p>
<h2 id="setting-up-a-web-page-for-single-world"><a href="#TOC">2. Setting up a web page for single world</a></h2>
<p>Most commonly you will want your World to fill the browsers’s whole client area. This default situation is easiest and most straight forward.</p>
<p>Example html file:</p>
<pre><code>&lt;!DOCTYPE html&gt;  

&lt;html&gt;

  &lt;head&gt;

    &lt;title&gt;Morphic!&lt;/title&gt;

    &lt;script type=&quot;text/javascript&quot; src=&quot;morphic.js&quot;&gt;&lt;/script&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;



      var world;



      window.onload = function () {

        world = new WorldMorph(

          document.getElementById(&#39;world&#39;));

        setInterval(loop, 50);

      };



      function loop() {

        world.doOneCycle();

      }



    &lt;/script&gt;

  &lt;/head&gt;

  &lt;body&gt;



    &lt;canvas id=&quot;world&quot; tabindex=&quot;1&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;

      &lt;p&gt;Your browser doesn&#39;t support canvas.&lt;/p&gt;

    &lt;/canvas&gt;



  &lt;/body&gt;

&lt;/html&gt;</code></pre>
<p>if you use ScrollFrames or otherwise plan to support mouse wheel scrolling events, you might also add the following inline-CSS attribute to the Canvas element:</p>
<pre><code>style=&quot;position: absolute;&quot;</code></pre>
<p>which will prevent the World to be scrolled around instead of the elements inside of it in some browsers.</p>
<h3 id="b-multiple-worlds"><a href="#TOC">(b) multiple worlds</a></h3>
<p>If you wish to create a web page with more than one world, make sure to prevent each world from auto-filling the whole page and include it in the main loop. It’s also a good idea to give each world its own tabindex:</p>
<p>Example html file:</p>
<pre><code>&lt;!DOCTYPE html&gt;

&lt;html&gt;

  &lt;head&gt;

    &lt;title&gt;Morphic!&lt;/title&gt;

    &lt;script type=&quot;text/javascript&quot; src=&quot;morphic.js&quot;&gt;&lt;/script&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;



      var world1, world2;



      window.onload = function () {

        world1 = new WorldMorph(document.getElementById(&#39;world1&#39;), false);

        world2 = new WorldMorph(document.getElementById(&#39;world2&#39;), false);

        setInterval(loop, 50);

      };





      function loop() {

        world1.doOneCycle();

        world2.doOneCycle();

      }



    &lt;/script&gt;

  &lt;/head&gt;

  &lt;body&gt;



    &lt;p&gt;first world:&lt;/p&gt;



    &lt;canvas id=&quot;world1&quot; tabindex=&quot;1&quot; width=&quot;600&quot; height=&quot;400&quot;&gt;

      &lt;p&gt;Your browser doesn&#39;t support canvas.&lt;/p&gt;

    &lt;/canvas&gt;



    &lt;p&gt;second world:&lt;/p&gt;



    &lt;canvas id=&quot;world2&quot; tabindex=&quot;2&quot; width=&quot;400&quot; height=&quot;600&quot;&gt;

      &lt;p&gt;Your browser doesn&#39;t support canvas.&lt;/p&gt;

    &lt;/canvas&gt;



  &lt;/body&gt;

&lt;/html&gt;</code></pre>
<h3 id="c-an-application"><a href="#TOC">(c) an application</a></h3>
<p>Of course, most of the time you don’t want to just plain use the standard Morhic World “as is” out of the box, but write your own application (something like Scratch!) in it. For such an application you’ll create your own morph prototypes, perhaps assemble your own “window frame” and bring it all to life in a customized World state. the following example creates a simple snake-like mouse drawing game.</p>
<p>Example html file:</p>
<pre><code>&lt;!DOCTYPE html&gt;

&lt;html&gt;

  &lt;head&gt;

    &lt;title&gt;touch me!&lt;/title&gt;

    &lt;script type=&quot;text/javascript&quot; src=&quot;morphic.js&quot;&gt;&lt;/script&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;



      var worldCanvas, sensor;



      window.onload = function () {



        var x, y, w, h;

        worldCanvas = document.getElementById(&#39;world&#39;);

        world = new WorldMorph(worldCanvas);

        world.isDevMode = false;

        world.color = new Color();



        w = 100;

        h = 100;



        x = 0;

        y = 0;



        while ((y * h) &lt; world.height()) {

          while ((x * w) &lt; world.width()) {



            sensor = new MouseSensorMorph();

            sensor.setPosition(new Point(x * w, y * h));

            sensor.alpha = 0;

            sensor.setExtent(new Point(w, h));

            world.add(sensor);

            x += 1;



          }



          x = 0;

          y += 1;



        }

        setInterval(loop, 50);

      };





      function loop() {

        world.doOneCycle();

      }



    &lt;/script&gt;

  &lt;/head&gt;



  &lt;body bgcolor=&#39;black&#39;&gt;

    &lt;canvas id=&quot;world&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;

      &lt;p&gt;Your browser doesn&#39;t support canvas.&lt;/p&gt;

    &lt;/canvas&gt;

  &lt;/body&gt;

&lt;/html&gt;</code></pre>
<p>To get an idea how you can craft your own custom morph prototypes I’ve included two examples which should give you an idea how to add properties, override inherited methods and use the stepping mechanism for “livelyness”:</p>
<p>BouncerMorph</p>
<p>MouseSensorMorph</p>
<p>For the sake of sharing a single file I’ve included those examples in morphic.js itself. Usually you’ll define your additions in a separate file and keep morphic.js untouched.</p>
<h3 id="manipulating-morphs"><a href="#TOC">(2) manipulating morphs</a></h3>
<p>There are many methods to programmatically manipulate morphs. Among the most important and common ones among all morphs are the following nine:</p>
<ul>
<li><p>hide()</p></li>
<li><p>show()</p></li>
<li><p>setPosition(aPoint)</p></li>
<li><p>setExtent(aPoint)</p></li>
<li><p>setColor(aColor)</p></li>
<li><p>add(submorph) - attaches submorph ontop</p></li>
<li><p>addBack(submorph) - attaches submorph underneath</p></li>
<li><p>fullCopy() - duplication</p></li>
<li><p>destroy() - deletion</p></li>
</ul>
<h3 id="events"><a href="#TOC">(3) events</a></h3>
<p>All user (and system) interaction is triggered by events, which are passed on from the root element - the World - to its submorphs. The World contains a list of system (browser) events it reacts to in its</p>
<p>initEventListeners()</p>
<p>method. Currently there are</p>
<ul>
<li><p>mouse</p>
<ul>
<li>drop</li>
</ul></li>
<li><p>keyboard</p></li>
<li><p>(window) resize</p></li>
</ul>
<p>events.</p>
<p>These system events are dispatched within the morphic World by the World’s Hand and its keyboardReceiver (usually the active text cursor).</p>
<h3 id="a-mouse-events"><a href="#TOC">(a) mouse events:</a></h3>
<p>The Hand dispatches the following mouse events to relevant morphs:</p>
<p>mouseDownLeft</p>
<p>mouseDownRight</p>
<p>mouseClickLeft</p>
<p>mouseClickRight</p>
<p>mouseEnter</p>
<p>mouseLeave</p>
<p>mouseEnterDragging</p>
<p>mouseLeaveDragging</p>
<p>mouseMove</p>
<p>mouseScroll</p>
<p>If you wish your morph to react to any such event, simply add a method of the same name as the event, e.g:</p>
<p>MyMorph.prototype.mouseMove = function(pos) {};</p>
<p>The only optional parameter of such a method is a Point object indicating the current position of the Hand inside the World’s coordinate system.</p>
<p>Events may be “bubbled” up a morph’s owner chain by calling</p>
<p>this.escalateEvent(functionName, arg)</p>
<p>in the event handler method’s code.</p>
<p>Likewise, removing the event handler method will render your morph passive to the event in question.</p>
<h3 id="b-context-menu"><a href="#TOC">(b) context menu:</a></h3>
<p>By default right-clicking (or single-finger tap-and-hold) on a morph also invokes its context menu (in addition to firing the mouseClickRight event). A morph’s context menu can be customized by assigning a Menu instance to its</p>
<p>customContextMenu</p>
<p>property, or altogether suppressed by overriding its inherited</p>
<p>contextMenu()</p>
<p>method.</p>
<h3 id="c-dragging"><a href="#TOC">(c) dragging:</a></h3>
<p>Dragging a morph is initiated when the left mouse button is pressed, held and the mouse is moved.</p>
<p>You can control whether a morph is draggable by setting its</p>
<p>isDraggable</p>
<p>property either to false or true. If a morph isn’t draggable itself it will pass the pick-up request up its owner chain. This lets you create draggable composite morphs like Windows, DialogBoxes, Sliders etc.</p>
<p>Sometimes it is desireable to make “template” shapes which cannot be moved themselves, but from which instead duplicates can be peeled off. This is especially useful for building blocks in construction kits, e.g. the MIT-Scratch palette. Morphic.js lets you control this functionality by setting the</p>
<p>isTemplate</p>
<p>property flag to true for any morph whose “isDraggable” property is turned off. When dragging such a Morph the hand will instead grab a duplicate of the template whose “isDraggable” flag is true and whose “isTemplate” flag is false, in other words: a non-template.</p>
<p>Dragging is indicated by adding a drop shadow to the morph in hand. If a morph follows the hand without displaying a drop shadow it is merely being moved about without changing its parent (owner morph), e.g. when “dragging” a morph handle to resize its owner, or when “dragging” a slider button.</p>
<p>Right before a morph is picked up its</p>
<p>prepareToBeGrabbed(handMorph)</p>
<p>method is invoked, if it is present. Immediately after the pick-up the former parent’s</p>
<p>reactToGrabOf(grabbedMorph)</p>
<p>method is called, again only if it exists.</p>
<p>Similar to events, these methods are optional and don’t exist by default. For a simple example of how they can be used to adjust scroll bars in a scroll frame please have a look at their implementation in FrameMorph.</p>
<h3 id="d-dropping"><a href="#TOC">(d) dropping:</a></h3>
<p>Dropping is triggered when the left mouse button is either pressed or released while the Hand is dragging a morph.</p>
<p>Dropping a morph causes it to become embedded in a new owner morph.</p>
<p>You can control this embedding behavior by setting the prospective drop target’s</p>
<p>acceptsDrops</p>
<p>property to either true or false, or by overriding its inherited</p>
<p>wantsDropOf(aMorph)</p>
<p>method.</p>
<p>Right after a morph has been dropped its</p>
<p>justDropped(handMorph)</p>
<p>method is called, and its new parent’s</p>
<p>reactToDropOf(droppedMorph, handMorph)</p>
<p>method is invoked, again only if each method exists.</p>
<p>Similar to events, these methods are optional and by default are not present in morphs by default (watch out for inheritance, though!). For a simple example of how they can be used to adjust scroll bars in a scroll frame please have a look at their implementation in FrameMorph.</p>
<p>Drops of image elements from outside the world canvas are dispatched as</p>
<p>droppedImage(aCanvas, name)</p>
<p>events to interested Morphs at the mouse pointer. If you want you Morph to e.g. import outside images you can add the droppedImage() method to it. The parameter passed to the event handles is a new offscreen canvas element representing a copy of the original image element which can be directly used, e.g. by assigning it to another Morph’s image property.</p>
<p>The same applies to drops of audio or text files from outside the world canvas.</p>
<p>Those are dispatched as</p>
<p>droppedAudio(anAudio, name)</p>
<p>droppedText(aString, name)</p>
<p>events to interested Morphs at the mouse pointer.</p>
<h3 id="e-keyboard-events"><a href="#TOC">(e) keyboard events</a></h3>
<p>The World dispatches the following key events to its active keyboardReceiver:</p>
<p>keypress</p>
<p>keydown</p>
<pre><code>  keyup</code></pre>
<p>Currently the only morph which acts as keyboard receiver is CursorMorph, the basic text editing widget. If you wish to add keyboard support to your morph you need to add event handling methods for</p>
<p>processKeyPress(event)</p>
<p>processKeyDown(event)</p>
<p>processKeyUp(event)</p>
<p>and activate them by assigning your morph to the World’s</p>
<p>keyboardReceiver</p>
<p>property.</p>
<p>Note that processKeyUp() is optional and doesn’t have to be present if your morph doesn’t require it.</p>
<h3 id="f-resize-event"><a href="#TOC">(f) resize event</a></h3>
<p>The Window resize event is handled by the World and allows the World’s extent to be adjusted so that it always completely fills the browser’s visible page. You can turn off this default behavior by setting the World’s</p>
<p>useFillPage</p>
<p>property to false.</p>
<p>Alternatively you can also initialize the World with the useFillPage switch turned off from the beginning by passing the false value as second parameter to the World’s constructor:</p>
<p>world = new World(aCanvas, false);</p>
<p>Use this when creating a web page with multiple Worlds.</p>
<p>if “useFillPage” is turned on the World dispatches an</p>
<p>reactToWorldResize(newBounds)</p>
<p>events to all of its children (toplevel only), allowing each to adjust to the new World bounds by implementing a corresponding method, the passed argument being the World’s new dimensions after completing the resize. By default, the “reactToWorldResize” Method does not exist.</p>
<p>Example:</p>
<p>Add the following method to your Morph to let it automatically fill the whole World, but leave a 10 pixel border uncovered:</p>
<pre><code>MyMorph.prototype.reactToWorldResize = function (rect) {

  this.changed();

  this.bounds = rect.insetBy(10);

  this.drawNew();

  this.changed();

};</code></pre>
<h3 id="g-combined-mouse-keyboard-events"><a href="#TOC">(g) combined mouse-keyboard events</a></h3>
<p>Occasionally you’ll want an object to react differently to a mouse click or to some other mouse event while the user holds down a key on the keyboard. Such “shift-click”, “ctl-click”, or “alt-click” events can be implemented by querying the World’s</p>
<p>currentKey</p>
<p>property inside the function that reacts to the mouse event. This property stores the keyCode of the key that’s currently pressed.</p>
<p>Once the key is released by the user it reverts to null.</p>
<h3 id="stepping"><a href="#TOC">(4) stepping</a></h3>
<p>Stepping is what makes Morphic “magical”. Two properties control a morph’s stepping behavior: the fps attribute and the step() method.</p>
<p>By default the</p>
<p>step()</p>
<p>method does nothing. As you can see in the examples of BouncerMorph and MouseSensorMorph you can easily override this inherited method to suit your needs.</p>
<p>By default the step() method is called once per display cycle.</p>
<p>Depending on the number of actively stepping morphs and the complexity of your step() methods this can cause quite a strain on your CPU, and also result in your application behaving differently on slower computers than on fast ones.</p>
<p>Setting</p>
<p>myMorph.fps</p>
<p>to a number lower than the interval for the main loop lets you free system resources (albeit at the cost of a less responsive or slower behavior for this particular morph).</p>
<h3 id="creating-new-kinds-of-morphs"><a href="#TOC">(5) creating new kinds of morphs</a></h3>
<p>The real fun begins when you start to create new kinds of morphs with customized shapes. Imagine, e.g. jigsaw puzzle pieces or musical notes. For this you have to override the default</p>
<p>drawNew()</p>
<p>method.</p>
<p>This method creates a new offscreen Canvas and stores it in the morph’s</p>
<p>image</p>
<p>property.</p>
<p>Use the following template for a start:</p>
<pre><code>MyMorph.prototype.drawNew = function() {

  var context;

  this.image = newCanvas(this.extent());

  context = this.image.getContext(&#39;2d&#39;);

  // use context to paint stuff here

};</code></pre>
<p>If your new morph stores or references other morphs outside of the submorph tree in other properties, be sure to also override the default</p>
<p>copyRecordingReferences()</p>
<p>method accordingly if you want it to support duplication.</p>
<h3 id="development-and-user-modes"><a href="#TOC">(6) development and user modes</a></h3>
<p>When working with Squeak on Scratch or BYOB among the features I like the best and use the most is inspecting what’s going on in the World while it is up and running. That’s what development mode is for (you could also call it debug mode). In essence development mode controls which context menu shows up. In user mode right clicking (or double finger tapping) a morph invokes its</p>
<p>customContextMenu</p>
<p>property, whereas in development mode only the general</p>
<p>developersMenu()</p>
<p>method is called and the resulting menu invoked. The developers’ menu features Gui-Builder-wise functionality to directly inspect, take apart, reassamble and otherwise manipulate morphs and theircontents.</p>
<p>Instead of using the “customContextMenu” property you can also assign a more dynamic contextMenu by overriding the general</p>
<p>userMenu()</p>
<p>method with a customized menu constructor. The difference between the customContextMenu property and the userMenu() method is that the former is also present in development mode and overrides the developersMenu() result. For an example of how to use the customContextMenu property have a look at TextMorph’s evaluation menu, which is used for the Inspector’s evaluation pane.</p>
<p>When in development mode you can inspect every Morph’s properties with the inspector, including all of its methods. The inspector also lets you add, remove and rename properties, and even edit their values at runtime. Like in a Smalltalk environment the inspect features an evaluation pane into which you can type in arbitrary JavaScript code and evaluate it in the context of the inspectee.</p>
<p>Use switching between user and development modes while you are developing an application and disable switching to development once you’re done and deploying, because generally you don’t want to confuse end-users with inspectors and meta-level stuff.</p>
<h3 id="turtle-graphics"><a href="#TOC">(7) turtle graphics</a></h3>
<p>The basic Morphic kernel features a simple LOGO turtle constructor called</p>
<p>PenMorph</p>
<p>which you can use to draw onto its parent Morph. By default every Morph in the system (including the World) is able to act as turtle canvas and can display pen trails. Pen trails will be lost whenever the trails morph (the pen’s parent) performs a “drawNew()” operation. If you want to create your own pen trails canvas, you may wish to modify its</p>
<p>penTrails()</p>
<p>property, so that it keeps a separate offscreen canvas for pen trails (and doesn’t loose these on redraw).</p>
<p>The following properties of PenMorph are relevant for turtle graphics:</p>
<p>color - a Color</p>
<p>size - line width of pen trails</p>
<p>heading - degrees</p>
<p>isDown - drawing state</p>
<p>The following commands can be used to actually draw something:</p>
<p>up() - lift the pen up, further movements leave no trails</p>
<p>down() - set down, further movements leave trails</p>
<p>clear() - remove all trails from the current parent</p>
<p>forward(n) - move n steps in the current direction (heading)</p>
<p>turn(n) - turn right n degrees</p>
<p>Turtle graphics can best be explored interactively by creating a new PenMorph object and by manipulating it with the inspector widget.</p>
<p>NOTE: PenMorph has a special optimization for recursive operations called</p>
<p>warp(function)</p>
<p>You can significantly speed up recursive ops and increase the depth of recursion that’s displayable by wrapping WARP around your recursive function call:</p>
<p>Example:</p>
<pre><code>myPen.warp(function () {

  myPen.tree(12, 120, 20);

})</code></pre>
<p>will be much faster than just invoking the tree function, because it prevents the parent’s parent from keeping track of every single line segment and instead redraws the outcome in a single pass.</p>
<h3 id="damage-list-housekeeping"><a href="#TOC">(8) damage list housekeeping</a></h3>
<p>Morphic’s progressive display update comes at the cost of having to cycle through a list of “broken rectangles” every display cycle. If this list gets very long working this damage list can lead to a seemingly dramatic slow-down of the Morphic system. Typically this occurs when updating the layout of complex Morphs with very many submorphs, e.g. when resizing an inspector window.</p>
<p>An effective strategy to cope with this is to use the inherited</p>
<p>trackChanges</p>
<p>property of the Morph prototype for damage list housekeeping.</p>
<p>The trackChanges property of the Morph prototype is a Boolean switch that determines whether the World’s damage list (‘broken’ rectangles) tracks changes. By default the switch is always on. If set to false changes are not stored. This can be very useful for housekeeping of the damage list in situations where a large number of (sub-) morphs are changed more or less at once. Instead of keeping track of every single submorph’s changes tremendous performance improvements can be achieved by setting the trackChanges flag to false before propagating the layout changes, setting it to true again and then storing the full bounds of the surrounding morph. An an example refer to the</p>
<p>moveBy()</p>
<p>method of HandMorph, and to the</p>
<p>fixLayout()</p>
<p>method of InspectorMorph, or the</p>
<p>startLayout()</p>
<p>endLayout()</p>
<p>methods of SyntaxElementMorph in the Snap application.</p>
<h3 id="minifying-morphic.js"><a href="#TOC">(9) minifying morphic.js</a></h3>
<p>Coming from Smalltalk and being a Squeaker at heart I am a huge fan of browsing the code itself to make sense of it. Therefore I have included this documentation and (too little) inline comments so all you need to get going is this very file.</p>
<p>Nowadays with live streaming HD video even on mobile phones 250 KB shouldn’t be a big strain on bandwith, still minifying and even compressing morphic.js down do about 100 KB may sometimes improve performance in production use.</p>
<p>Being an attorney-at-law myself you programmer folk keep harassing me with rabulistic nitpickings about free software licenses. I’m releasing morphic.js under an AGPL license. Therefore please make sure to adhere to that license in any minified or compressed version.</p>
<h2 id="colophon-1"><a href="#TOC">Colophon</a></h2>
<h3 id="viii.-acknowledgements"><a href="#TOC">VIII. acknowledgements</a></h3>
<p>The original Morphic was designed and written by Randy Smith and John Maloney for the SELF programming language, and later ported to Squeak (Smalltalk) by John Maloney and Dan Ingalls, who has also ported it to JavaScript (the Lively Kernel), once again setting a “Gold Standard” for self sustaining systems which morphic.js cannot and does not aspire to meet.</p>
<p>This Morphic implementation for JavaScript is not a direct port of Squeak’s Morphic, but still many individual functions have been ported almost literally from Squeak, sometimes even including their comments, e.g. the morph duplication mechanism fullCopy(). Squeak has been a treasure trove, and if morphic.js looks, feels and smells a lot like Squeak, I’ll take it as a compliment.</p>
<p>Evelyn Eastmond has inspired and encouraged me with her wonderful implementation of DesignBlocksJS. Thanks for sharing code, ideas and enthusiasm for programming.</p>
<p>John Maloney has been my mentor and my source of inspiration for these Morphic experiments. Thanks for the critique, the suggestions and explanations for all things Morphic and for being my all time programming hero.</p>
<p>I have originally written morphic.js in Florian Balmer’s Notepad2 editor for Windows and later switched to Apple’s Dashcode. I’ve also come to depend on both Douglas Crockford’s JSLint, Mozilla’s Firebug and Google’s Chrome to get it right.</p>
<h3 id="ix.-contributors"><a href="#TOC">IX. contributors</a></h3>
<ul>
<li><p>Joe Otto found and fixed many early bugs and taught me some tricks.</p></li>
<li><p>Nathan Dinsmore contributed mouse wheel scrolling, cached background texture handling and countless bug fixes.</p></li>
<li><p>Ian Reynolds contributed backspace key handling for Chrome.</p></li>
</ul>
<p>Jens Mönig</p>
<p>FrameMorph //////////////////////////////////////////////////////////</p>
<p>I clip my submorphs at my bounds. Which potentially saves a lot of redrawing</p>
<p>and event handling.</p>
</body>
</html>
