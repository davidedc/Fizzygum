// Generated by CoffeeScript 1.3.3
var BlinkerMorph, BouncerMorph, BoxMorph, CaretMorph, CircleBoxMorph, Color, ColorPaletteMorph, ColorPickerMorph, FrameMorph, GrayPaletteMorph, HandMorph, HandleMorph, InspectorMorph, ListMorph, MenuItemMorph, MenuMorph, Morph, MorphicNode, MorphsListMorph, MouseSensorMorph, Mousetrap, PenMorph, Point, Point2, Rectangle, ScrollFrameMorph, ShadowMorph, SliderButtonMorph, SliderMorph, SpeechBubbleMorph, StringFieldMorph, StringMorph, SystemTest_SimpleMenuTest, SystemTestsRecorderAndPlayer, TextMorph, TriggerMorph, WorldMorph, clone, contains, copy, degrees, detect, fontHeight, getBlurredShadowSupport, getDocumentPositionOf, getMinimumFontHeight, hashCode, i, isFunction, isNil, isObject, isString, localize, modules, morphicVersion, newCanvas, noOperation, nop, radians, sizeOf, standardSettings, touchScreenSettings, useBlurredShadows, _KEYCODE_MAP, _MAP, _REVERSE_MAP, _SHIFT_MAP, _SPECIAL_ALIASES, _addEvent, _bindMultiple, _bindSequence, _bindSingle, _callbacks, _characterFromEvent, _directMap, _eventModifiers, _fireCallback, _getMatches, _getReverseMap, _handleCharacter, _handleKey, _ignoreNextKeyup, _isModifier, _modifiersMatch, _pickBestAction, _resetSequenceTimer, _resetSequences, _resetTimer, _sequenceLevels, _sequenceType,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

hashCode = function(stringToBeHashed) {
  var char, hash, i, _i, _ref;
  hash = 0;
  if (stringToBeHashed.length === 0) {
    return hash;
  }
  for (i = _i = 0, _ref = stringToBeHashed.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    char = stringToBeHashed.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return hash;
};

nop = function() {
  return function() {
    return null;
  };
};

noOperation = function() {
  return null;
};

isFunction = function(functionToCheck) {
  return typeof functionToCheck === "function";
};

localize = function(string) {
  return string;
};

isNil = function(thing) {
  return thing === undefined || thing === null;
};

contains = function(list, element) {
  return list.some(function(any) {
    return any === element;
  });
};

detect = function(list, predicate) {
  var element, _i, _len;
  for (_i = 0, _len = list.length; _i < _len; _i++) {
    element = list[_i];
    if (predicate.call(null, element)) {
      return element;
    }
  }
  return null;
};

sizeOf = function(object) {
  var key, size;
  size = 0;
  key = void 0;
  for (key in object) {
    if (object.hasOwnProperty(key)) {
      size += 1;
    }
  }
  return size;
};

isString = function(target) {
  return typeof target === "string" || target instanceof String;
};

isObject = function(target) {
  return (target != null) && (typeof target === "object" || target instanceof Object);
};

radians = function(degrees) {
  return degrees * Math.PI / 180;
};

degrees = function(radians) {
  return radians * 180 / Math.PI;
};

fontHeight = function(height) {
  var minHeight;
  minHeight = Math.max(height, WorldMorph.MorphicPreferences.minimumFontHeight);
  return minHeight * 1.2;
};

newCanvas = function(extentPoint) {
  var canvas, ext;
  ext = extentPoint || {
    x: 0
  };
  ({
    y: 0
  });
  canvas = document.createElement("canvas");
  canvas.width = ext.x;
  canvas.height = ext.y;
  return canvas;
};

getMinimumFontHeight = function() {
  var canvas, ctx, data, maxX, size, str, x, y, _i, _j;
  str = "I";
  size = 50;
  canvas = document.createElement("canvas");
  canvas.width = size;
  canvas.height = size;
  ctx = canvas.getContext("2d");
  ctx.font = "1px serif";
  maxX = ctx.measureText(str).width;
  ctx.fillStyle = "black";
  ctx.textBaseline = "bottom";
  ctx.fillText(str, 0, size);
  for (y = _i = 0; 0 <= size ? _i < size : _i > size; y = 0 <= size ? ++_i : --_i) {
    for (x = _j = 0; 0 <= maxX ? _j < maxX : _j > maxX; x = 0 <= maxX ? ++_j : --_j) {
      data = ctx.getImageData(x, y, 1, 1);
      if (data.data[3] !== 0) {
        return size - y + 1;
      }
    }
  }
  return 0;
};

getBlurredShadowSupport = function() {
  var ctx, source, target;
  source = document.createElement("canvas");
  source.width = 10;
  source.height = 10;
  ctx = source.getContext("2d");
  ctx.fillStyle = "rgb(255, 0, 0)";
  ctx.beginPath();
  ctx.arc(5, 5, 5, 0, Math.PI * 2, true);
  ctx.closePath();
  ctx.fill();
  target = document.createElement("canvas");
  target.width = 10;
  target.height = 10;
  ctx = target.getContext("2d");
  ctx.shadowBlur = 10;
  ctx.shadowColor = "rgba(0, 0, 255, 1)";
  ctx.drawImage(source, 0, 0);
  if (ctx.getImageData(0, 0, 1, 1).data[3]) {
    return true;
  } else {
    return false;
  }
};

getDocumentPositionOf = function(aDOMelement) {
  var offsetParent, pos;
  if (aDOMelement === null) {
    return {
      x: 0,
      y: 0
    };
  }
  pos = {
    x: aDOMelement.offsetLeft,
    y: aDOMelement.offsetTop
  };
  offsetParent = aDOMelement.offsetParent;
  while (offsetParent !== null) {
    pos.x += offsetParent.offsetLeft;
    pos.y += offsetParent.offsetTop;
    if (offsetParent !== document.body && offsetParent !== document.documentElement) {
      pos.x -= offsetParent.scrollLeft;
      pos.y -= offsetParent.scrollTop;
    }
    offsetParent = offsetParent.offsetParent;
  }
  return pos;
};

clone = function(target) {
  var Clone;
  if (typeof target === "object") {
    Clone = function() {};
    Clone.prototype = target;
    return new Clone();
  }
  return target;
};

copy = function(target) {
  var c, property, value;
  if (typeof target !== "object") {
    return target;
  }
  value = target.valueOf();
  if (target !== value) {
    return new target.constructor(value);
  }
  if (target instanceof target.constructor && target.constructor !== Object) {
    c = clone(target.constructor.prototype);
    for (property in target) {
      if (target.hasOwnProperty(property)) {
        c[property] = target[property];
      }
    }
  } else {
    c = {};
    for (property in target) {
      if (!c[property]) {
        c[property] = target[property];
      }
    }
  }
  return c;
};

getMinimumFontHeight = function() {
  var canvas, ctx, data, maxX, size, str, x, y, _i, _j;
  str = "I";
  size = 50;
  canvas = document.createElement("canvas");
  canvas.width = size;
  canvas.height = size;
  ctx = canvas.getContext("2d");
  ctx.font = "1px serif";
  maxX = ctx.measureText(str).width;
  ctx.fillStyle = "black";
  ctx.textBaseline = "bottom";
  ctx.fillText(str, 0, size);
  for (y = _i = 0; 0 <= size ? _i < size : _i > size; y = 0 <= size ? ++_i : --_i) {
    for (x = _j = 0; 0 <= maxX ? _j < maxX : _j > maxX; x = 0 <= maxX ? ++_j : --_j) {
      data = ctx.getImageData(x, y, 1, 1);
      if (data.data[3] !== 0) {
        return size - y + 1;
      }
    }
  }
  return 0;
};

getBlurredShadowSupport = function() {
  var ctx, source, target;
  source = document.createElement("canvas");
  source.width = 10;
  source.height = 10;
  ctx = source.getContext("2d");
  ctx.fillStyle = "rgb(255, 0, 0)";
  ctx.beginPath();
  ctx.arc(5, 5, 5, 0, Math.PI * 2, true);
  ctx.closePath();
  ctx.fill();
  target = document.createElement("canvas");
  target.width = 10;
  target.height = 10;
  ctx = target.getContext("2d");
  ctx.shadowBlur = 10;
  ctx.shadowColor = "rgba(0, 0, 255, 1)";
  ctx.drawImage(source, 0, 0);
  if (ctx.getImageData(0, 0, 1, 1).data[3]) {
    return true;
  } else {
    return false;
  }
};

getDocumentPositionOf = function(aDOMelement) {
  var offsetParent, pos;
  if (aDOMelement === null) {
    return {
      x: 0,
      y: 0
    };
  }
  pos = {
    x: aDOMelement.offsetLeft,
    y: aDOMelement.offsetTop
  };
  offsetParent = aDOMelement.offsetParent;
  while (offsetParent !== null) {
    pos.x += offsetParent.offsetLeft;
    pos.y += offsetParent.offsetTop;
    if (offsetParent !== document.body && offsetParent !== document.documentElement) {
      pos.x -= offsetParent.scrollLeft;
      pos.y -= offsetParent.scrollTop;
    }
    offsetParent = offsetParent.offsetParent;
  }
  return pos;
};

clone = function(target) {
  var Clone;
  if (typeof target === "object") {
    Clone = function() {};
    Clone.prototype = target;
    return new Clone();
  }
  return target;
};

copy = function(target) {
  var c, property, value;
  if (typeof target !== "object") {
    return target;
  }
  value = target.valueOf();
  if (target !== value) {
    return new target.constructor(value);
  }
  if (target instanceof target.constructor && target.constructor !== Object) {
    c = clone(target.constructor.prototype);
    for (property in target) {
      if (target.hasOwnProperty(property)) {
        c[property] = target[property];
      }
    }
  } else {
    c = {};
    for (property in target) {
      if (!c[property]) {
        c[property] = target[property];
      }
    }
  }
  return c;
};

MorphicNode = (function() {

  MorphicNode.prototype.parent = null;

  MorphicNode.prototype.children = null;

  function MorphicNode(parent, children) {
    this.parent = parent != null ? parent : null;
    this.children = children != null ? children : [];
  }

  MorphicNode.prototype.toString = function() {
    return "a MorphicNode" + "[" + this.children.length.toString() + "]";
  };

  MorphicNode.prototype.addChild = function(aMorphicNode) {
    this.children.push(aMorphicNode);
    return aMorphicNode.parent = this;
  };

  MorphicNode.prototype.addChildFirst = function(aMorphicNode) {
    this.children.splice(0, null, aMorphicNode);
    return aMorphicNode.parent = this;
  };

  MorphicNode.prototype.removeChild = function(aMorphicNode) {
    var idx;
    idx = this.children.indexOf(aMorphicNode);
    if (idx !== -1) {
      return this.children.splice(idx, 1);
    }
  };

  MorphicNode.prototype.root = function() {
    if (this.parent != null) {
      return this.parent.root();
    }
    return this;
  };

  MorphicNode.prototype.depth = function() {
    if (!this.parent) {
      return 0;
    }
    return this.parent.depth() + 1;
  };

  MorphicNode.prototype.allChildren = function() {
    var result;
    result = [this];
    this.children.forEach(function(child) {
      return result = result.concat(child.allChildren());
    });
    return result;
  };

  MorphicNode.prototype.forAllChildren = function(aFunction) {
    if (this.children.length) {
      this.children.forEach(function(child) {
        return child.forAllChildren(aFunction);
      });
    }
    return aFunction.call(null, this);
  };

  MorphicNode.prototype.allLeafs = function() {
    var result;
    result = [];
    this.allChildren().forEach(function(element) {
      if (!element.children.length) {
        return result.push(element);
      }
    });
    return result;
  };

  MorphicNode.prototype.allParents = function() {
    var result;
    result = [this];
    if (this.parent != null) {
      result = result.concat(this.parent.allParents());
    }
    return result;
  };

  MorphicNode.prototype.siblings = function() {
    var _this = this;
    if (!this.parent) {
      return [];
    }
    return this.parent.children.filter(function(child) {
      return child !== _this;
    });
  };

  MorphicNode.prototype.parentThatIsA = function(constructor) {
    if (this instanceof constructor) {
      return this;
    }
    if (!this.parent) {
      return null;
    }
    return this.parent.parentThatIsA(constructor);
  };

  MorphicNode.prototype.parentThatIsAnyOf = function(constructors) {
    var _this = this;
    constructors.forEach(function(each) {
      if (_this.constructor === each) {
        return _this;
      }
    });
    if (!this.parent) {
      return null;
    }
    return this.parent.parentThatIsAnyOf(constructors);
  };

  return MorphicNode;

})();

Morph = (function(_super) {

  __extends(Morph, _super);

  Morph.prototype.propertyUpTheChain = [1, 2, 3];

  Morph.prototype.morphMethod = function() {
    return 3.14;
  };

  Morph.morphStaticMethod = function() {
    return 3.14;
  };

  Morph.prototype.isMorph = true;

  Morph.prototype.bounds = null;

  Morph.prototype.color = null;

  Morph.prototype.texture = null;

  Morph.prototype.cachedTexture = null;

  Morph.prototype.lastTime = null;

  Morph.prototype.alpha = 1;

  Morph.prototype.isVisible = true;

  Morph.prototype.isDraggable = false;

  Morph.prototype.isTemplate = false;

  Morph.prototype.acceptsDrops = false;

  Morph.prototype.noticesTransparentClick = false;

  Morph.prototype.fps = 0;

  Morph.prototype.customContextMenu = null;

  Morph.prototype.trackChanges = true;

  Morph.prototype.shadowBlur = 4;

  Morph.prototype.image = null;

  Morph.prototype.onNextStep = null;

  function Morph() {
    Morph.__super__.constructor.call(this);
    this.bounds = new Rectangle(0, 0, 50, 40);
    this.color = new Color(80, 80, 80);
    this.updateRendering();
    this.lastTime = Date.now();
  }

  Morph.prototype.toString = function() {
    return "a " + (this.constructor.name || this.constructor.toString().split(" ")[1].split("(")[0]) + " " + this.children.length.toString() + " " + this.bounds;
  };

  Morph.prototype.destroy = function() {
    if (this.parent !== null) {
      this.fullChanged();
      return this.parent.removeChild(this);
    }
  };

  Morph.prototype.destroyAll = function() {
    var childrenCopy,
      _this = this;
    childrenCopy = this.children.filter(function(x) {
      return true;
    });
    return childrenCopy.forEach(function(child) {
      return child.destroy();
    });
  };

  Morph.prototype.runChildrensStepFunction = function() {
    var elapsed, nxt, timeRemainingToWaitedFrame;
    if (!this.step) {
      return null;
    }
    elapsed = WorldMorph.currentTime - this.lastTime;
    if (this.fps > 0) {
      timeRemainingToWaitedFrame = (1000 / this.fps) - elapsed;
    } else {
      timeRemainingToWaitedFrame = 0;
    }
    if (timeRemainingToWaitedFrame < 1) {
      this.lastTime = WorldMorph.currentTime;
      if (this.onNextStep) {
        nxt = this.onNextStep;
        this.onNextStep = null;
        nxt.call(this);
      }
      this.step();
      return this.children.forEach(function(child) {
        return child.runChildrensStepFunction();
      });
    }
  };

  Morph.prototype.nextSteps = function(arrayOfFunctions) {
    var lst, nxt,
      _this = this;
    lst = arrayOfFunctions || [];
    nxt = lst.shift();
    if (nxt) {
      return this.onNextStep = function() {
        nxt.call(_this);
        return _this.nextSteps(lst);
      };
    }
  };

  Morph.prototype.step = noOperation;

  Morph.prototype.left = function() {
    return this.bounds.left();
  };

  Morph.prototype.right = function() {
    return this.bounds.right();
  };

  Morph.prototype.top = function() {
    return this.bounds.top();
  };

  Morph.prototype.bottom = function() {
    return this.bounds.bottom();
  };

  Morph.prototype.center = function() {
    return this.bounds.center();
  };

  Morph.prototype.bottomCenter = function() {
    return this.bounds.bottomCenter();
  };

  Morph.prototype.bottomLeft = function() {
    return this.bounds.bottomLeft();
  };

  Morph.prototype.bottomRight = function() {
    return this.bounds.bottomRight();
  };

  Morph.prototype.boundingBox = function() {
    return this.bounds;
  };

  Morph.prototype.corners = function() {
    return this.bounds.corners();
  };

  Morph.prototype.leftCenter = function() {
    return this.bounds.leftCenter();
  };

  Morph.prototype.rightCenter = function() {
    return this.bounds.rightCenter();
  };

  Morph.prototype.topCenter = function() {
    return this.bounds.topCenter();
  };

  Morph.prototype.topLeft = function() {
    return this.bounds.topLeft();
  };

  Morph.prototype.topRight = function() {
    return this.bounds.topRight();
  };

  Morph.prototype.position = function() {
    return this.bounds.origin;
  };

  Morph.prototype.extent = function() {
    return this.bounds.extent();
  };

  Morph.prototype.width = function() {
    return this.bounds.width();
  };

  Morph.prototype.height = function() {
    return this.bounds.height();
  };

  Morph.prototype.boundsIncludingChildren = function() {
    var result;
    result = this.bounds;
    this.children.forEach(function(child) {
      if (child.isVisible) {
        return result = result.merge(child.boundsIncludingChildren());
      }
    });
    return result;
  };

  Morph.prototype.boundsIncludingChildrenNoShadow = function() {
    var result;
    result = this.bounds;
    this.children.forEach(function(child) {
      if ((!(child instanceof ShadowMorph)) && child.isVisible) {
        return result = result.merge(child.boundsIncludingChildren());
      }
    });
    return result;
  };

  Morph.prototype.visibleBounds = function() {
    var frames, visible;
    visible = this.bounds;
    frames = this.allParents().filter(function(p) {
      return p instanceof FrameMorph;
    });
    frames.forEach(function(f) {
      return visible = visible.intersect(f.bounds);
    });
    return visible;
  };

  Morph.prototype.moveBy = function(delta) {
    this.changed();
    this.bounds = this.bounds.translateBy(delta);
    this.children.forEach(function(child) {
      return child.moveBy(delta);
    });
    return this.changed();
  };

  Morph.prototype.silentMoveBy = function(delta) {
    this.bounds = this.bounds.translateBy(delta);
    return this.children.forEach(function(child) {
      return child.silentMoveBy(delta);
    });
  };

  Morph.prototype.setPosition = function(aPoint) {
    var delta;
    delta = aPoint.subtract(this.topLeft());
    if ((delta.x !== 0) || (delta.y !== 0)) {
      return this.moveBy(delta);
    }
  };

  Morph.prototype.silentSetPosition = function(aPoint) {
    var delta;
    delta = aPoint.subtract(this.topLeft());
    if ((delta.x !== 0) || (delta.y !== 0)) {
      return this.silentMoveBy(delta);
    }
  };

  Morph.prototype.setLeft = function(x) {
    return this.setPosition(new Point(x, this.top()));
  };

  Morph.prototype.setRight = function(x) {
    return this.setPosition(new Point(x - this.width(), this.top()));
  };

  Morph.prototype.setTop = function(y) {
    return this.setPosition(new Point(this.left(), y));
  };

  Morph.prototype.setBottom = function(y) {
    return this.setPosition(new Point(this.left(), y - this.height()));
  };

  Morph.prototype.setCenter = function(aPoint) {
    return this.setPosition(aPoint.subtract(this.extent().floorDivideBy(2)));
  };

  Morph.prototype.setFullCenter = function(aPoint) {
    return this.setPosition(aPoint.subtract(this.boundsIncludingChildren().extent().floorDivideBy(2)));
  };

  Morph.prototype.keepWithin = function(aMorph) {
    var bottomOff, leftOff, rightOff, topOff;
    leftOff = this.boundsIncludingChildren().left() - aMorph.left();
    if (leftOff < 0) {
      this.moveBy(new Point(-leftOff, 0));
    }
    rightOff = this.boundsIncludingChildren().right() - aMorph.right();
    if (rightOff > 0) {
      this.moveBy(new Point(-rightOff, 0));
    }
    topOff = this.boundsIncludingChildren().top() - aMorph.top();
    if (topOff < 0) {
      this.moveBy(new Point(0, -topOff));
    }
    bottomOff = this.boundsIncludingChildren().bottom() - aMorph.bottom();
    if (bottomOff > 0) {
      return this.moveBy(new Point(0, -bottomOff));
    }
  };

  Morph.prototype.setExtent = function(aPoint) {
    if (!aPoint.eq(this.extent())) {
      this.changed();
      this.silentSetExtent(aPoint);
      this.changed();
      return this.updateRendering();
    }
  };

  Morph.prototype.silentSetExtent = function(aPoint) {
    var ext, newHeight, newWidth;
    ext = aPoint.round();
    newWidth = Math.max(ext.x, 0);
    newHeight = Math.max(ext.y, 0);
    return this.bounds.corner = new Point(this.bounds.origin.x + newWidth, this.bounds.origin.y + newHeight);
  };

  Morph.prototype.setWidth = function(width) {
    return this.setExtent(new Point(width || 0, this.height()));
  };

  Morph.prototype.silentSetWidth = function(width) {
    var w;
    w = Math.max(Math.round(width || 0), 0);
    return this.bounds.corner = new Point(this.bounds.origin.x + w, this.bounds.corner.y);
  };

  Morph.prototype.setHeight = function(height) {
    return this.setExtent(new Point(this.width(), height || 0));
  };

  Morph.prototype.silentSetHeight = function(height) {
    var h;
    h = Math.max(Math.round(height || 0), 0);
    return this.bounds.corner = new Point(this.bounds.corner.x, this.bounds.origin.y + h);
  };

  Morph.prototype.setColor = function(aColor) {
    if (aColor) {
      if (!this.color.eq(aColor)) {
        this.color = aColor;
        this.changed();
        return this.updateRendering();
      }
    }
  };

  Morph.prototype.updateRendering = function() {
    var context;
    this.image = newCanvas(this.extent());
    context = this.image.getContext("2d");
    context.fillStyle = this.color.toString();
    context.fillRect(0, 0, this.width(), this.height());
    if (this.cachedTexture) {
      return this.drawCachedTexture();
    } else {
      if (this.texture) {
        return this.drawTexture(this.texture);
      }
    }
  };

  Morph.prototype.drawTexture = function(url) {
    var _this = this;
    this.cachedTexture = new Image();
    this.cachedTexture.onload = function() {
      return _this.drawCachedTexture();
    };
    return this.cachedTexture.src = this.texture = url;
  };

  Morph.prototype.drawCachedTexture = function() {
    var bg, cols, context, lines, x, y, _i, _j;
    bg = this.cachedTexture;
    cols = Math.floor(this.image.width / bg.width);
    lines = Math.floor(this.image.height / bg.height);
    context = this.image.getContext("2d");
    for (y = _i = 0; 0 <= lines ? _i <= lines : _i >= lines; y = 0 <= lines ? ++_i : --_i) {
      for (x = _j = 0; 0 <= cols ? _j <= cols : _j >= cols; x = 0 <= cols ? ++_j : --_j) {
        context.drawImage(bg, Math.round(x * bg.width), Math.round(y * bg.height));
      }
    }
    return this.changed();
  };

  Morph.prototype.blit = function(aCanvas, clippingRectangle) {
    var al, area, at, context, delta, h, randomB, randomG, randomR, sl, src, st, w;
    if (clippingRectangle == null) {
      clippingRectangle = this.bounds;
    }
    if (!this.isVisible) {
      return null;
    }
    area = clippingRectangle.intersect(this.bounds).round();
    if (area.isNotEmpty()) {
      delta = this.position().neg();
      src = area.copy().translateBy(delta).round();
      context = aCanvas.getContext("2d");
      context.globalAlpha = this.alpha;
      sl = src.left();
      st = src.top();
      al = area.left();
      at = area.top();
      w = Math.min(src.width(), this.image.width - sl);
      h = Math.min(src.height(), this.image.height - st);
      if (w < 1 || h < 1) {
        return null;
      }
      context.drawImage(this.image, Math.round(sl), Math.round(st), Math.round(w), Math.round(h), Math.round(al), Math.round(at), Math.round(w), Math.round(h));
      if (WorldMorph.showRedraws) {
        randomR = Math.round(Math.random() * 255);
        randomG = Math.round(Math.random() * 255);
        randomB = Math.round(Math.random() * 255);
        context.globalAlpha = 0.5;
        context.fillStyle = "rgb(" + randomR + "," + randomG + "," + randomB + ")";
        return context.fillRect(Math.round(al), Math.round(at), Math.round(w), Math.round(h));
      }
    }
  };

  Morph.prototype.recursivelyBlit = function(aCanvas, clippingRectangle) {
    if (clippingRectangle == null) {
      clippingRectangle = this.boundsIncludingChildren();
    }
    if (!this.isVisible) {
      return null;
    }
    this.blit(aCanvas, clippingRectangle);
    return this.children.forEach(function(child) {
      return child.recursivelyBlit(aCanvas, clippingRectangle);
    });
  };

  Morph.prototype.hide = function() {
    this.isVisible = false;
    this.changed();
    return this.children.forEach(function(child) {
      return child.hide();
    });
  };

  Morph.prototype.show = function() {
    this.isVisible = true;
    this.changed();
    return this.children.forEach(function(child) {
      return child.show();
    });
  };

  Morph.prototype.toggleVisibility = function() {
    this.isVisible = !this.isVisible;
    this.changed();
    return this.children.forEach(function(child) {
      return child.toggleVisibility();
    });
  };

  Morph.prototype.fullImageClassic = function() {
    var fb, img;
    fb = this.boundsIncludingChildren();
    img = newCanvas(fb.extent());
    this.recursivelyBlit(img, fb);
    img.globalAlpha = this.alpha;
    return img;
  };

  Morph.prototype.fullImage = function() {
    var boundsIncludingChildren, ctx, img;
    boundsIncludingChildren = this.boundsIncludingChildren();
    img = newCanvas(boundsIncludingChildren.extent());
    ctx = img.getContext("2d");
    ctx.translate(-this.bounds.origin.x, -this.bounds.origin.y);
    this.recursivelyBlit(img, boundsIncludingChildren);
    return img;
  };

  Morph.prototype.fullImageData = function() {
    return this.fullImage().toDataURL();
  };

  Morph.prototype.fullImageHashCode = function() {
    return hashCode(this.fullImageData());
  };

  Morph.prototype.shadowImage = function(off_, color) {
    var clr, ctx, fb, img, offset, outline, sha;
    offset = off_ || new Point(7, 7);
    clr = color || new Color(0, 0, 0);
    fb = this.boundsIncludingChildren().extent();
    img = this.fullImage();
    outline = newCanvas(fb);
    ctx = outline.getContext("2d");
    ctx.drawImage(img, 0, 0);
    ctx.globalCompositeOperation = "destination-out";
    ctx.drawImage(img, Math.round(-offset.x), Math.round(-offset.y));
    sha = newCanvas(fb);
    ctx = sha.getContext("2d");
    ctx.drawImage(outline, 0, 0);
    ctx.globalCompositeOperation = "source-atop";
    ctx.fillStyle = clr.toString();
    ctx.fillRect(0, 0, fb.x, fb.y);
    return sha;
  };

  Morph.prototype.shadowImageBlurred = function(off_, color) {
    var blur, clr, ctx, fb, img, offset, sha;
    offset = off_ || new Point(7, 7);
    blur = this.shadowBlur;
    clr = color || new Color(0, 0, 0);
    fb = this.boundsIncludingChildren().extent().add(blur * 2);
    img = this.fullImage();
    sha = newCanvas(fb);
    ctx = sha.getContext("2d");
    ctx.shadowOffsetX = offset.x;
    ctx.shadowOffsetY = offset.y;
    ctx.shadowBlur = blur;
    ctx.shadowColor = clr.toString();
    ctx.drawImage(img, Math.round(blur - offset.x), Math.round(blur - offset.y));
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.shadowBlur = 0;
    ctx.globalCompositeOperation = "destination-out";
    ctx.drawImage(img, Math.round(blur - offset.x), Math.round(blur - offset.y));
    return sha;
  };

  Morph.prototype.shadow = function(off_, a, color) {
    var alpha, fb, offset, shadow;
    shadow = new ShadowMorph();
    offset = off_ || new Point(7, 7);
    alpha = a || (a === 0 ? 0 : 0.2);
    fb = this.boundsIncludingChildren();
    shadow.setExtent(fb.extent().add(this.shadowBlur * 2));
    if (useBlurredShadows) {
      shadow.image = this.shadowImageBlurred(offset, color);
      shadow.alpha = alpha;
      shadow.setPosition(fb.origin.add(offset).subtract(this.shadowBlur));
    } else {
      shadow.image = this.shadowImage(offset, color);
      shadow.alpha = alpha;
      shadow.setPosition(fb.origin.add(offset));
    }
    return shadow;
  };

  Morph.prototype.addShadow = function(off_, a, color) {
    var alpha, offset, shadow;
    offset = off_ || new Point(7, 7);
    alpha = a || (a === 0 ? 0 : 0.2);
    shadow = this.shadow(offset, alpha, color);
    this.addBack(shadow);
    this.fullChanged();
    return shadow;
  };

  Morph.prototype.getShadow = function() {
    var shadows;
    shadows = this.children.slice(0).reverse().filter(function(child) {
      return child instanceof ShadowMorph;
    });
    if (shadows.length) {
      return shadows[0];
    }
    return null;
  };

  Morph.prototype.removeShadow = function() {
    var shadow;
    shadow = this.getShadow();
    if (shadow !== null) {
      this.fullChanged();
      return this.removeChild(shadow);
    }
  };

  Morph.prototype.penTrails = function() {
    return this.image;
  };

  Morph.prototype.changed = function() {
    var w;
    if (this.trackChanges) {
      w = this.root();
      if (w instanceof WorldMorph) {
        w.broken.push(this.visibleBounds().spread());
      }
    }
    if (this.parent) {
      return this.parent.childChanged(this);
    }
  };

  Morph.prototype.fullChanged = function() {
    var w;
    if (this.trackChanges) {
      w = this.root();
      if (w instanceof WorldMorph) {
        return w.broken.push(this.boundsIncludingChildren().spread());
      }
    }
  };

  Morph.prototype.childChanged = function() {
    if (this.parent) {
      return this.parent.childChanged(this);
    }
  };

  Morph.prototype.world = function() {
    var root;
    root = this.root();
    if (root instanceof WorldMorph) {
      return root;
    }
    if (root instanceof HandMorph) {
      return root.world;
    }
    return null;
  };

  Morph.prototype.add = function(aMorph) {
    var owner;
    owner = aMorph.parent;
    if (owner != null) {
      owner.removeChild(aMorph);
    }
    return this.addChild(aMorph);
  };

  Morph.prototype.addBack = function(aMorph) {
    var owner;
    owner = aMorph.parent;
    if (owner != null) {
      owner.removeChild(aMorph);
    }
    return this.addChildFirst(aMorph);
  };

  Morph.prototype.topMorphSuchThat = function(predicate) {
    var next;
    if (predicate.call(null, this)) {
      next = detect(this.children.slice(0).reverse(), predicate);
      if (next) {
        return next.topMorphSuchThat(predicate);
      }
      return this;
    }
    return null;
  };

  Morph.prototype.morphAt = function(aPoint) {
    var morphs, result;
    morphs = this.allChildren().slice(0).reverse();
    result = null;
    morphs.forEach(function(m) {
      if (m.boundsIncludingChildren().containsPoint(aPoint) && (result === null)) {
        return result = m;
      }
    });
    return result;
  };

  Morph.prototype.overlappedMorphs = function() {
    var allChildren, allParents, fb, morphs, world,
      _this = this;
    world = this.world();
    fb = this.boundsIncludingChildren();
    allParents = this.allParents();
    allChildren = this.allChildren();
    morphs = world.allChildren();
    return morphs.filter(function(m) {
      return m.isVisible && m !== _this && m !== world && !contains(allParents, m) && !contains(allChildren, m) && m.boundsIncludingChildren().intersects(fb);
    });
  };

  Morph.prototype.getPixelColor = function(aPoint) {
    var context, data, point;
    point = aPoint.subtract(this.bounds.origin);
    context = this.image.getContext("2d");
    data = context.getImageData(point.x, point.y, 1, 1);
    return new Color(data.data[0], data.data[1], data.data[2], data.data[3]);
  };

  Morph.prototype.isTransparentAt = function(aPoint) {
    var context, data, point;
    if (this.bounds.containsPoint(aPoint)) {
      if (this.texture) {
        return false;
      }
      point = aPoint.subtract(this.bounds.origin);
      context = this.image.getContext("2d");
      data = context.getImageData(Math.floor(point.x), Math.floor(point.y), 1, 1);
      return data.data[3] === 0;
    }
    return false;
  };

  Morph.prototype.copy = function() {
    var c;
    c = copy(this);
    c.parent = null;
    c.children = [];
    c.bounds = this.bounds.copy();
    return c;
  };

  Morph.prototype.fullCopy = function() {
    var c, dict;
    dict = {};
    c = this.copyRecordingReferences(dict);
    c.forAllChildren(function(m) {
      return m.updateReferences(dict);
    });
    return c;
  };

  Morph.prototype.copyRecordingReferences = function(dict) {
    var c;
    c = this.copy();
    dict[this] = c;
    this.children.forEach(function(m) {
      return c.add(m.copyRecordingReferences(dict));
    });
    return c;
  };

  Morph.prototype.updateReferences = function(dict) {
    var property, _results;
    _results = [];
    for (property in this) {
      if (property.isMorph && dict[property]) {
        _results.push(this[property] = dict[property]);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Morph.prototype.rootForGrab = function() {
    if (this instanceof ShadowMorph) {
      return this.parent.rootForGrab();
    }
    if (this.parent instanceof ScrollFrameMorph) {
      return this.parent;
    }
    if (this.parent === null || this.parent instanceof WorldMorph || this.parent instanceof FrameMorph || this.isDraggable === true) {
      return this;
    }
    return this.parent.rootForGrab();
  };

  Morph.prototype.wantsDropOf = function(aMorph) {
    if ((aMorph instanceof HandleMorph) || (aMorph instanceof MenuMorph) || (aMorph instanceof InspectorMorph)) {
      return false;
    }
    return this.acceptsDrops;
  };

  Morph.prototype.pickUp = function(wrrld) {
    var world;
    world = wrrld || this.world();
    this.setPosition(world.hand.position().subtract(this.extent().floorDivideBy(2)));
    return world.hand.grab(this);
  };

  Morph.prototype.isPickedUp = function() {
    return this.parentThatIsA(HandMorph) !== null;
  };

  Morph.prototype.situation = function() {
    if (this.parent) {
      return {
        origin: this.parent,
        position: this.position().subtract(this.parent.position())
      };
    }
    return null;
  };

  Morph.prototype.slideBackTo = function(situation, inSteps) {
    var oldFps, oldStep, pos, stepCount, steps, xStep, yStep,
      _this = this;
    steps = inSteps || 5;
    pos = situation.origin.position().add(situation.position);
    xStep = -(this.left() - pos.x) / steps;
    yStep = -(this.top() - pos.y) / steps;
    stepCount = 0;
    oldStep = this.step;
    oldFps = this.fps;
    this.fps = 0;
    return this.step = function() {
      _this.fullChanged();
      _this.silentMoveBy(new Point(xStep, yStep));
      _this.fullChanged();
      stepCount += 1;
      if (stepCount === steps) {
        situation.origin.add(_this);
        if (situation.origin.reactToDropOf) {
          situation.origin.reactToDropOf(_this);
        }
        _this.step = oldStep;
        return _this.fps = oldFps;
      }
    };
  };

  Morph.prototype.resize = function() {
    return this.world().activeHandle = new HandleMorph(this);
  };

  Morph.prototype.move = function() {
    return this.world().activeHandle = new HandleMorph(this, null, null, null, null, "move");
  };

  Morph.prototype.hint = function(msg) {
    var m, text;
    text = msg;
    if (msg) {
      if (msg.toString) {
        text = msg.toString();
      }
    } else {
      text = "NULL";
    }
    m = new MenuMorph(this, text);
    m.isDraggable = true;
    return m.popUpCenteredAtHand(this.world());
  };

  Morph.prototype.inform = function(msg) {
    var m, text;
    text = msg;
    if (msg) {
      if (msg.toString) {
        text = msg.toString();
      }
    } else {
      text = "NULL";
    }
    m = new MenuMorph(this, text);
    m.addItem("Ok");
    m.isDraggable = true;
    return m.popUpCenteredAtHand(this.world());
  };

  Morph.prototype.prompt = function(msg, callback, environment, defaultContents, width, floorNum, ceilingNum, isRounded) {
    var entryField, isNumeric, menu, slider;
    if (ceilingNum) {
      isNumeric = true;
    }
    menu = new MenuMorph(callback || null, msg || "", environment || null);
    entryField = new StringFieldMorph(defaultContents || "", width || 100, WorldMorph.MorphicPreferences.prompterFontSize, WorldMorph.MorphicPreferences.prompterFontName, false, false, isNumeric);
    menu.items.push(entryField);
    if (ceilingNum || WorldMorph.MorphicPreferences.useSliderForInput) {
      slider = new SliderMorph(floorNum || 0, ceilingNum, parseFloat(defaultContents), Math.floor((ceilingNum - floorNum) / 4), "horizontal");
      slider.alpha = 1;
      slider.color = new Color(225, 225, 225);
      slider.button.color = menu.borderColor;
      slider.button.highlightColor = slider.button.color.copy();
      slider.button.highlightColor.b += 100;
      slider.button.pressColor = slider.button.color.copy();
      slider.button.pressColor.b += 150;
      slider.setHeight(WorldMorph.MorphicPreferences.prompterSliderSize);
      if (isRounded) {
        slider.action = function(num) {
          entryField.changed();
          entryField.text.text = Math.round(num).toString();
          entryField.text.updateRendering();
          entryField.text.changed();
          return entryField.text.edit();
        };
      } else {
        slider.action = function(num) {
          entryField.changed();
          entryField.text.text = num.toString();
          entryField.text.updateRendering();
          return entryField.text.changed();
        };
      }
      menu.items.push(slider);
    }
    menu.addLine(2);
    menu.addItem("Ok", function() {
      return entryField.string();
    });
    menu.addItem("Cancel", function() {
      return null;
    });
    menu.isDraggable = true;
    menu.popUpAtHand(this.world());
    return entryField.text.edit();
  };

  Morph.prototype.pickColor = function(msg, callback, environment, defaultContents) {
    var colorPicker, menu;
    menu = new MenuMorph(callback || null, msg || "", environment || null);
    colorPicker = new ColorPickerMorph(defaultContents);
    menu.items.push(colorPicker);
    menu.addLine(2);
    menu.addItem("Ok", function() {
      return colorPicker.getChoice();
    });
    menu.addItem("Cancel", function() {
      return null;
    });
    menu.isDraggable = true;
    return menu.popUpAtHand(this.world());
  };

  Morph.prototype.inspect = function(anotherObject) {
    var inspectee, inspector, world;
    world = (this.world instanceof Function ? this.world() : this.root() || this.world);
    inspectee = this;
    if (anotherObject) {
      inspectee = anotherObject;
    }
    inspector = new InspectorMorph(inspectee);
    inspector.setPosition(world.hand.position());
    inspector.keepWithin(world);
    world.add(inspector);
    return inspector.changed();
  };

  Morph.prototype.contextMenu = function() {
    var world;
    if (this.customContextMenu) {
      return this.customContextMenu;
    }
    world = (this.world instanceof Function ? this.world() : this.root() || this.world);
    if (world && world.isDevMode) {
      if (this.parent === world) {
        return this.developersMenu();
      }
      return this.hierarchyMenu();
    }
    return this.userMenu() || (this.parent && this.parent.userMenu());
  };

  Morph.prototype.hierarchyMenu = function() {
    var menu, parents, world;
    parents = this.allParents();
    world = (this.world instanceof Function ? this.world() : this.root() || this.world);
    menu = new MenuMorph(this, null);
    parents.forEach(function(each) {
      if (each.developersMenu && (each !== world)) {
        return menu.addItem(each.toString().slice(0, 50), function() {
          return each.developersMenu().popUpAtHand(world);
        });
      }
    });
    return menu;
  };

  Morph.prototype.developersMenu = function() {
    var menu, userMenu, world;
    world = (this.world instanceof Function ? this.world() : this.root() || this.world);
    userMenu = this.userMenu() || (this.parent && this.parent.userMenu());
    menu = new MenuMorph(this, this.constructor.name || this.constructor.toString().split(" ")[1].split("(")[0]);
    if (userMenu) {
      menu.addItem("user features...", function() {
        return userMenu.popUpAtHand(world);
      });
      menu.addLine();
    }
    menu.addItem("color...", (function() {
      return this.pickColor(menu.title + "\ncolor:", this.setColor, this, this.color);
    }), "choose another color \nfor this morph");
    menu.addItem("transparency...", (function() {
      return this.prompt(menu.title + "\nalpha\nvalue:", this.setAlphaScaled, this, (this.alpha * 100).toString(), null, 1, 100, true);
    }), "set this morph's\nalpha value");
    menu.addItem("resize...", "resize", "show a handle\nwhich can be dragged\nto change this morph's" + " extent");
    menu.addLine();
    menu.addItem("duplicate", (function() {
      return this.fullCopy().pickUp(this.world());
    }), "make a copy\nand pick it up");
    menu.addItem("pick up", "pickUp", "disattach and put \ninto the hand");
    menu.addItem("attach...", "attach", "stick this morph\nto another one");
    menu.addItem("move...", "move", "show a handle\nwhich can be dragged\nto move this morph");
    menu.addItem("inspect...", "inspect", "open a window\non all properties");
    menu.addItem("pic...", (function() {
      return window.open(this.fullImageData());
    }), "open a new window\nwith a picture of this morph");
    menu.addLine();
    if (this.isDraggable) {
      menu.addItem("lock", "toggleIsDraggable", "make this morph\nunmovable");
    } else {
      menu.addItem("unlock", "toggleIsDraggable", "make this morph\nmovable");
    }
    menu.addItem("hide", "hide");
    menu.addItem("delete", "destroy");
    if (!(this instanceof WorldMorph)) {
      menu.addLine();
      menu.addItem("World...", (function() {
        return world.contextMenu().popUpAtHand(world);
      }), "show the\nWorld's menu");
    }
    return menu;
  };

  Morph.prototype.userMenu = function() {
    return null;
  };

  Morph.prototype.calculateAlphaScaled = function(alpha) {
    var newAlpha, unscaled;
    if (typeof alpha === "number") {
      unscaled = alpha / 100;
      return Math.min(Math.max(unscaled, 0.1), 1);
    } else {
      newAlpha = parseFloat(alpha);
      if (!isNaN(newAlpha)) {
        unscaled = newAlpha / 100;
        return Math.min(Math.max(unscaled, 0.1), 1);
      }
    }
  };

  Morph.prototype.setAlphaScaled = function(alpha) {
    this.alpha = this.calculateAlphaScaled(alpha);
    return this.changed();
  };

  Morph.prototype.attach = function() {
    var choices, menu,
      _this = this;
    choices = this.overlappedMorphs();
    menu = new MenuMorph(this, "choose new parent:");
    choices.forEach(function(each) {
      return menu.addItem(each.toString().slice(0, 50), function() {
        each.add(_this);
        return _this.isDraggable = false;
      });
    });
    if (choices.length) {
      return menu.popUpAtHand(this.world());
    }
  };

  Morph.prototype.toggleIsDraggable = function() {
    return this.isDraggable = !this.isDraggable;
  };

  Morph.prototype.colorSetters = function() {
    return ["color"];
  };

  Morph.prototype.numericalSetters = function() {
    return ["setLeft", "setTop", "setWidth", "setHeight", "setAlphaScaled"];
  };

  Morph.prototype.allEntryFields = function() {
    return this.allChildren().filter(function(each) {
      return each.isEditable && (each instanceof StringMorph || each instanceof TextMorph);
    });
  };

  Morph.prototype.nextEntryField = function(current) {
    var fields, idx;
    fields = this.allEntryFields();
    idx = fields.indexOf(current);
    if (idx !== -1) {
      if (fields.length > (idx + 1)) {
        return fields[idx + 1];
      }
    }
    return fields[0];
  };

  Morph.prototype.previousEntryField = function(current) {
    var fields, idx;
    fields = this.allEntryFields();
    idx = fields.indexOf(current);
    if (idx !== -1) {
      if (idx > 0) {
        return fields[idx - 1];
      }
      return fields[fields.length - 1];
    }
    return fields[0];
  };

  Morph.prototype.tab = function(editField) {
    if (this.nextTab) {
      return this.nextTab(editField);
    } else {
      if (this.parent) {
        return this.parent.tab(editField);
      }
    }
  };

  Morph.prototype.backTab = function(editField) {
    if (this.previousTab) {
      return this.previousTab(editField);
    } else {
      if (this.parent) {
        return this.parent.backTab(editField);
      }
    }
  };

  Morph.prototype.escalateEvent = function(functionName, arg) {
    var handler;
    handler = this.parent;
    while (!handler[functionName] && (handler.parent != null)) {
      handler = handler.parent;
    }
    if (handler[functionName]) {
      return handler[functionName](arg);
    }
  };

  Morph.prototype.evaluateString = function(code) {
    var result;
    try {
      result = eval(code);
      this.updateRendering();
      this.changed();
    } catch (err) {
      this.inform(err);
    }
    return result;
  };

  Morph.prototype.isTouching = function(otherMorph) {
    var data, oImg;
    oImg = this.overlappingImage(otherMorph);
    data = oImg.getContext("2d").getImageData(1, 1, oImg.width, oImg.height).data;
    return detect(data, function(each) {
      return each !== 0;
    }) !== null;
  };

  Morph.prototype.overlappingImage = function(otherMorph) {
    var ctx, fb, oImg, oRect, otherFb;
    fb = this.boundsIncludingChildren();
    otherFb = otherMorph.boundsIncludingChildren();
    oRect = fb.intersect(otherFb);
    oImg = newCanvas(oRect.extent());
    ctx = oImg.getContext("2d");
    if (oRect.width() < 1 || oRect.height() < 1) {
      return newCanvas(new Point(1, 1));
    }
    ctx.drawImage(this.fullImage(), Math.round(oRect.origin.x - fb.origin.x), Math.round(oRect.origin.y - fb.origin.y));
    ctx.globalCompositeOperation = "source-in";
    ctx.drawImage(otherMorph.fullImage(), Math.round(otherFb.origin.x - oRect.origin.x), Math.round(otherFb.origin.y - oRect.origin.y));
    return oImg;
  };

  return Morph;

})(MorphicNode);

BouncerMorph = (function(_super) {

  __extends(BouncerMorph, _super);

  BouncerMorph.prototype.isStopped = false;

  BouncerMorph.prototype.type = null;

  BouncerMorph.prototype.direction = null;

  BouncerMorph.prototype.speed = null;

  function BouncerMorph(type, speed) {
    this.type = type != null ? type : "vertical";
    this.speed = speed != null ? speed : 1;
    BouncerMorph.__super__.constructor.call(this);
    this.fps = 50;
    if (this.type === "vertical") {
      this.direction = "down";
    } else {
      this.direction = "right";
    }
  }

  BouncerMorph.prototype.moveUp = function() {
    return this.moveBy(new Point(0, -this.speed));
  };

  BouncerMorph.prototype.moveDown = function() {
    return this.moveBy(new Point(0, this.speed));
  };

  BouncerMorph.prototype.moveRight = function() {
    return this.moveBy(new Point(this.speed, 0));
  };

  BouncerMorph.prototype.moveLeft = function() {
    return this.moveBy(new Point(-this.speed, 0));
  };

  BouncerMorph.prototype.step = function() {
    if (!this.isStopped) {
      if (this.type === "vertical") {
        if (this.direction === "down") {
          this.moveDown();
        } else {
          this.moveUp();
        }
        if (this.boundsIncludingChildren().top() < this.parent.top() && this.direction === "up") {
          this.direction = "down";
        }
        if (this.boundsIncludingChildren().bottom() > this.parent.bottom() && this.direction === "down") {
          return this.direction = "up";
        }
      } else if (this.type === "horizontal") {
        if (this.direction === "right") {
          this.moveRight();
        } else {
          this.moveLeft();
        }
        if (this.boundsIncludingChildren().left() < this.parent.left() && this.direction === "left") {
          this.direction = "right";
        }
        if (this.boundsIncludingChildren().right() > this.parent.right() && this.direction === "right") {
          return this.direction = "left";
        }
      }
    }
  };

  return BouncerMorph;

})(Morph);

ColorPickerMorph = (function(_super) {

  __extends(ColorPickerMorph, _super);

  ColorPickerMorph.prototype.choice = null;

  function ColorPickerMorph(defaultColor) {
    this.choice = defaultColor || new Color(255, 255, 255);
    ColorPickerMorph.__super__.constructor.call(this);
    this.color = new Color(255, 255, 255);
    this.silentSetExtent(new Point(80, 80));
    this.updateRendering();
  }

  ColorPickerMorph.prototype.updateRendering = function() {
    ColorPickerMorph.__super__.updateRendering.call(this);
    return this.buildSubmorphs();
  };

  ColorPickerMorph.prototype.buildSubmorphs = function() {
    var cpal, gpal, x, y;
    this.children.forEach(function(child) {
      return child.destroy();
    });
    this.children = [];
    this.feedback = new Morph();
    this.feedback.color = this.choice;
    this.feedback.setExtent(new Point(20, 20));
    cpal = new ColorPaletteMorph(this.feedback, new Point(this.width(), 50));
    gpal = new GrayPaletteMorph(this.feedback, new Point(this.width(), 5));
    cpal.setPosition(this.bounds.origin);
    this.add(cpal);
    gpal.setPosition(cpal.bottomLeft());
    this.add(gpal);
    x = gpal.left() + Math.floor((gpal.width() - this.feedback.width()) / 2);
    y = gpal.bottom() + Math.floor((this.bottom() - gpal.bottom() - this.feedback.height()) / 2);
    this.feedback.setPosition(new Point(x, y));
    return this.add(this.feedback);
  };

  ColorPickerMorph.prototype.getChoice = function() {
    return this.feedback.color;
  };

  ColorPickerMorph.prototype.rootForGrab = function() {
    return this;
  };

  return ColorPickerMorph;

})(Morph);

CircleBoxMorph = (function(_super) {

  __extends(CircleBoxMorph, _super);

  CircleBoxMorph.prototype.orientation = null;

  CircleBoxMorph.prototype.autoOrient = true;

  function CircleBoxMorph(orientation) {
    this.orientation = orientation != null ? orientation : "vertical";
    CircleBoxMorph.__super__.constructor.call(this);
    this.setExtent(new Point(20, 100));
  }

  CircleBoxMorph.prototype.autoOrientation = function() {
    if (this.height() > this.width()) {
      return this.orientation = "vertical";
    } else {
      return this.orientation = "horizontal";
    }
  };

  CircleBoxMorph.prototype.updateRendering = function() {
    var center1, center2, context, ext, points, radius, rect, x, y,
      _this = this;
    if (this.autoOrient) {
      this.autoOrientation();
    }
    this.image = newCanvas(this.extent());
    context = this.image.getContext("2d");
    if (this.orientation === "vertical") {
      radius = this.width() / 2;
      x = this.center().x;
      center1 = new Point(x, this.top() + radius);
      center2 = new Point(x, this.bottom() - radius);
      rect = this.bounds.origin.add(new Point(0, radius)).corner(this.bounds.corner.subtract(new Point(0, radius)));
    } else {
      radius = this.height() / 2;
      y = this.center().y;
      center1 = new Point(this.left() + radius, y);
      center2 = new Point(this.right() - radius, y);
      rect = this.bounds.origin.add(new Point(radius, 0)).corner(this.bounds.corner.subtract(new Point(radius, 0)));
    }
    points = [center1.subtract(this.bounds.origin), center2.subtract(this.bounds.origin)];
    points.forEach(function(center) {
      context.fillStyle = _this.color.toString();
      context.beginPath();
      context.arc(center.x, center.y, radius, 0, 2 * Math.PI, false);
      context.closePath();
      return context.fill();
    });
    rect = rect.translateBy(this.bounds.origin.neg());
    ext = rect.extent();
    if (ext.x > 0 && ext.y > 0) {
      return context.fillRect(rect.origin.x, rect.origin.y, rect.width(), rect.height());
    }
  };

  CircleBoxMorph.prototype.developersMenu = function() {
    var menu;
    menu = CircleBoxMorph.__super__.developersMenu.call(this);
    menu.addLine();
    if (this.orientation === "vertical") {
      menu.addItem("horizontal...", "toggleOrientation", "toggle the\norientation");
    } else {
      menu.addItem("vertical...", "toggleOrientation", "toggle the\norientation");
    }
    return menu;
  };

  CircleBoxMorph.prototype.toggleOrientation = function() {
    var center;
    center = this.center();
    this.changed();
    if (this.orientation === "vertical") {
      this.orientation = "horizontal";
    } else {
      this.orientation = "vertical";
    }
    this.silentSetExtent(new Point(this.height(), this.width()));
    this.setCenter(center);
    this.updateRendering();
    return this.changed();
  };

  return CircleBoxMorph;

})(Morph);

morphicVersion = "2012-October-22";

SystemTestsRecorderAndPlayer = (function() {

  SystemTestsRecorderAndPlayer.prototype.eventQueue = [];

  SystemTestsRecorderAndPlayer.prototype.recordingASystemTest = false;

  SystemTestsRecorderAndPlayer.prototype.replayingASystemTest = false;

  SystemTestsRecorderAndPlayer.prototype.lastRecordedEventTime = null;

  SystemTestsRecorderAndPlayer.prototype.handMorph = null;

  SystemTestsRecorderAndPlayer.prototype.systemInfo = null;

  function SystemTestsRecorderAndPlayer(worldMorph, handMorph) {
    this.worldMorph = worldMorph;
    this.handMorph = handMorph;
  }

  SystemTestsRecorderAndPlayer.prototype.initialiseSystemInfo = function() {
    this.systemInfo = {};
    this.systemInfo.zombieKernelTestHarnessVersionMajor = 0;
    this.systemInfo.zombieKernelTestHarnessVersionMinor = 1;
    this.systemInfo.zombieKernelTestHarnessVersionRelease = 0;
    this.systemInfo.userAgent = navigator.userAgent;
    this.systemInfo.screenWidth = window.screen.width;
    this.systemInfo.screenHeight = window.screen.height;
    this.systemInfo.screenColorDepth = window.screen.colorDepth;
    if (window.devicePixelRatio != null) {
      this.systemInfo.screenPixelRatio = window.devicePixelRatio;
    } else {
      this.systemInfo.screenPixelRatio = window.devicePixelRatio;
    }
    this.systemInfo.appCodeName = navigator.appCodeName;
    this.systemInfo.appName = navigator.appName;
    this.systemInfo.appVersion = navigator.appVersion;
    this.systemInfo.cookieEnabled = navigator.cookieEnabled;
    this.systemInfo.platform = navigator.platform;
    return this.systemInfo.systemLanguage = navigator.systemLanguage;
  };

  SystemTestsRecorderAndPlayer.prototype.startRecording = function() {
    var systemTestEvent;
    this.worldMorph.destroyAll();
    this.eventQueue = [];
    this.lastRecordedEventTime = new Date().getTime();
    this.recordingASystemTest = true;
    this.replayingASystemTest = false;
    this.initialiseSystemInfo();
    systemTestEvent = {};
    systemTestEvent.type = "systemInfo";
    systemTestEvent.time = 0;
    systemTestEvent.systemInfo = this.systemInfo;
    return this.eventQueue.push(systemTestEvent);
  };

  SystemTestsRecorderAndPlayer.prototype.stopRecording = function() {
    return this.recordingASystemTest = false;
  };

  SystemTestsRecorderAndPlayer.prototype.startPlaying = function() {
    this.recordingASystemTest = false;
    this.replayingASystemTest = true;
    return this.replayEvents();
  };

  SystemTestsRecorderAndPlayer.prototype.stopPlaying = function() {
    return this.replayingASystemTest = false;
  };

  SystemTestsRecorderAndPlayer.prototype.addMouseMoveEvent = function(pageX, pageY) {
    var currentTime, systemTestEvent;
    if (!this.recordingASystemTest) {
      return;
    }
    currentTime = new Date().getTime();
    systemTestEvent = {};
    systemTestEvent.type = "mouseMove";
    systemTestEvent.mouseX = pageX;
    systemTestEvent.mouseY = pageY;
    systemTestEvent.time = currentTime - this.lastRecordedEventTime;
    this.eventQueue.push(systemTestEvent);
    return this.lastRecordedEventTime = currentTime;
  };

  SystemTestsRecorderAndPlayer.prototype.addMouseDownEvent = function(button, ctrlKey) {
    var currentTime, systemTestEvent;
    if (!this.recordingASystemTest) {
      return;
    }
    currentTime = new Date().getTime();
    systemTestEvent = {};
    systemTestEvent.type = "mouseDown";
    systemTestEvent.time = currentTime - this.lastRecordedEventTime;
    systemTestEvent.button = button;
    systemTestEvent.ctrlKey = ctrlKey;
    this.eventQueue.push(systemTestEvent);
    return this.lastRecordedEventTime = currentTime;
  };

  SystemTestsRecorderAndPlayer.prototype.addMouseUpEvent = function() {
    var currentTime, systemTestEvent;
    if (!this.recordingASystemTest) {
      return;
    }
    currentTime = new Date().getTime();
    systemTestEvent = {};
    systemTestEvent.type = "mouseUp";
    systemTestEvent.time = currentTime - this.lastRecordedEventTime;
    this.eventQueue.push(systemTestEvent);
    return this.lastRecordedEventTime = currentTime;
  };

  SystemTestsRecorderAndPlayer.prototype.takeScreenshot = function() {
    var currentTime, systemTestEvent;
    console.log("taking screenshot");
    if (this.systemInfo === null) {
      this.initialiseSystemInfo();
    }
    currentTime = new Date().getTime();
    systemTestEvent = {};
    systemTestEvent.type = "takeScreenshot";
    systemTestEvent.time = currentTime - this.lastRecordedEventTime;
    systemTestEvent.screenShotImageData = [];
    systemTestEvent.screenShotImageData.push([this.systemInfo, this.worldMorph.fullImageData()]);
    this.eventQueue.push(systemTestEvent);
    this.lastRecordedEventTime = currentTime;
    if (!this.recordingASystemTest) {
      return systemTestEvent;
    }
  };

  SystemTestsRecorderAndPlayer.prototype.compareScreenshots = function(expected) {
    var a, i, _i, _len;
    i = 0;
    console.log("expected length " + expected.length);
    for (_i = 0, _len = expected.length; _i < _len; _i++) {
      a = expected[_i];
      console.log("trying to match screenshot: " + i);
      i++;
      if (a[1] === this.worldMorph.fullImageData()) {
        console.log("PASS - screenshot (" + i + ") matched");
        return;
      }
    }
    return console.log("FAIL - no screenshots like this one");
  };

  SystemTestsRecorderAndPlayer.prototype.replayEvents = function() {
    var lastPlayedEventTime, queuedEvent, _i, _len, _ref, _results;
    lastPlayedEventTime = 0;
    console.log("events: " + this.eventQueue);
    _ref = this.eventQueue;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      queuedEvent = _ref[_i];
      lastPlayedEventTime += queuedEvent.time;
      _results.push(this.scheduleEvent(queuedEvent, lastPlayedEventTime));
    }
    return _results;
  };

  SystemTestsRecorderAndPlayer.prototype.scheduleEvent = function(queuedEvent, lastPlayedEventTime) {
    var callback,
      _this = this;
    if (queuedEvent.type === 'mouseMove') {
      callback = function() {
        return _this.handMorph.processMouseMove(queuedEvent.mouseX, queuedEvent.mouseY);
      };
    } else if (queuedEvent.type === 'mouseDown') {
      callback = function() {
        return _this.handMorph.processMouseDown(queuedEvent.button, queuedEvent.ctrlKey);
      };
    } else if (queuedEvent.type === 'mouseUp') {
      callback = function() {
        return _this.handMorph.processMouseUp();
      };
    } else if (queuedEvent.type === 'takeScreenshot') {
      callback = function() {
        return _this.compareScreenshots(queuedEvent.screenShotImageData);
      };
    } else {
      return;
    }
    return setTimeout(callback, lastPlayedEventTime);
  };

  return SystemTestsRecorderAndPlayer;

})();

BoxMorph = (function(_super) {

  __extends(BoxMorph, _super);

  BoxMorph.prototype.edge = null;

  BoxMorph.prototype.border = null;

  BoxMorph.prototype.borderColor = null;

  function BoxMorph(edge, border, borderColor) {
    this.edge = edge != null ? edge : 4;
    this.border = border || (border === 0 ? 0 : 2);
    this.borderColor = borderColor || new Color();
    BoxMorph.__super__.constructor.call(this);
  }

  BoxMorph.prototype.updateRendering = function() {
    var context;
    this.image = newCanvas(this.extent());
    context = this.image.getContext("2d");
    if ((this.edge === 0) && (this.border === 0)) {
      BoxMorph.__super__.updateRendering.call(this);
      return null;
    }
    context.fillStyle = this.color.toString();
    context.beginPath();
    this.outlinePath(context, Math.max(this.edge - this.border, 0), this.border);
    context.closePath();
    context.fill();
    if (this.border > 0) {
      context.lineWidth = this.border;
      context.strokeStyle = this.borderColor.toString();
      context.beginPath();
      this.outlinePath(context, this.edge, this.border / 2);
      context.closePath();
      return context.stroke();
    }
  };

  BoxMorph.prototype.outlinePath = function(context, radius, inset) {
    var h, offset, w;
    offset = radius + inset;
    w = this.width();
    h = this.height();
    context.arc(offset, offset, radius, radians(-180), radians(-90), false);
    context.arc(w - offset, offset, radius, radians(-90), radians(-0), false);
    context.arc(w - offset, h - offset, radius, radians(0), radians(90), false);
    return context.arc(offset, h - offset, radius, radians(90), radians(180), false);
  };

  BoxMorph.prototype.developersMenu = function() {
    var menu;
    menu = BoxMorph.__super__.developersMenu.call(this);
    menu.addLine();
    menu.addItem("border width...", (function() {
      return this.prompt(menu.title + "\nborder\nwidth:", this.setBorderWidth, this, this.border.toString(), null, 0, 100, true);
    }), "set the border's\nline size");
    menu.addItem("border color...", (function() {
      return this.pickColor(menu.title + "\nborder color:", this.setBorderColor, this, this.borderColor);
    }), "set the border's\nline color");
    menu.addItem("corner size...", (function() {
      return this.prompt(menu.title + "\ncorner\nsize:", this.setCornerSize, this, this.edge.toString(), null, 0, 100, true);
    }), "set the corner's\nradius");
    return menu;
  };

  BoxMorph.prototype.setBorderWidth = function(size) {
    var newSize;
    if (typeof size === "number") {
      this.border = Math.max(size, 0);
    } else {
      newSize = parseFloat(size);
      if (!isNaN(newSize)) {
        this.border = Math.max(newSize, 0);
      }
    }
    this.updateRendering();
    return this.changed();
  };

  BoxMorph.prototype.setBorderColor = function(color) {
    if (color) {
      this.borderColor = color;
      this.updateRendering();
      return this.changed();
    }
  };

  BoxMorph.prototype.setCornerSize = function(size) {
    var newSize;
    if (typeof size === "number") {
      this.edge = Math.max(size, 0);
    } else {
      newSize = parseFloat(size);
      if (!isNaN(newSize)) {
        this.edge = Math.max(newSize, 0);
      }
    }
    this.updateRendering();
    return this.changed();
  };

  BoxMorph.prototype.colorSetters = function() {
    return ["color", "borderColor"];
  };

  BoxMorph.prototype.numericalSetters = function() {
    var list;
    list = BoxMorph.__super__.numericalSetters.call(this);
    list.push("setBorderWidth", "setCornerSize");
    return list;
  };

  return BoxMorph;

})(Morph);

Color = (function() {

  Color.prototype.a = null;

  Color.prototype.r = null;

  Color.prototype.g = null;

  Color.prototype.b = null;

  function Color(r, g, b, a) {
    this.r = r != null ? r : 0;
    this.g = g != null ? g : 0;
    this.b = b != null ? b : 0;
    this.a = a || (a === 0 ? 0 : 1);
  }

  Color.prototype.toString = function() {
    return "rgba(" + Math.round(this.r) + "," + Math.round(this.g) + "," + Math.round(this.b) + "," + this.a + ")";
  };

  Color.prototype.copy = function() {
    return new Color(this.r, this.g, this.b, this.a);
  };

  Color.prototype.eq = function(aColor) {
    return aColor && this.r === aColor.r && this.g === aColor.g && this.b === aColor.b;
  };

  Color.prototype.hsv = function() {
    var bb, d, gg, h, max, min, rr, s, v;
    rr = this.r / 255;
    gg = this.g / 255;
    bb = this.b / 255;
    max = Math.max(rr, gg, bb);
    min = Math.min(rr, gg, bb);
    h = max;
    s = max;
    v = max;
    d = max - min;
    s = (max === 0 ? 0 : d / max);
    if (max === min) {
      h = 0;
    } else {
      switch (max) {
        case rr:
          h = (gg - bb) / d + (gg < bb ? 6 : 0);
          break;
        case gg:
          h = (bb - rr) / d + 2;
          break;
        case bb:
          h = (rr - gg) / d + 4;
      }
      h /= 6;
    }
    return [h, s, v];
  };

  Color.prototype.set_hsv = function(h, s, v) {
    var f, i, p, q, t;
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
      case 0:
        this.r = v;
        this.g = t;
        this.b = p;
        break;
      case 1:
        this.r = q;
        this.g = v;
        this.b = p;
        break;
      case 2:
        this.r = p;
        this.g = v;
        this.b = t;
        break;
      case 3:
        this.r = p;
        this.g = q;
        this.b = v;
        break;
      case 4:
        this.r = t;
        this.g = p;
        this.b = v;
        break;
      case 5:
        this.r = v;
        this.g = p;
        this.b = q;
    }
    this.r *= 255;
    this.g *= 255;
    return this.b *= 255;
  };

  Color.prototype.mixed = function(proportion, otherColor) {
    var frac1, frac2;
    frac1 = Math.min(Math.max(proportion, 0), 1);
    frac2 = 1 - frac1;
    return new Color(this.r * frac1 + otherColor.r * frac2, this.g * frac1 + otherColor.g * frac2, this.b * frac1 + otherColor.b * frac2);
  };

  Color.prototype.darker = function(percent) {
    var fract;
    fract = 0.8333;
    if (percent) {
      fract = (100 - percent) / 100;
    }
    return this.mixed(fract, new Color(0, 0, 0));
  };

  Color.prototype.lighter = function(percent) {
    var fract;
    fract = 0.8333;
    if (percent) {
      fract = (100 - percent) / 100;
    }
    return this.mixed(fract, new Color(255, 255, 255));
  };

  Color.prototype.dansDarker = function() {
    var hsv, result, vv;
    hsv = this.hsv();
    result = new Color();
    vv = Math.max(hsv[2] - 0.16, 0);
    result.set_hsv(hsv[0], hsv[1], vv);
    return result;
  };

  return Color;

})();

ColorPaletteMorph = (function(_super) {

  __extends(ColorPaletteMorph, _super);

  ColorPaletteMorph.prototype.target = null;

  ColorPaletteMorph.prototype.targetSetter = "color";

  ColorPaletteMorph.prototype.choice = null;

  function ColorPaletteMorph(target, sizePoint) {
    this.target = target != null ? target : null;
    ColorPaletteMorph.__super__.constructor.call(this);
    this.silentSetExtent(sizePoint || new Point(80, 50));
    this.updateRendering();
  }

  ColorPaletteMorph.prototype.updateRendering = function() {
    var context, ext, h, l, x, y, _i, _ref, _results;
    ext = this.extent();
    this.image = newCanvas(this.extent());
    context = this.image.getContext("2d");
    this.choice = new Color();
    _results = [];
    for (x = _i = 0, _ref = ext.x; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
      h = 360 * x / ext.x;
      y = 0;
      _results.push((function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (y = _j = 0, _ref1 = ext.y; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          l = 100 - (y / ext.y * 100);
          context.fillStyle = "hsl(" + h + ",100%," + l + "%)";
          _results1.push(context.fillRect(x, y, 1, 1));
        }
        return _results1;
      })());
    }
    return _results;
  };

  ColorPaletteMorph.prototype.mouseMove = function(pos) {
    this.choice = this.getPixelColor(pos);
    return this.updateTarget();
  };

  ColorPaletteMorph.prototype.mouseDownLeft = function(pos) {
    this.choice = this.getPixelColor(pos);
    return this.updateTarget();
  };

  ColorPaletteMorph.prototype.updateTarget = function() {
    if (this.target instanceof Morph && this.choice !== null) {
      if (this.target[this.targetSetter] instanceof Function) {
        return this.target[this.targetSetter](this.choice);
      } else {
        this.target[this.targetSetter] = this.choice;
        this.target.updateRendering();
        return this.target.changed();
      }
    }
  };

  ColorPaletteMorph.prototype.copyRecordingReferences = function(dict) {
    var c;
    c = ColorPaletteMorph.__super__.copyRecordingReferences.call(this, dict);
    if (c.target && dict[this.target]) {
      c.target = dict[this.target];
    }
    return c;
  };

  ColorPaletteMorph.prototype.developersMenu = function() {
    var menu;
    menu = ColorPaletteMorph.__super__.developersMenu.call(this);
    menu.addLine();
    menu.addItem("set target", "setTarget", "choose another morph\nwhose color property\n will be" + " controlled by this one");
    return menu;
  };

  ColorPaletteMorph.prototype.setTarget = function() {
    var choices, menu,
      _this = this;
    choices = this.overlappedMorphs();
    menu = new MenuMorph(this, "choose target:");
    choices.push(this.world());
    choices.forEach(function(each) {
      return menu.addItem(each.toString().slice(0, 50), function() {
        _this.target = each;
        return _this.setTargetSetter();
      });
    });
    if (choices.length === 1) {
      this.target = choices[0];
      return this.setTargetSetter();
    } else {
      if (choices.length) {
        return menu.popUpAtHand(this.world());
      }
    }
  };

  ColorPaletteMorph.prototype.setTargetSetter = function() {
    var choices, menu,
      _this = this;
    choices = this.target.colorSetters();
    menu = new MenuMorph(this, "choose target property:");
    choices.forEach(function(each) {
      return menu.addItem(each, function() {
        return _this.targetSetter = each;
      });
    });
    if (choices.length === 1) {
      return this.targetSetter = choices[0];
    } else {
      if (choices.length) {
        return menu.popUpAtHand(this.world());
      }
    }
  };

  return ColorPaletteMorph;

})(Morph);

modules = {};

useBlurredShadows = getBlurredShadowSupport();

standardSettings = {
  minimumFontHeight: getMinimumFontHeight(),
  globalFontFamily: "",
  menuFontName: "sans-serif",
  menuFontSize: 12,
  bubbleHelpFontSize: 10,
  prompterFontName: "sans-serif",
  prompterFontSize: 12,
  prompterSliderSize: 10,
  handleSize: 15,
  scrollBarSize: 12,
  mouseScrollAmount: 40,
  useSliderForInput: false,
  useVirtualKeyboard: true,
  rasterizeSVGs: false
};

touchScreenSettings = {
  minimumFontHeight: standardSettings.minimumFontHeight,
  globalFontFamily: "",
  menuFontName: "sans-serif",
  menuFontSize: 24,
  bubbleHelpFontSize: 18,
  prompterFontName: "sans-serif",
  prompterFontSize: 24,
  prompterSliderSize: 20,
  handleSize: 26,
  scrollBarSize: 24,
  mouseScrollAmount: 40,
  useSliderForInput: true,
  useVirtualKeyboard: true,
  rasterizeSVGs: false
};

FrameMorph = (function(_super) {

  __extends(FrameMorph, _super);

  FrameMorph.scrollFrame = null;

  function FrameMorph(scrollFrame) {
    this.scrollFrame = scrollFrame != null ? scrollFrame : null;
    FrameMorph.__super__.constructor.call(this);
    this.color = new Color(255, 250, 245);
    this.acceptsDrops = true;
    if (this.scrollFrame) {
      this.isDraggable = false;
      this.noticesTransparentClick = false;
    }
    this.updateRendering();
  }

  FrameMorph.prototype.setColor = function(aColor) {
    if (this.scrollFrame) {
      this.scrollFrame.color = aColor;
    }
    return FrameMorph.__super__.setColor.call(this, aColor);
  };

  FrameMorph.prototype.setAlphaScaled = function(alpha) {
    if (this.scrollFrame) {
      this.scrollFrame.alpha = this.calculateAlphaScaled(alpha);
    }
    return FrameMorph.__super__.setAlphaScaled.call(this, alpha);
  };

  FrameMorph.prototype.boundsIncludingChildren = function() {
    var shadow;
    shadow = this.getShadow();
    if (shadow !== null) {
      return this.bounds.merge(shadow.bounds);
    }
    return this.bounds;
  };

  FrameMorph.prototype.recursivelyBlit = function(aCanvas, clippingRectangle) {
    var dirtyPartOfFrame,
      _this = this;
    if (clippingRectangle == null) {
      clippingRectangle = this.bounds;
    }
    if (!this.isVisible) {
      return null;
    }
    dirtyPartOfFrame = this.bounds.intersect(clippingRectangle);
    if (dirtyPartOfFrame.isEmpty()) {
      return null;
    }
    this.blit(aCanvas, dirtyPartOfFrame);
    return this.children.forEach(function(child) {
      if (child instanceof ShadowMorph) {
        return child.recursivelyBlit(aCanvas, clippingRectangle);
      } else {
        return child.recursivelyBlit(aCanvas, dirtyPartOfFrame);
      }
    });
  };

  FrameMorph.prototype.moveBy = function(delta) {
    this.changed();
    this.bounds = this.bounds.translateBy(delta);
    this.children.forEach(function(child) {
      return child.silentMoveBy(delta);
    });
    return this.changed();
  };

  FrameMorph.prototype.submorphBounds = function() {
    var result;
    result = null;
    if (this.children.length) {
      result = this.children[0].bounds;
      this.children.forEach(function(child) {
        return result = result.merge(child.boundsIncludingChildren());
      });
    }
    return result;
  };

  FrameMorph.prototype.keepInScrollFrame = function() {
    if (this.scrollFrame === null) {
      return null;
    }
    if (this.left() > this.scrollFrame.left()) {
      this.moveBy(new Point(this.scrollFrame.left() - this.left(), 0));
    }
    if (this.right() < this.scrollFrame.right()) {
      this.moveBy(new Point(this.scrollFrame.right() - this.right(), 0));
    }
    if (this.top() > this.scrollFrame.top()) {
      this.moveBy(new Point(0, this.scrollFrame.top() - this.top()));
    }
    if (this.bottom() < this.scrollFrame.bottom()) {
      return this.moveBy(0, new Point(this.scrollFrame.bottom() - this.bottom(), 0));
    }
  };

  FrameMorph.prototype.adjustBounds = function() {
    var newBounds, subBounds,
      _this = this;
    if (this.scrollFrame === null) {
      return null;
    }
    subBounds = this.submorphBounds();
    if (subBounds && (!this.scrollFrame.isTextLineWrapping)) {
      newBounds = subBounds.expandBy(this.scrollFrame.padding).growBy(this.scrollFrame.growth).merge(this.scrollFrame.bounds);
    } else {
      newBounds = this.scrollFrame.bounds.copy();
    }
    if (!this.bounds.eq(newBounds)) {
      this.bounds = newBounds;
      this.updateRendering();
      this.keepInScrollFrame();
    }
    if (this.scrollFrame.isTextLineWrapping) {
      this.children.forEach(function(morph) {
        if (morph instanceof TextMorph) {
          morph.setWidth(_this.width());
          return _this.setHeight(Math.max(morph.height(), _this.scrollFrame.height()));
        }
      });
    }
    return this.scrollFrame.adjustScrollBars();
  };

  FrameMorph.prototype.reactToDropOf = function() {
    return this.adjustBounds();
  };

  FrameMorph.prototype.reactToGrabOf = function() {
    return this.adjustBounds();
  };

  FrameMorph.prototype.copyRecordingReferences = function(dict) {
    var c;
    c = FrameMorph.__super__.copyRecordingReferences.call(this, dict);
    if (c.frame && dict[this.scrollFrame]) {
      c.frame = dict[this.scrollFrame];
    }
    return c;
  };

  FrameMorph.prototype.developersMenu = function() {
    var menu;
    menu = FrameMorph.__super__.developersMenu.call(this);
    if (this.children.length) {
      menu.addLine();
      menu.addItem("move all inside...", "keepAllSubmorphsWithin", "keep all submorphs\nwithin and visible");
    }
    return menu;
  };

  FrameMorph.prototype.keepAllSubmorphsWithin = function() {
    var _this = this;
    return this.children.forEach(function(m) {
      return m.keepWithin(_this);
    });
  };

  return FrameMorph;

})(Morph);

ScrollFrameMorph = (function(_super) {

  __extends(ScrollFrameMorph, _super);

  ScrollFrameMorph.prototype.autoScrollTrigger = null;

  ScrollFrameMorph.prototype.hasVelocity = true;

  ScrollFrameMorph.prototype.padding = 0;

  ScrollFrameMorph.prototype.growth = 0;

  ScrollFrameMorph.prototype.isTextLineWrapping = false;

  ScrollFrameMorph.prototype.isScrollingByDragging = true;

  ScrollFrameMorph.prototype.scrollBarSize = null;

  ScrollFrameMorph.prototype.contents = null;

  ScrollFrameMorph.prototype.vBar = null;

  ScrollFrameMorph.prototype.hBar = null;

  function ScrollFrameMorph(contents, scrollBarSize, sliderColor) {
    var _this = this;
    this.alpha = 0;
    ScrollFrameMorph.__super__.constructor.call(this);
    this.scrollBarSize = scrollBarSize || WorldMorph.MorphicPreferences.scrollBarSize;
    this.contents = contents || new FrameMorph(this);
    this.add(this.contents);
    this.color = this.contents.color;
    this.alpha = this.contents.alpha;
    this.updateRendering = this.contents.updateRendering;
    this.hBar = new SliderMorph(null, null, null, null, "horizontal", sliderColor);
    this.hBar.setHeight(this.scrollBarSize);
    this.hBar.action = function(num) {
      return _this.contents.setPosition(new Point(_this.left() - num, _this.contents.position().y));
    };
    this.hBar.isDraggable = false;
    this.add(this.hBar);
    this.vBar = new SliderMorph(null, null, null, null, "vertical", sliderColor);
    this.vBar.setWidth(this.scrollBarSize);
    this.vBar.action = function(num) {
      return _this.contents.setPosition(new Point(_this.contents.position().x, _this.top() - num));
    };
    this.vBar.isDraggable = false;
    this.add(this.vBar);
  }

  ScrollFrameMorph.prototype.setColor = function(aColor) {
    this.color = aColor;
    return this.contents.setColor(aColor);
  };

  ScrollFrameMorph.prototype.setAlphaScaled = function(alpha) {
    this.alpha = this.calculateAlphaScaled(alpha);
    return this.contents.setAlphaScaled(alpha);
  };

  ScrollFrameMorph.prototype.adjustScrollBars = function() {
    var hWidth, vHeight;
    hWidth = this.width() - this.scrollBarSize;
    vHeight = this.height() - this.scrollBarSize;
    this.changed();
    if (this.contents.width() > this.width() + WorldMorph.MorphicPreferences.scrollBarSize) {
      this.hBar.show();
      if (this.hBar.width() !== hWidth) {
        this.hBar.setWidth(hWidth);
      }
      this.hBar.setPosition(new Point(this.left(), this.bottom() - this.hBar.height()));
      this.hBar.start = 0;
      this.hBar.stop = this.contents.width() - this.width();
      this.hBar.size = this.width() / this.contents.width() * this.hBar.stop;
      this.hBar.value = this.left() - this.contents.left();
      this.hBar.updateRendering();
    } else {
      this.hBar.hide();
    }
    if (this.contents.height() > this.height() + this.scrollBarSize) {
      this.vBar.show();
      if (this.vBar.height() !== vHeight) {
        this.vBar.setHeight(vHeight);
      }
      this.vBar.setPosition(new Point(this.right() - this.vBar.width(), this.top()));
      this.vBar.start = 0;
      this.vBar.stop = this.contents.height() - this.height();
      this.vBar.size = this.height() / this.contents.height() * this.vBar.stop;
      this.vBar.value = this.top() - this.contents.top();
      return this.vBar.updateRendering();
    } else {
      return this.vBar.hide();
    }
  };

  ScrollFrameMorph.prototype.addContents = function(aMorph) {
    this.contents.add(aMorph);
    return this.contents.adjustBounds();
  };

  ScrollFrameMorph.prototype.setContents = function(aMorph) {
    this.contents.children.forEach(function(m) {
      return m.destroy();
    });
    this.contents.children = [];
    aMorph.setPosition(this.position().add(this.padding + 2));
    return this.addContents(aMorph);
  };

  ScrollFrameMorph.prototype.setExtent = function(aPoint) {
    if (this.isTextLineWrapping) {
      this.contents.setPosition(this.position().copy());
    }
    ScrollFrameMorph.__super__.setExtent.call(this, aPoint);
    return this.contents.adjustBounds();
  };

  ScrollFrameMorph.prototype.scrollX = function(steps) {
    var cl, cw, l, newX, r;
    cl = this.contents.left();
    l = this.left();
    cw = this.contents.width();
    r = this.right();
    newX = cl + steps;
    if (newX > l) {
      newX = l;
    }
    if (newX + cw < r) {
      newX = r - cw;
    }
    if (newX !== cl) {
      return this.contents.setLeft(newX);
    }
  };

  ScrollFrameMorph.prototype.scrollY = function(steps) {
    var b, ch, ct, newY, t;
    ct = this.contents.top();
    t = this.top();
    ch = this.contents.height();
    b = this.bottom();
    newY = ct + steps;
    if (newY > t) {
      newY = t;
    }
    if (newY + ch < b) {
      newY = b - ch;
    }
    if (newY !== ct) {
      return this.contents.setTop(newY);
    }
  };

  ScrollFrameMorph.prototype.mouseDownLeft = function(pos) {
    var deltaX, deltaY, friction, oldPos, world,
      _this = this;
    if (!this.isScrollingByDragging) {
      return null;
    }
    world = this.root();
    oldPos = pos;
    deltaX = 0;
    deltaY = 0;
    friction = 0.8;
    return this.step = function() {
      var newPos;
      if (world.hand.mouseButton && (!world.hand.children.length) && (_this.bounds.containsPoint(world.hand.position()))) {
        newPos = world.hand.bounds.origin;
        deltaX = newPos.x - oldPos.x;
        if (deltaX !== 0) {
          _this.scrollX(deltaX);
        }
        deltaY = newPos.y - oldPos.y;
        if (deltaY !== 0) {
          _this.scrollY(deltaY);
        }
        oldPos = newPos;
      } else {
        if (!_this.hasVelocity) {
          _this.step = noOperation;
        } else {
          if ((Math.abs(deltaX) < 0.5) && (Math.abs(deltaY) < 0.5)) {
            _this.step = noOperation;
          } else {
            deltaX = deltaX * friction;
            _this.scrollX(Math.round(deltaX));
            deltaY = deltaY * friction;
            _this.scrollY(Math.round(deltaY));
          }
        }
      }
      return _this.adjustScrollBars();
    };
  };

  ScrollFrameMorph.prototype.startAutoScrolling = function() {
    var hand, inset, world,
      _this = this;
    inset = WorldMorph.MorphicPreferences.scrollBarSize * 3;
    world = this.world();
    if (!world) {
      return null;
    }
    hand = world.hand;
    if (!this.autoScrollTrigger) {
      this.autoScrollTrigger = Date.now();
    }
    return this.step = function() {
      var inner, pos;
      pos = hand.bounds.origin;
      inner = _this.bounds.insetBy(inset);
      if ((_this.bounds.containsPoint(pos)) && (!(inner.containsPoint(pos))) && hand.children.length) {
        return _this.autoScroll(pos);
      } else {
        _this.step = noOperation;
        return _this.autoScrollTrigger = null;
      }
    };
  };

  ScrollFrameMorph.prototype.autoScroll = function(pos) {
    var area, inset;
    if (Date.now() - this.autoScrollTrigger < 500) {
      return null;
    }
    inset = WorldMorph.MorphicPreferences.scrollBarSize * 3;
    area = this.topLeft().extent(new Point(this.width(), inset));
    if (area.containsPoint(pos)) {
      this.scrollY(inset - (pos.y - this.top()));
    }
    area = this.topLeft().extent(new Point(inset, this.height()));
    if (area.containsPoint(pos)) {
      this.scrollX(inset - (pos.x - this.left()));
    }
    area = (new Point(this.right() - inset, this.top())).extent(new Point(inset, this.height()));
    if (area.containsPoint(pos)) {
      this.scrollX(-(inset - (this.right() - pos.x)));
    }
    area = (new Point(this.left(), this.bottom() - inset)).extent(new Point(this.width(), inset));
    if (area.containsPoint(pos)) {
      this.scrollY(-(inset - (this.bottom() - pos.y)));
    }
    return this.adjustScrollBars();
  };

  ScrollFrameMorph.prototype.scrollCaretIntoView = function(morph) {
    var fb, ft, offset, txt;
    txt = morph.target;
    offset = txt.position().subtract(this.contents.position());
    ft = this.top() + this.padding;
    fb = this.bottom() - this.padding;
    this.contents.setExtent(txt.extent().add(offset).add(this.padding));
    if (morph.top() < ft) {
      this.contents.setTop(this.contents.top() + ft - morph.top());
      morph.setTop(ft);
    } else if (morph.bottom() > fb) {
      this.contents.setBottom(this.contents.bottom() + fb - morph.bottom());
      morph.setBottom(fb);
    }
    return this.adjustScrollBars();
  };

  ScrollFrameMorph.prototype.mouseScroll = function(y, x) {
    if (y) {
      this.scrollY(y * WorldMorph.MorphicPreferences.mouseScrollAmount);
    }
    if (x) {
      this.scrollX(x * WorldMorph.MorphicPreferences.mouseScrollAmount);
    }
    return this.adjustScrollBars();
  };

  ScrollFrameMorph.prototype.copyRecordingReferences = function(dict) {
    var c;
    c = ScrollFrameMorph.__super__.copyRecordingReferences.call(this, dict);
    if (c.contents && dict[this.contents]) {
      c.contents = dict[this.contents];
    }
    if (c.hBar && dict[this.hBar]) {
      c.hBar = dict[this.hBar];
      c.hBar.action = function(num) {
        return c.contents.setPosition(new Point(c.left() - num, c.contents.position().y));
      };
    }
    if (c.vBar && dict[this.vBar]) {
      c.vBar = dict[this.vBar];
      c.vBar.action = function(num) {
        return c.contents.setPosition(new Point(c.contents.position().x, c.top() - num));
      };
    }
    return c;
  };

  ScrollFrameMorph.prototype.developersMenu = function() {
    var menu;
    menu = ScrollFrameMorph.__super__.developersMenu.call(this);
    if (this.isTextLineWrapping) {
      menu.addItem("auto line wrap off...", "toggleTextLineWrapping", "turn automatic\nline wrapping\noff");
    } else {
      menu.addItem("auto line wrap on...", "toggleTextLineWrapping", "enable automatic\nline wrapping");
    }
    return menu;
  };

  ScrollFrameMorph.prototype.toggleTextLineWrapping = function() {
    return this.isTextLineWrapping = !this.isTextLineWrapping;
  };

  return ScrollFrameMorph;

})(FrameMorph);

SpeechBubbleMorph = (function(_super) {

  __extends(SpeechBubbleMorph, _super);

  SpeechBubbleMorph.prototype.isPointingRight = true;

  SpeechBubbleMorph.prototype.contents = null;

  SpeechBubbleMorph.prototype.padding = null;

  SpeechBubbleMorph.prototype.isThought = null;

  SpeechBubbleMorph.prototype.isClickable = false;

  function SpeechBubbleMorph(contents, color, edge, border, borderColor, padding, isThought) {
    this.contents = contents != null ? contents : "";
    this.padding = padding != null ? padding : 0;
    this.isThought = isThought != null ? isThought : false;
    SpeechBubbleMorph.__super__.constructor.call(this, edge || 6, border || (border === 0 ? 0 : 1), borderColor || new Color(140, 140, 140));
    this.color = color || new Color(230, 230, 230);
    this.updateRendering();
  }

  SpeechBubbleMorph.prototype.popUp = function(world, pos, isClickable) {
    this.updateRendering();
    this.setPosition(pos.subtract(new Point(0, this.height())));
    this.addShadow(new Point(2, 2), 80);
    this.keepWithin(world);
    world.add(this);
    this.changed();
    world.hand.destroyTemporaries();
    world.hand.temporaries.push(this);
    if (isClickable) {
      return this.mouseEnter = function() {
        return this.destroy();
      };
    } else {
      return this.isClickable = false;
    }
  };

  SpeechBubbleMorph.prototype.updateRendering = function() {
    if (this.contentsMorph) {
      this.contentsMorph.destroy();
    }
    if (this.contents instanceof Morph) {
      this.contentsMorph = this.contents;
    } else if (isString(this.contents)) {
      this.contentsMorph = new TextMorph(this.contents, WorldMorph.MorphicPreferences.bubbleHelpFontSize, null, false, true, "center");
    } else if (this.contents instanceof HTMLCanvasElement) {
      this.contentsMorph = new Morph();
      this.contentsMorph.silentSetWidth(this.contents.width);
      this.contentsMorph.silentSetHeight(this.contents.height);
      this.contentsMorph.image = this.contents;
    } else {
      this.contentsMorph = new TextMorph(this.contents.toString(), WorldMorph.MorphicPreferences.bubbleHelpFontSize, null, false, true, "center");
    }
    this.add(this.contentsMorph);
    this.silentSetWidth(this.contentsMorph.width() + (this.padding ? this.padding * 2 : this.edge * 2));
    this.silentSetHeight(this.contentsMorph.height() + this.edge + this.border * 2 + this.padding * 2 + 2);
    SpeechBubbleMorph.__super__.updateRendering.call(this);
    return this.contentsMorph.setPosition(this.position().add(new Point(this.padding || this.edge, this.border + this.padding + 1)));
  };

  SpeechBubbleMorph.prototype.outlinePath = function(context, radius, inset) {
    var circle, h, offset, rad, w;
    circle = function(x, y, r) {
      context.moveTo(x + r, y);
      return context.arc(x, y, r, radians(0), radians(360));
    };
    offset = radius + inset;
    w = this.width();
    h = this.height();
    context.arc(offset, offset, radius, radians(-180), radians(-90), false);
    context.arc(w - offset, offset, radius, radians(-90), radians(-0), false);
    context.arc(w - offset, h - offset - radius, radius, radians(0), radians(90), false);
    if (!this.isThought) {
      if (this.isPointingRight) {
        context.lineTo(offset + radius, h - offset);
        context.lineTo(radius / 2 + inset, h - inset);
      } else {
        context.lineTo(w - (radius / 2 + inset), h - inset);
        context.lineTo(w - (offset + radius), h - offset);
      }
    }
    context.arc(offset, h - offset - radius, radius, radians(90), radians(180), false);
    if (this.isThought) {
      context.lineTo(inset, offset);
      if (this.isPointingRight) {
        rad = radius / 4;
        circle(rad + inset, h - rad - inset, rad);
        rad = radius / 3.2;
        circle(rad * 2 + inset, h - rad - inset * 2, rad);
        rad = radius / 2.8;
        return circle(rad * 3 + inset * 2, h - rad - inset * 4, rad);
      } else {
        rad = radius / 4;
        circle(w - (rad + inset), h - rad - inset, rad);
        rad = radius / 3.2;
        circle(w - (rad * 2 + inset), h - rad - inset * 2, rad);
        rad = radius / 2.8;
        return circle(w - (rad * 3 + inset * 2), h - rad - inset * 4, rad);
      }
    }
  };

  SpeechBubbleMorph.prototype.shadowImage = function(off_, color) {
    var clr, ctx, fb, img, offset, outline, sha;
    fb = void 0;
    img = void 0;
    outline = void 0;
    sha = void 0;
    ctx = void 0;
    offset = off_ || new Point(7, 7);
    clr = color || new Color(0, 0, 0);
    fb = this.extent();
    img = this.image;
    outline = newCanvas(fb);
    ctx = outline.getContext("2d");
    ctx.drawImage(img, 0, 0);
    ctx.globalCompositeOperation = "destination-out";
    ctx.drawImage(img, -offset.x, -offset.y);
    sha = newCanvas(fb);
    ctx = sha.getContext("2d");
    ctx.drawImage(outline, 0, 0);
    ctx.globalCompositeOperation = "source-atop";
    ctx.fillStyle = clr.toString();
    ctx.fillRect(0, 0, fb.x, fb.y);
    return sha;
  };

  SpeechBubbleMorph.prototype.shadowImageBlurred = function(off_, color) {
    var blur, clr, ctx, fb, img, offset, sha;
    fb = void 0;
    img = void 0;
    sha = void 0;
    ctx = void 0;
    offset = off_ || new Point(7, 7);
    blur = this.shadowBlur;
    clr = color || new Color(0, 0, 0);
    fb = this.extent().add(blur * 2);
    img = this.image;
    sha = newCanvas(fb);
    ctx = sha.getContext("2d");
    ctx.shadowOffsetX = offset.x;
    ctx.shadowOffsetY = offset.y;
    ctx.shadowBlur = blur;
    ctx.shadowColor = clr.toString();
    ctx.drawImage(img, blur - offset.x, blur - offset.y);
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.shadowBlur = 0;
    ctx.globalCompositeOperation = "destination-out";
    ctx.drawImage(img, blur - offset.x, blur - offset.y);
    return sha;
  };

  SpeechBubbleMorph.prototype.fixLayout = function() {
    this.removeShadow();
    this.updateRendering();
    return this.addShadow(new Point(2, 2), 80);
  };

  return SpeechBubbleMorph;

})(BoxMorph);

SliderButtonMorph = (function(_super) {

  __extends(SliderButtonMorph, _super);

  SliderButtonMorph.prototype.highlightColor = new Color(90, 90, 140);

  SliderButtonMorph.prototype.pressColor = new Color(80, 80, 160);

  SliderButtonMorph.prototype.is3D = true;

  SliderButtonMorph.prototype.hasMiddleDip = true;

  function SliderButtonMorph(orientation) {
    this.color = new Color(80, 80, 80);
    SliderButtonMorph.__super__.constructor.call(this, orientation);
  }

  SliderButtonMorph.prototype.autoOrientation = function() {
    return noOperation;
  };

  SliderButtonMorph.prototype.updateRendering = function() {
    var colorBak;
    colorBak = this.color.copy();
    SliderButtonMorph.__super__.updateRendering.call(this);
    if (this.is3D) {
      this.drawEdges();
    }
    this.normalImage = this.image;
    this.color = this.highlightColor.copy();
    SliderButtonMorph.__super__.updateRendering.call(this);
    if (this.is3D) {
      this.drawEdges();
    }
    this.highlightImage = this.image;
    this.color = this.pressColor.copy();
    SliderButtonMorph.__super__.updateRendering.call(this);
    if (this.is3D) {
      this.drawEdges();
    }
    this.pressImage = this.image;
    this.color = colorBak;
    return this.image = this.normalImage;
  };

  SliderButtonMorph.prototype.drawEdges = function() {
    var context, gradient, h, radius, w;
    context = this.image.getContext("2d");
    w = this.width();
    h = this.height();
    context.lineJoin = "round";
    context.lineCap = "round";
    if (this.orientation === "vertical") {
      context.lineWidth = w / 3;
      gradient = context.createLinearGradient(0, 0, context.lineWidth, 0);
      gradient.addColorStop(0, "white");
      gradient.addColorStop(1, this.color.toString());
      context.strokeStyle = gradient;
      context.beginPath();
      context.moveTo(context.lineWidth * 0.5, w / 2);
      context.lineTo(context.lineWidth * 0.5, h - w / 2);
      context.stroke();
      gradient = context.createLinearGradient(w - context.lineWidth, 0, w, 0);
      gradient.addColorStop(0, this.color.toString());
      gradient.addColorStop(1, "black");
      context.strokeStyle = gradient;
      context.beginPath();
      context.moveTo(w - context.lineWidth * 0.5, w / 2);
      context.lineTo(w - context.lineWidth * 0.5, h - w / 2);
      context.stroke();
      if (this.hasMiddleDip) {
        gradient = context.createLinearGradient(context.lineWidth, 0, w - context.lineWidth, 0);
        radius = w / 4;
        gradient.addColorStop(0, "black");
        gradient.addColorStop(0.35, this.color.toString());
        gradient.addColorStop(0.65, this.color.toString());
        gradient.addColorStop(1, "white");
        context.fillStyle = gradient;
        context.beginPath();
        context.arc(w / 2, h / 2, radius, radians(0), radians(360), false);
        context.closePath();
        return context.fill();
      }
    } else if (this.orientation === "horizontal") {
      context.lineWidth = h / 3;
      gradient = context.createLinearGradient(0, 0, 0, context.lineWidth);
      gradient.addColorStop(0, "white");
      gradient.addColorStop(1, this.color.toString());
      context.strokeStyle = gradient;
      context.beginPath();
      context.moveTo(h / 2, context.lineWidth * 0.5);
      context.lineTo(w - h / 2, context.lineWidth * 0.5);
      context.stroke();
      gradient = context.createLinearGradient(0, h - context.lineWidth, 0, h);
      gradient.addColorStop(0, this.color.toString());
      gradient.addColorStop(1, "black");
      context.strokeStyle = gradient;
      context.beginPath();
      context.moveTo(h / 2, h - context.lineWidth * 0.5);
      context.lineTo(w - h / 2, h - context.lineWidth * 0.5);
      context.stroke();
      if (this.hasMiddleDip) {
        gradient = context.createLinearGradient(0, context.lineWidth, 0, h - context.lineWidth);
        radius = h / 4;
        gradient.addColorStop(0, "black");
        gradient.addColorStop(0.35, this.color.toString());
        gradient.addColorStop(0.65, this.color.toString());
        gradient.addColorStop(1, "white");
        context.fillStyle = gradient;
        context.beginPath();
        context.arc(this.width() / 2, this.height() / 2, radius, radians(0), radians(360), false);
        context.closePath();
        return context.fill();
      }
    }
  };

  SliderButtonMorph.prototype.mouseEnter = function() {
    this.image = this.highlightImage;
    return this.changed();
  };

  SliderButtonMorph.prototype.mouseLeave = function() {
    this.image = this.normalImage;
    return this.changed();
  };

  SliderButtonMorph.prototype.mouseDownLeft = function(pos) {
    this.image = this.pressImage;
    this.changed();
    return this.escalateEvent("mouseDownLeft", pos);
  };

  SliderButtonMorph.prototype.mouseClickLeft = function() {
    this.image = this.highlightImage;
    return this.changed();
  };

  SliderButtonMorph.prototype.mouseMove = function() {
    return noOperation;
  };

  return SliderButtonMorph;

})(CircleBoxMorph);

StringFieldMorph = (function(_super) {

  __extends(StringFieldMorph, _super);

  StringFieldMorph.prototype.defaultContents = null;

  StringFieldMorph.prototype.minWidth = null;

  StringFieldMorph.prototype.fontSize = null;

  StringFieldMorph.prototype.fontStyle = null;

  StringFieldMorph.prototype.isBold = null;

  StringFieldMorph.prototype.isItalic = null;

  StringFieldMorph.prototype.isNumeric = null;

  StringFieldMorph.prototype.text = null;

  StringFieldMorph.prototype.isEditable = true;

  function StringFieldMorph(defaultContents, minWidth, fontSize, fontStyle, isBold, isItalic, isNumeric) {
    this.defaultContents = defaultContents != null ? defaultContents : "";
    this.minWidth = minWidth != null ? minWidth : 100;
    this.fontSize = fontSize != null ? fontSize : 12;
    this.fontStyle = fontStyle != null ? fontStyle : "sans-serif";
    this.isBold = isBold != null ? isBold : false;
    this.isItalic = isItalic != null ? isItalic : false;
    this.isNumeric = isNumeric != null ? isNumeric : false;
    StringFieldMorph.__super__.constructor.call(this);
    this.color = new Color(255, 255, 255);
    this.updateRendering();
  }

  StringFieldMorph.prototype.updateRendering = function() {
    var txt;
    txt = (this.text ? this.string() : this.defaultContents);
    this.text = null;
    this.children.forEach(function(child) {
      return child.destroy();
    });
    this.children = [];
    this.text = new StringMorph(txt, this.fontSize, this.fontStyle, this.isBold, this.isItalic, this.isNumeric);
    this.text.isNumeric = this.isNumeric;
    this.text.setPosition(this.bounds.origin.copy());
    this.text.isEditable = this.isEditable;
    this.text.isDraggable = false;
    this.text.enableSelecting();
    this.silentSetExtent(new Point(Math.max(this.width(), this.minWidth), this.text.height()));
    StringFieldMorph.__super__.updateRendering.call(this);
    return this.add(this.text);
  };

  StringFieldMorph.prototype.string = function() {
    return this.text.text;
  };

  StringFieldMorph.prototype.mouseClickLeft = function(pos) {
    if (this.isEditable) {
      return this.text.edit();
    } else {
      return this.escalateEvent('mouseClickLeft', pos);
    }
  };

  StringFieldMorph.prototype.copyRecordingReferences = function(dict) {
    var c;
    c = StringFieldMorph.__super__.copyRecordingReferences.call(this, dict);
    if (c.text && dict[this.text]) {
      c.text = dict[this.text];
    }
    return c;
  };

  return StringFieldMorph;

})(FrameMorph);

InspectorMorph = (function(_super) {

  __extends(InspectorMorph, _super);

  InspectorMorph.prototype.target = null;

  InspectorMorph.prototype.currentProperty = null;

  InspectorMorph.prototype.showing = "attributes";

  InspectorMorph.prototype.markOwnershipOfProperties = false;

  InspectorMorph.prototype.label = null;

  InspectorMorph.prototype.list = null;

  InspectorMorph.prototype.detail = null;

  InspectorMorph.prototype.work = null;

  InspectorMorph.prototype.buttonInspect = null;

  InspectorMorph.prototype.buttonClose = null;

  InspectorMorph.prototype.buttonSubset = null;

  InspectorMorph.prototype.buttonEdit = null;

  InspectorMorph.prototype.resizer = null;

  function InspectorMorph(target) {
    this.target = target;
    InspectorMorph.__super__.constructor.call(this);
    this.silentSetExtent(new Point(WorldMorph.MorphicPreferences.handleSize * 20, WorldMorph.MorphicPreferences.handleSize * 20 * 2 / 3));
    this.isDraggable = true;
    this.border = 1;
    this.edge = 5;
    this.color = new Color(60, 60, 60);
    this.borderColor = new Color(95, 95, 95);
    this.updateRendering();
    if (this.target) {
      this.buildPanes();
    }
  }

  InspectorMorph.prototype.setTarget = function(target) {
    this.target = target;
    this.currentProperty = null;
    return this.buildPanes();
  };

  InspectorMorph.prototype.buildPanes = function() {
    var attribs, ctrl, ev, property, staticAttributes, staticFunctions, staticProperties, targetOwnMethods,
      _this = this;
    attribs = [];
    this.children.forEach(function(m) {
      if (m !== this.work) {
        return m.destroy();
      }
    });
    this.children = [];
    this.label = new TextMorph(this.target.toString());
    this.label.fontSize = WorldMorph.MorphicPreferences.menuFontSize;
    this.label.isBold = true;
    this.label.color = new Color(255, 255, 255);
    this.label.updateRendering();
    this.add(this.label);
    for (property in this.target) {
      if (property) {
        attribs.push(property);
      }
    }
    if (this.showing === "attributes") {
      attribs = attribs.filter(function(prop) {
        return !isFunction(_this.target[prop]);
      });
    } else if (this.showing === "methods") {
      attribs = attribs.filter(function(prop) {
        return isFunction(_this.target[prop]);
      });
    }
    staticProperties = Object.getOwnPropertyNames(this.target.constructor);
    staticProperties = staticProperties.filter(function(prop) {
      return prop !== "name" && prop !== "length" && prop !== "prototype" && prop !== "caller" && prop !== "__super__" && prop !== "arguments";
    });
    if (this.showing === "attributes") {
      staticFunctions = [];
      staticAttributes = staticProperties.filter(function(prop) {
        return !isFunction(_this.target.constructor[prop]);
      });
    } else if (this.showing === "methods") {
      staticFunctions = staticProperties.filter(function(prop) {
        return isFunction(_this.target.constructor[prop]);
      });
      staticAttributes = [];
    } else {
      staticFunctions = staticProperties.filter(function(prop) {
        return isFunction(_this.target.constructor[prop]);
      });
      staticAttributes = staticProperties.filter(function(prop) {
        return __indexOf.call(staticFunctions, prop) < 0;
      });
    }
    attribs = (attribs.concat(staticFunctions)).concat(staticAttributes);
    if (this.markOwnershipOfProperties) {
      targetOwnMethods = Object.getOwnPropertyNames(this.target.constructor.prototype);
    }
    this.list = new ListMorph((this.target instanceof Array ? attribs : attribs.sort()), null, (this.markOwnershipOfProperties ? [
      [
        new Color(0, 0, 180), function(element) {
          return true;
        }
      ], [
        new Color(255, 165, 0), function(element) {
          return __indexOf.call(staticProperties, element) >= 0;
        }
      ], [
        new Color(0, 180, 0), function(element) {
          return _this.target.hasOwnProperty(element);
        }
      ], [
        new Color(180, 0, 0), function(element) {
          return __indexOf.call(targetOwnMethods, element) >= 0;
        }
      ]
    ] : null));
    this.list.action = function(selected) {
      var cnts, txt, val;
      val = _this.target[selected];
      if (val === void 0) {
        val = _this.target.constructor[selected];
      }
      _this.currentProperty = val;
      if (val === null) {
        txt = "NULL";
      } else if (isString(val)) {
        txt = val;
      } else {
        txt = val.toString();
      }
      cnts = new TextMorph(txt);
      cnts.isEditable = true;
      cnts.enableSelecting();
      cnts.setReceiver(_this.target);
      return _this.detail.setContents(cnts);
    };
    this.list.hBar.alpha = 0.6;
    this.list.vBar.alpha = 0.6;
    this.list.listContents.step = null;
    this.add(this.list);
    this.detail = new ScrollFrameMorph();
    this.detail.acceptsDrops = false;
    this.detail.contents.acceptsDrops = false;
    this.detail.isTextLineWrapping = true;
    this.detail.color = new Color(255, 255, 255);
    this.detail.hBar.alpha = 0.6;
    this.detail.vBar.alpha = 0.6;
    ctrl = new TextMorph("");
    ctrl.isEditable = true;
    ctrl.enableSelecting();
    ctrl.setReceiver(this.target);
    this.detail.setContents(ctrl);
    this.add(this.detail);
    if (this.work === null) {
      this.work = new ScrollFrameMorph();
      this.work.acceptsDrops = false;
      this.work.contents.acceptsDrops = false;
      this.work.isTextLineWrapping = true;
      this.work.color = new Color(255, 255, 255);
      this.work.hBar.alpha = 0.6;
      this.work.vBar.alpha = 0.6;
      ev = new TextMorph("");
      ev.isEditable = true;
      ev.enableSelecting();
      ev.setReceiver(this.target);
      this.work.setContents(ev);
    }
    this.add(this.work);
    this.buttonSubset = new TriggerMorph();
    this.buttonSubset.labelString = "show...";
    this.buttonSubset.action = function() {
      var menu;
      menu = new MenuMorph();
      menu.addItem("attributes", function() {
        _this.showing = "attributes";
        return _this.buildPanes();
      });
      menu.addItem("methods", function() {
        _this.showing = "methods";
        return _this.buildPanes();
      });
      menu.addItem("all", function() {
        _this.showing = "all";
        return _this.buildPanes();
      });
      menu.addLine();
      menu.addItem((_this.markOwnershipOfProperties ? "un-mark ownership" : "mark ownership"), (function() {
        _this.markOwnershipOfProperties = !_this.markOwnershipOfProperties;
        return _this.buildPanes();
      }), "highlight\nownership of properties");
      return menu.popUpAtHand(_this.world());
    };
    this.add(this.buttonSubset);
    this.buttonInspect = new TriggerMorph();
    this.buttonInspect.labelString = "inspect...";
    this.buttonInspect.action = function() {
      var menu;
      if (isObject(_this.currentProperty)) {
        menu = new MenuMorph();
        menu.addItem("in new inspector...", function() {
          var inspector, world;
          world = _this.world();
          inspector = new InspectorMorph(_this.currentProperty);
          inspector.setPosition(world.hand.position());
          inspector.keepWithin(world);
          world.add(inspector);
          return inspector.changed();
        });
        menu.addItem("here...", function() {
          return _this.setTarget(_this.currentProperty);
        });
        return menu.popUpAtHand(_this.world());
      } else {
        return _this.inform((_this.currentProperty === null ? "null" : typeof _this.currentProperty) + "\nis not inspectable");
      }
    };
    this.add(this.buttonInspect);
    this.buttonEdit = new TriggerMorph();
    this.buttonEdit.labelString = "edit...";
    this.buttonEdit.action = function() {
      var menu;
      menu = new MenuMorph(_this);
      menu.addItem("save", "save", "accept changes");
      menu.addLine();
      menu.addItem("add property...", "addProperty");
      menu.addItem("rename...", "renameProperty");
      menu.addItem("remove...", "removeProperty");
      return menu.popUpAtHand(_this.world());
    };
    this.add(this.buttonEdit);
    this.buttonClose = new TriggerMorph();
    this.buttonClose.labelString = "close";
    this.buttonClose.action = function() {
      return _this.destroy();
    };
    this.add(this.buttonClose);
    this.resizer = new HandleMorph(this, 150, 100, this.edge, this.edge);
    return this.fixLayout();
  };

  InspectorMorph.prototype.fixLayout = function() {
    var b, h, r, w, x, y;
    Morph.prototype.trackChanges = false;
    x = this.left() + this.edge;
    y = this.top() + this.edge;
    r = this.right() - this.edge;
    w = r - x;
    this.label.setPosition(new Point(x, y));
    this.label.setWidth(w);
    if (this.label.height() > (this.height() - 50)) {
      this.silentSetHeight(this.label.height() + 50);
      this.updateRendering();
      this.changed();
      this.resizer.updateRendering();
    }
    y = this.label.bottom() + 2;
    w = Math.min(Math.floor(this.width() / 3), this.list.listContents.width());
    w -= this.edge;
    b = this.bottom() - (2 * this.edge) - WorldMorph.MorphicPreferences.handleSize;
    h = b - y;
    this.list.setPosition(new Point(x, y));
    this.list.setExtent(new Point(w, h));
    x = this.list.right() + this.edge;
    r = this.right() - this.edge;
    w = r - x;
    this.detail.setPosition(new Point(x, y));
    this.detail.setExtent(new Point(w, (h * 2 / 3) - this.edge));
    y = this.detail.bottom() + this.edge;
    this.work.setPosition(new Point(x, y));
    this.work.setExtent(new Point(w, h / 3));
    x = this.list.left();
    y = this.list.bottom() + this.edge;
    w = this.list.width();
    h = WorldMorph.MorphicPreferences.handleSize;
    this.buttonSubset.setPosition(new Point(x, y));
    this.buttonSubset.setExtent(new Point(w, h));
    x = this.detail.left();
    w = this.detail.width() - this.edge - WorldMorph.MorphicPreferences.handleSize;
    w = w / 3 - this.edge / 3;
    this.buttonInspect.setPosition(new Point(x, y));
    this.buttonInspect.setExtent(new Point(w, h));
    x = this.buttonInspect.right() + this.edge;
    this.buttonEdit.setPosition(new Point(x, y));
    this.buttonEdit.setExtent(new Point(w, h));
    x = this.buttonEdit.right() + this.edge;
    r = this.detail.right() - this.edge - WorldMorph.MorphicPreferences.handleSize;
    w = r - x;
    this.buttonClose.setPosition(new Point(x, y));
    this.buttonClose.setExtent(new Point(w, h));
    Morph.prototype.trackChanges = true;
    return this.changed();
  };

  InspectorMorph.prototype.setExtent = function(aPoint) {
    InspectorMorph.__super__.setExtent.call(this, aPoint);
    return this.fixLayout();
  };

  InspectorMorph.prototype.save = function() {
    var prop, txt;
    txt = this.detail.contents.children[0].text.toString();
    prop = this.list.selected;
    try {
      this.target.evaluateString("this." + prop + " = " + txt);
      if (this.target.updateRendering) {
        this.target.changed();
        this.target.updateRendering();
        return this.target.changed();
      }
    } catch (err) {
      return this.inform(err);
    }
  };

  InspectorMorph.prototype.addProperty = function() {
    var _this = this;
    return this.prompt("new property name:", (function(prop) {
      if (prop) {
        _this.target[prop] = null;
        _this.buildPanes();
        if (_this.target.updateRendering) {
          _this.target.changed();
          _this.target.updateRendering();
          return _this.target.changed();
        }
      }
    }), this, "property");
  };

  InspectorMorph.prototype.renameProperty = function() {
    var propertyName,
      _this = this;
    propertyName = this.list.selected;
    return this.prompt("property name:", (function(prop) {
      try {
        delete _this.target[propertyName];
        _this.target[prop] = _this.currentProperty;
      } catch (err) {
        _this.inform(err);
      }
      _this.buildPanes();
      if (_this.target.updateRendering) {
        _this.target.changed();
        _this.target.updateRendering();
        return _this.target.changed();
      }
    }), this, propertyName);
  };

  InspectorMorph.prototype.removeProperty = function() {
    var prop;
    prop = this.list.selected;
    try {
      delete this.target[prop];
      this.currentProperty = null;
      this.buildPanes();
      if (this.target.updateRendering) {
        this.target.changed();
        this.target.updateRendering();
        return this.target.changed();
      }
    } catch (err) {
      return this.inform(err);
    }
  };

  return InspectorMorph;

})(BoxMorph);

TriggerMorph = (function(_super) {

  __extends(TriggerMorph, _super);

  TriggerMorph.prototype.target = null;

  TriggerMorph.prototype.action = null;

  TriggerMorph.prototype.environment = null;

  TriggerMorph.prototype.label = null;

  TriggerMorph.prototype.labelString = null;

  TriggerMorph.prototype.labelColor = null;

  TriggerMorph.prototype.hint = null;

  TriggerMorph.prototype.fontSize = null;

  TriggerMorph.prototype.fontStyle = null;

  TriggerMorph.prototype.highlightColor = new Color(192, 192, 192);

  TriggerMorph.prototype.highlightImage = null;

  TriggerMorph.prototype.pressColor = new Color(128, 128, 128);

  TriggerMorph.prototype.normalImage = null;

  TriggerMorph.prototype.pressImage = null;

  function TriggerMorph(target, action, labelString, fontSize, fontStyle, environment, hint, labelColor) {
    this.target = target != null ? target : null;
    this.action = action != null ? action : null;
    this.labelString = labelString != null ? labelString : null;
    this.environment = environment != null ? environment : null;
    this.hint = hint != null ? hint : null;
    this.fontSize = fontSize || WorldMorph.MorphicPreferences.menuFontSize;
    this.fontStyle = fontStyle || "sans-serif";
    this.labelColor = labelColor || new Color(0, 0, 0);
    TriggerMorph.__super__.constructor.call(this);
    this.color = new Color(255, 255, 255);
    this.updateRendering();
  }

  TriggerMorph.prototype.updateRendering = function() {
    this.createBackgrounds();
    if (this.labelString !== null) {
      return this.createLabel();
    }
  };

  TriggerMorph.prototype.createBackgrounds = function() {
    var context, ext;
    ext = this.extent();
    this.normalImage = newCanvas(ext);
    context = this.normalImage.getContext("2d");
    context.fillStyle = this.color.toString();
    context.fillRect(0, 0, ext.x, ext.y);
    this.highlightImage = newCanvas(ext);
    context = this.highlightImage.getContext("2d");
    context.fillStyle = this.highlightColor.toString();
    context.fillRect(0, 0, ext.x, ext.y);
    this.pressImage = newCanvas(ext);
    context = this.pressImage.getContext("2d");
    context.fillStyle = this.pressColor.toString();
    context.fillRect(0, 0, ext.x, ext.y);
    return this.image = this.normalImage;
  };

  TriggerMorph.prototype.createLabel = function() {
    if (this.label !== null) {
      this.label.destroy();
    }
    this.label = new StringMorph(this.labelString, this.fontSize, this.fontStyle, false, false, false, null, null, this.labelColor);
    this.label.setPosition(this.center().subtract(this.label.extent().floorDivideBy(2)));
    return this.add(this.label);
  };

  TriggerMorph.prototype.copyRecordingReferences = function(dict) {
    var c;
    c = TriggerMorph.__super__.copyRecordingReferences.call(this, dict);
    if (c.label && dict[this.label]) {
      c.label = dict[this.label];
    }
    return c;
  };

  TriggerMorph.prototype.trigger = function() {
    if (typeof this.target === "function") {
      if (typeof this.action === "function") {
        return this.target.call(this.environment, this.action.call());
      } else {
        return this.target.call(this.environment, this.action);
      }
    } else {
      if (typeof this.action === "function") {
        return this.action.call(this.target);
      } else {
        return this.target[this.action]();
      }
    }
  };

  TriggerMorph.prototype.mouseEnter = function() {
    this.image = this.highlightImage;
    this.changed();
    if (this.hint) {
      return this.bubbleHelp(this.hint);
    }
  };

  TriggerMorph.prototype.mouseLeave = function() {
    this.image = this.normalImage;
    this.changed();
    if (this.hint) {
      return this.world().hand.destroyTemporaries();
    }
  };

  TriggerMorph.prototype.mouseDownLeft = function() {
    this.image = this.pressImage;
    return this.changed();
  };

  TriggerMorph.prototype.mouseClickLeft = function() {
    this.image = this.highlightImage;
    this.changed();
    return this.trigger();
  };

  TriggerMorph.prototype.bubbleHelp = function(contents) {
    var _this = this;
    this.fps = 2;
    return this.step = function() {
      if (_this.bounds.containsPoint(_this.world().hand.position())) {
        _this.popUpbubbleHelp(contents);
      }
      _this.fps = 0;
      return delete _this.step;
    };
  };

  TriggerMorph.prototype.popUpbubbleHelp = function(contents) {
    return new SpeechBubbleMorph(localize(contents), null, null, 1).popUp(this.world(), this.rightCenter().add(new Point(-8, 0)));
  };

  return TriggerMorph;

})(Morph);

MenuItemMorph = (function(_super) {

  __extends(MenuItemMorph, _super);

  function MenuItemMorph(target, action, labelString, fontSize, fontStyle, environment, hint, color) {
    MenuItemMorph.__super__.constructor.call(this, target, action, labelString, fontSize, fontStyle, environment, hint, color);
  }

  MenuItemMorph.prototype.createLabel = function() {
    var icon, lbl, np;
    if (this.label !== null) {
      this.label.destroy();
    }
    if (isString(this.labelString)) {
      this.label = this.createLabelString(this.labelString);
    } else if (this.labelString instanceof Array) {
      this.label = new Morph();
      this.label.alpha = 0;
      this.label.add(icon = this.createIcon(this.labelString[0]));
      this.label.add(lbl = this.createLabelString(this.labelString[1]));
      lbl.setCenter(icon.center());
      lbl.setLeft(icon.right() + 4);
      this.label.bounds = icon.bounds.merge(lbl.bounds);
      this.label.updateRendering();
    } else {
      this.label = this.createIcon(this.labelString);
    }
    this.silentSetExtent(this.label.extent().add(new Point(8, 0)));
    np = this.position().add(new Point(4, 0));
    this.label.bounds = np.extent(this.label.extent());
    return this.add(this.label);
  };

  MenuItemMorph.prototype.createIcon = function(source) {
    var icon, src;
    icon = new Morph();
    icon.image = (source instanceof Morph ? source.fullImage() : source);
    if (source instanceof Morph && source.getShadow()) {
      src = icon.image;
      icon.image = newCanvas(source.fullBounds().extent().subtract(this.shadowBlur * (useBlurredShadows ? 1 : 2)));
      icon.image.getContext("2d").drawImage(src, 0, 0);
    }
    icon.silentSetWidth(icon.image.width);
    icon.silentSetHeight(icon.image.height);
    return icon;
  };

  MenuItemMorph.prototype.createLabelString = function(string) {
    var lbl;
    lbl = new TextMorph(string, this.fontSize, this.fontStyle);
    lbl.setColor(this.labelColor);
    return lbl;
  };

  MenuItemMorph.prototype.mouseEnter = function() {
    if (!this.isListItem()) {
      this.image = this.highlightImage;
      this.changed();
    }
    if (this.hint) {
      return this.bubbleHelp(this.hint);
    }
  };

  MenuItemMorph.prototype.mouseLeave = function() {
    if (!this.isListItem()) {
      this.image = this.normalImage;
      this.changed();
    }
    if (this.hint) {
      return this.world().hand.destroyTemporaries();
    }
  };

  MenuItemMorph.prototype.mouseDownLeft = function(pos) {
    if (this.isListItem()) {
      this.parent.unselectAllItems();
      this.escalateEvent("mouseDownLeft", pos);
    }
    this.image = this.pressImage;
    return this.changed();
  };

  MenuItemMorph.prototype.mouseMove = function() {
    if (this.isListItem()) {
      return this.escalateEvent("mouseMove");
    }
  };

  MenuItemMorph.prototype.mouseClickLeft = function() {
    if (!this.isListItem()) {
      this.parent.destroy();
      this.root().activeMenu = null;
    }
    return this.trigger();
  };

  MenuItemMorph.prototype.isListItem = function() {
    if (this.parent) {
      return this.parent.isListContents;
    }
    return false;
  };

  MenuItemMorph.prototype.isSelectedListItem = function() {
    if (this.isListItem()) {
      return this.image === this.pressImage;
    }
    return false;
  };

  return MenuItemMorph;

})(TriggerMorph);

MorphsListMorph = (function(_super) {

  __extends(MorphsListMorph, _super);

  MorphsListMorph.prototype.morphsList = null;

  MorphsListMorph.prototype.buttonClose = null;

  MorphsListMorph.prototype.resizer = null;

  function MorphsListMorph(target) {
    MorphsListMorph.__super__.constructor.call(this);
    this.silentSetExtent(new Point(WorldMorph.MorphicPreferences.handleSize * 10, WorldMorph.MorphicPreferences.handleSize * 20 * 2 / 3));
    this.isDraggable = true;
    this.border = 1;
    this.edge = 5;
    this.color = new Color(60, 60, 60);
    this.borderColor = new Color(95, 95, 95);
    this.updateRendering();
    this.buildPanes();
  }

  MorphsListMorph.prototype.setTarget = function(target) {
    this.target = target;
    this.currentProperty = null;
    return this.buildPanes();
  };

  MorphsListMorph.prototype.buildPanes = function() {
    var ListOfMorphs, attribs, theWordMorph,
      _this = this;
    attribs = [];
    this.children.forEach(function(m) {
      if (m !== this.work) {
        return m.destroy();
      }
    });
    this.children = [];
    this.label = new TextMorph("Morphs List");
    this.label.fontSize = WorldMorph.MorphicPreferences.menuFontSize;
    this.label.isBold = true;
    this.label.color = new Color(255, 255, 255);
    this.label.updateRendering();
    this.add(this.label);
    theWordMorph = "Morph";
    ListOfMorphs = (Object.keys(window)).filter(function(i) {
      return i.indexOf(theWordMorph, i.length - theWordMorph.length) !== -1;
    });
    this.morphsList = new ListMorph(ListOfMorphs, null);
    this.morphsList.hBar.alpha = 0.6;
    this.morphsList.vBar.alpha = 0.6;
    this.add(this.morphsList);
    this.buttonClose = new TriggerMorph();
    this.buttonClose.labelString = "close";
    this.buttonClose.action = function() {
      return _this.destroy();
    };
    this.add(this.buttonClose);
    this.resizer = new HandleMorph(this, 150, 100, this.edge, this.edge);
    return this.fixLayout();
  };

  MorphsListMorph.prototype.fixLayout = function() {
    var b, h, r, w, x, y;
    Morph.prototype.trackChanges = false;
    x = this.left() + this.edge;
    y = this.top() + this.edge;
    r = this.right() - this.edge;
    w = r - x;
    this.label.setPosition(new Point(x, y));
    this.label.setWidth(w);
    if (this.label.height() > (this.height() - 50)) {
      this.silentSetHeight(this.label.height() + 50);
      this.updateRendering();
      this.changed();
      this.resizer.updateRendering();
    }
    y = this.label.bottom() + 2;
    w = this.width() - this.edge;
    w -= this.edge;
    b = this.bottom() - (2 * this.edge) - WorldMorph.MorphicPreferences.handleSize;
    h = b - y;
    this.morphsList.setPosition(new Point(x, y));
    this.morphsList.setExtent(new Point(w, h));
    x = this.morphsList.left();
    y = this.morphsList.bottom() + this.edge;
    h = WorldMorph.MorphicPreferences.handleSize;
    w = this.morphsList.width() - h - this.edge;
    this.buttonClose.setPosition(new Point(x, y));
    this.buttonClose.setExtent(new Point(w, h));
    Morph.prototype.trackChanges = true;
    return this.changed();
  };

  MorphsListMorph.prototype.setExtent = function(aPoint) {
    MorphsListMorph.__super__.setExtent.call(this, aPoint);
    return this.fixLayout();
  };

  return MorphsListMorph;

})(BoxMorph);

Point2 = (function() {

  Point2.prototype.x = null;

  Point2.prototype.y = null;

  function Point2(x, y) {
    this.x = x != null ? x : 0;
    this.y = y != null ? y : 0;
  }

  Point2.prototype.toString = function() {
    return Math.round(this.x.toString()) + "@" + Math.round(this.y.toString());
  };

  Point2.prototype.copy = function() {
    return new Point2(this.x, this.y);
  };

  Point2.prototype.eq = function(aPoint2) {
    return this.x === aPoint2.x && this.y === aPoint2.y;
  };

  Point2.prototype.lt = function(aPoint2) {
    return this.x < aPoint2.x && this.y < aPoint2.y;
  };

  Point2.prototype.gt = function(aPoint2) {
    return this.x > aPoint2.x && this.y > aPoint2.y;
  };

  Point2.prototype.ge = function(aPoint2) {
    return this.x >= aPoint2.x && this.y >= aPoint2.y;
  };

  Point2.prototype.le = function(aPoint2) {
    return this.x <= aPoint2.x && this.y <= aPoint2.y;
  };

  Point2.prototype.max = function(aPoint2) {
    this.x = Math.max(this.x, aPoint2.x);
    return this.y = Math.max(this.y, aPoint2.y);
  };

  Point2.prototype.min = function(aPoint2) {
    this.x = Math.min(this.x, aPoint2.x);
    return this.y = Math.min(this.y, aPoint2.y);
  };

  Point2.prototype.round = function() {
    this.x = Math.round(this.x);
    return this.y = Math.round(this.y);
  };

  Point2.prototype.abs = function() {
    this.x = Math.abs(this.x);
    return this.y = Math.abs(this.y);
  };

  Point2.prototype.neg = function() {
    this.x = -this.x;
    return this.y = -this.y;
  };

  Point2.prototype.mirror = function() {
    var tmpValueForSwappingXAndY;
    tmpValueForSwappingXAndY = this.x;
    this.x = this.y;
    return this.y = tmpValueForSwappingXAndY;
  };

  Point2.prototype.floor = function() {
    this.x = Math.max(Math.floor(this.x), 0);
    return this.y = Math.max(Math.floor(this.y), 0);
  };

  Point2.prototype.ceil = function() {
    this.x = Math.ceil(this.x);
    return this.y = Math.ceil(this.y);
  };

  Point2.prototype.add = function(other) {
    if (other instanceof Point2) {
      this.x = this.x + other.x;
      this.y = this.y + other.y;
      return;
    }
    this.x = this.x + other;
    return this.y = this.y + other;
  };

  Point2.prototype.subtract = function(other) {
    if (other instanceof Point2) {
      this.x = this.x - other.x;
      this.y = this.y - other.y;
      return;
    }
    this.x = this.x - other;
    return this.y = this.y - other;
  };

  Point2.prototype.multiplyBy = function(other) {
    if (other instanceof Point2) {
      this.x = this.x * other.x;
      this.y = this.y * other.y;
      return;
    }
    this.x = this.x * other;
    return this.y = this.y * other;
  };

  Point2.prototype.divideBy = function(other) {
    if (other instanceof Point2) {
      this.x = this.x / other.x;
      this.y = this.y / other.y;
      return;
    }
    this.x = this.x / other;
    return this.y = this.y / other;
  };

  Point2.prototype.floorDivideBy = function(other) {
    if (other instanceof Point2) {
      this.x = Math.floor(this.x / other.x);
      this.y = Math.floor(this.y / other.y);
      return;
    }
    this.x = Math.floor(this.x / other);
    return this.y = Math.floor(this.y / other);
  };

  Point2.prototype.r = function() {
    var t;
    t = this.copy();
    t.multiplyBy(t);
    return Math.sqrt(t.x + t.y);
  };

  Point2.prototype.degrees = function() {
    var tan, theta;
    if (this.x === 0) {
      if (this.y >= 0) {
        return 90;
      }
      return 270;
    }
    tan = this.y / this.x;
    theta = Math.atan(tan);
    if (this.x >= 0) {
      if (this.y >= 0) {
        return degrees(theta);
      }
      return 360 + (degrees(theta));
    }
    return 180 + degrees(theta);
  };

  Point2.prototype.theta = function() {
    var tan, theta;
    if (this.x === 0) {
      if (this.y >= 0) {
        return radians(90);
      }
      return radians(270);
    }
    tan = this.y / this.x;
    theta = Math.atan(tan);
    if (this.x >= 0) {
      if (this.y >= 0) {
        return theta;
      }
      return radians(360) + theta;
    }
    return radians(180) + theta;
  };

  Point2.prototype.crossProduct = function(aPoint2) {
    return this.multiplyBy(aPoint2.copy().mirror());
  };

  Point2.prototype.distanceTo = function(aPoint2) {
    return (aPoint2.copy().subtract(this)).r();
  };

  Point2.prototype.rotate = function(direction, center) {
    var offset, tmpPointForRotate;
    offset = this.copy().subtract(center);
    if (direction === "right") {
      this.x = -offset.y + center.x;
      this.y = offset.y + center.y;
      return;
    }
    if (direction === "left") {
      this.x = offset.y + center.x;
      this.y = -offset.y + center.y;
      return;
    }
    tmpPointForRotate = center.copy().subtract(offset);
    this.x = tmpPointForRotate.x;
    return this.y = tmpPointForRotate.y;
  };

  Point2.prototype.flip = function(direction, center) {
    if (direction === "vertical") {
      this.y = center.y * 2 - this.y;
      return;
    }
    return this.x = center.x * 2 - this.x;
  };

  Point2.prototype.distanceAngle = function(dist, angle) {
    var deg, x, y;
    deg = angle;
    if (deg > 270) {
      deg = deg - 360;
    } else {
      if (deg < -270) {
        deg = deg + 360;
      }
    }
    if (-90 <= deg && deg <= 90) {
      x = Math.sin(radians(deg)) * dist;
      y = Math.sqrt((dist * dist) - (x * x));
      this.x = x + this.x;
      this.y = this.y - y;
      return;
    }
    x = Math.sin(radians(180 - deg)) * dist;
    y = Math.sqrt((dist * dist) - (x * x));
    this.x = x + this.x;
    return this.y = this.y + y;
  };

  Point2.prototype.scaleBy = function(scalePoint2) {
    return this.multiplyBy(scalePoint2);
  };

  Point2.prototype.translateBy = function(deltaPoint2) {
    return this.add(deltaPoint2);
  };

  Point2.prototype.rotateBy = function(angle, centerPoint2) {
    var center, p, r, theta;
    center = centerPoint2 || new Point2(0, 0);
    p = this.copy().subtract(center);
    r = p.r();
    theta = angle - p.theta();
    this.x = center.x + (r * Math.cos(theta));
    return this.y = center.y - (r * Math.sin(theta));
  };

  Point2.prototype.asArray = function() {
    return [this.x, this.y];
  };

  Point2.prototype.corner = function(cornerPoint2) {
    return new Rectangle(this.x, this.y, cornerPoint2.x, cornerPoint2.y);
  };

  Point2.prototype.rectangle = function(aPoint2) {
    var crn, org;
    org = this.copy().min(aPoint2);
    crn = this.copy().max(aPoint2);
    return new Rectangle(org.x, org.y, crn.x, crn.y);
  };

  Point2.prototype.extent = function(aPoint2) {
    var crn;
    crn = this.copy().add(aPoint2);
    return new Rectangle(this.x, this.y, crn.x, crn.y);
  };

  return Point2;

})();

StringMorph = (function(_super) {

  __extends(StringMorph, _super);

  StringMorph.prototype.text = null;

  StringMorph.prototype.fontSize = null;

  StringMorph.prototype.fontName = null;

  StringMorph.prototype.fontStyle = null;

  StringMorph.prototype.isBold = null;

  StringMorph.prototype.isItalic = null;

  StringMorph.prototype.isEditable = false;

  StringMorph.prototype.isNumeric = null;

  StringMorph.prototype.isPassword = false;

  StringMorph.prototype.shadowOffset = null;

  StringMorph.prototype.shadowColor = null;

  StringMorph.prototype.isShowingBlanks = false;

  StringMorph.prototype.blanksColor = new Color(180, 140, 140);

  StringMorph.prototype.isScrollable = true;

  StringMorph.prototype.currentlySelecting = false;

  StringMorph.prototype.startMark = 0;

  StringMorph.prototype.endMark = 0;

  StringMorph.prototype.markedTextColor = new Color(255, 255, 255);

  StringMorph.prototype.markedBackgoundColor = new Color(60, 60, 120);

  function StringMorph(text, fontSize, fontStyle, isBold, isItalic, isNumeric, shadowOffset, shadowColor, color, fontName) {
    this.fontSize = fontSize != null ? fontSize : 12;
    this.fontStyle = fontStyle != null ? fontStyle : "sans-serif";
    this.isBold = isBold != null ? isBold : false;
    this.isItalic = isItalic != null ? isItalic : false;
    this.isNumeric = isNumeric != null ? isNumeric : false;
    this.shadowColor = shadowColor;
    this.text = text || (text === "" ? "" : "StringMorph");
    this.fontName = fontName || WorldMorph.MorphicPreferences.globalFontFamily;
    this.shadowOffset = shadowOffset || new Point(0, 0);
    StringMorph.__super__.constructor.call(this);
    this.color = color || new Color(0, 0, 0);
    this.noticesTransparentClick = true;
    this.updateRendering();
  }

  StringMorph.prototype.toString = function() {
    return "a " + (this.constructor.name || this.constructor.toString().split(" ")[1].split("(")[0]) + "(\"" + this.text.slice(0, 30) + "...\")";
  };

  StringMorph.prototype.password = function(letter, length) {
    var ans, i, _i;
    ans = "";
    for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
      ans += letter;
    }
    return ans;
  };

  StringMorph.prototype.font = function() {
    var font;
    font = "";
    if (this.isBold) {
      font = font + "bold ";
    }
    if (this.isItalic) {
      font = font + "italic ";
    }
    return font + this.fontSize + "px " + (this.fontName ? this.fontName + ", " : "") + this.fontStyle;
  };

  StringMorph.prototype.updateRendering = function() {
    var c, context, i, p, start, stop, text, width, x, y, _i;
    text = (this.isPassword ? this.password("*", this.text.length) : this.text);
    this.image = newCanvas();
    context = this.image.getContext("2d");
    context.font = this.font();
    width = Math.max(context.measureText(text).width + Math.abs(this.shadowOffset.x), 1);
    this.bounds.corner = this.bounds.origin.add(new Point(width, fontHeight(this.fontSize) + Math.abs(this.shadowOffset.y)));
    this.image.width = width;
    this.image.height = this.height();
    context.font = this.font();
    context.textAlign = "left";
    context.textBaseline = "bottom";
    if (this.shadowColor) {
      x = Math.max(this.shadowOffset.x, 0);
      y = Math.max(this.shadowOffset.y, 0);
      context.fillStyle = this.shadowColor.toString();
      context.fillText(text, x, fontHeight(this.fontSize) + y);
    }
    x = Math.abs(Math.min(this.shadowOffset.x, 0));
    y = Math.abs(Math.min(this.shadowOffset.y, 0));
    context.fillStyle = this.color.toString();
    if (this.isShowingBlanks) {
      this.renderWithBlanks(context, x, fontHeight(this.fontSize) + y);
    } else {
      context.fillText(text, x, fontHeight(this.fontSize) + y);
    }
    start = Math.min(this.startMark, this.endMark);
    stop = Math.max(this.startMark, this.endMark);
    for (i = _i = start; start <= stop ? _i < stop : _i > stop; i = start <= stop ? ++_i : --_i) {
      p = this.slotPosition(i).subtract(this.position());
      c = text.charAt(i);
      context.fillStyle = this.markedBackgoundColor.toString();
      context.fillRect(p.x, p.y, context.measureText(c).width + 1 + x, fontHeight(this.fontSize) + y);
      context.fillStyle = this.markedTextColor.toString();
      context.fillText(c, p.x + x, fontHeight(this.fontSize) + y);
    }
    if (this.parent ? this.parent.fixLayout : void 0) {
      return this.parent.fixLayout();
    }
  };

  StringMorph.prototype.renderWithBlanks = function(context, startX, y) {
    var blank, ctx, drawBlank, isFirst, space, words, x;
    drawBlank = function() {
      context.drawImage(blank, Math.round(x), 0);
      return x += space;
    };
    space = context.measureText(" ").width;
    blank = newCanvas(new Point(space, this.height()));
    ctx = blank.getContext("2d");
    words = this.text.split(" ");
    x = startX || 0;
    isFirst = true;
    ctx.fillStyle = this.blanksColor.toString();
    ctx.arc(space / 2, blank.height / 2, space / 2, radians(0), radians(360));
    ctx.fill();
    return words.forEach(function(word) {
      if (!isFirst) {
        drawBlank();
      }
      isFirst = false;
      if (word !== "") {
        context.fillText(word, x, y);
        return x += context.measureText(word).width;
      }
    });
  };

  StringMorph.prototype.slotPosition = function(slot) {
    var context, dest, idx, text, x, xOffset, y, _i;
    text = (this.isPassword ? this.password("*", this.text.length) : this.text);
    dest = Math.min(Math.max(slot, 0), text.length);
    context = this.image.getContext("2d");
    xOffset = 0;
    for (idx = _i = 0; 0 <= dest ? _i < dest : _i > dest; idx = 0 <= dest ? ++_i : --_i) {
      xOffset += context.measureText(text[idx]).width;
    }
    this.pos = dest;
    x = this.left() + xOffset;
    y = this.top();
    return new Point(x, y);
  };

  StringMorph.prototype.slotAt = function(aPoint) {
    var charX, context, idx, text;
    text = (this.isPassword ? this.password("*", this.text.length) : this.text);
    idx = 0;
    charX = 0;
    context = this.image.getContext("2d");
    while (aPoint.x - this.left() > charX) {
      charX += context.measureText(text[idx]).width;
      idx += 1;
      if (idx === text.length) {
        if ((context.measureText(text).width - (context.measureText(text[idx - 1]).width / 2)) < (aPoint.x - this.left())) {
          return idx;
        }
      }
    }
    return idx - 1;
  };

  StringMorph.prototype.upFrom = function(slot) {
    return slot;
  };

  StringMorph.prototype.downFrom = function(slot) {
    return slot;
  };

  StringMorph.prototype.startOfLine = function() {
    return 0;
  };

  StringMorph.prototype.endOfLine = function() {
    return this.text.length;
  };

  StringMorph.prototype.rawHeight = function() {
    return this.height() / 1.2;
  };

  StringMorph.prototype.developersMenu = function() {
    var menu;
    menu = StringMorph.__super__.developersMenu.call(this);
    menu.addLine();
    menu.addItem("edit", "edit");
    menu.addItem("font size...", (function() {
      return this.prompt(menu.title + "\nfont\nsize:", this.setFontSize, this, this.fontSize.toString(), null, 6, 500, true);
    }), "set this String's\nfont point size");
    if (this.fontStyle !== "serif") {
      menu.addItem("serif", "setSerif");
    }
    if (this.fontStyle !== "sans-serif") {
      menu.addItem("sans-serif", "setSansSerif");
    }
    if (this.isBold) {
      menu.addItem("normal weight", "toggleWeight");
    } else {
      menu.addItem("bold", "toggleWeight");
    }
    if (this.isItalic) {
      menu.addItem("normal style", "toggleItalic");
    } else {
      menu.addItem("italic", "toggleItalic");
    }
    if (this.isShowingBlanks) {
      menu.addItem("hide blanks", "toggleShowBlanks");
    } else {
      menu.addItem("show blanks", "toggleShowBlanks");
    }
    if (this.isPassword) {
      menu.addItem("show characters", "toggleIsPassword");
    } else {
      menu.addItem("hide characters", "toggleIsPassword");
    }
    return menu;
  };

  StringMorph.prototype.toggleIsDraggable = function() {
    this.isDraggable = !this.isDraggable;
    if (this.isDraggable) {
      return this.disableSelecting();
    } else {
      return this.enableSelecting();
    }
  };

  StringMorph.prototype.toggleShowBlanks = function() {
    this.isShowingBlanks = !this.isShowingBlanks;
    this.changed();
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.toggleWeight = function() {
    this.isBold = !this.isBold;
    this.changed();
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.toggleItalic = function() {
    this.isItalic = !this.isItalic;
    this.changed();
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.toggleIsPassword = function() {
    this.isPassword = !this.isPassword;
    this.changed();
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.setSerif = function() {
    this.fontStyle = "serif";
    this.changed();
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.setSansSerif = function() {
    this.fontStyle = "sans-serif";
    this.changed();
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.setFontSize = function(size) {
    var newSize;
    if (typeof size === "number") {
      this.fontSize = Math.round(Math.min(Math.max(size, 4), 500));
    } else {
      newSize = parseFloat(size);
      if (!isNaN(newSize)) {
        this.fontSize = Math.round(Math.min(Math.max(newSize, 4), 500));
      }
    }
    this.changed();
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.setText = function(size) {
    this.text = Math.round(size).toString();
    this.changed();
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.numericalSetters = function() {
    return ["setLeft", "setTop", "setAlphaScaled", "setFontSize", "setText"];
  };

  StringMorph.prototype.edit = function() {
    return this.root().edit(this);
  };

  StringMorph.prototype.selection = function() {
    var start, stop;
    start = Math.min(this.startMark, this.endMark);
    stop = Math.max(this.startMark, this.endMark);
    return this.text.slice(start, stop);
  };

  StringMorph.prototype.selectionStartSlot = function() {
    return Math.min(this.startMark, this.endMark);
  };

  StringMorph.prototype.clearSelection = function() {
    this.currentlySelecting = false;
    this.startMark = 0;
    this.endMark = 0;
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.deleteSelection = function() {
    var start, stop, text;
    text = this.text;
    start = Math.min(this.startMark, this.endMark);
    stop = Math.max(this.startMark, this.endMark);
    this.text = text.slice(0, start) + text.slice(stop);
    this.changed();
    return this.clearSelection();
  };

  StringMorph.prototype.selectAll = function() {
    this.startMark = 0;
    this.endMark = this.text.length;
    this.updateRendering();
    return this.changed();
  };

  StringMorph.prototype.mouseDownLeft = function(pos) {
    if (this.isEditable) {
      return this.clearSelection();
    } else {
      return this.escalateEvent("mouseDownLeft", pos);
    }
  };

  StringMorph.prototype.mouseClickLeft = function(pos) {
    var caret;
    caret = this.root().caret;
    if (this.isEditable) {
      if (!this.currentlySelecting) {
        this.edit();
      }
      if (caret) {
        caret.gotoPos(pos);
      }
      this.root().caret.gotoPos(pos);
      return this.currentlySelecting = true;
    } else {
      return this.escalateEvent("mouseClickLeft", pos);
    }
  };

  StringMorph.prototype.enableSelecting = function() {
    this.mouseDownLeft = function(pos) {
      this.clearSelection();
      if (this.isEditable && (!this.isDraggable)) {
        this.edit();
        this.root().caret.gotoPos(pos);
        this.startMark = this.slotAt(pos);
        this.endMark = this.startMark;
        return this.currentlySelecting = true;
      }
    };
    return this.mouseMove = function(pos) {
      var newMark;
      if (this.isEditable && this.currentlySelecting && (!this.isDraggable)) {
        newMark = this.slotAt(pos);
        if (newMark !== this.endMark) {
          this.endMark = newMark;
          this.updateRendering();
          return this.changed();
        }
      }
    };
  };

  StringMorph.prototype.disableSelecting = function() {
    this.mouseDownLeft = StringMorph.prototype.mouseDownLeft;
    return delete this.mouseMove;
  };

  return StringMorph;

})(Morph);

TextMorph = (function(_super) {

  __extends(TextMorph, _super);

  TextMorph.prototype.words = [];

  TextMorph.prototype.lines = [];

  TextMorph.prototype.lineSlots = [];

  TextMorph.prototype.alignment = null;

  TextMorph.prototype.maxWidth = null;

  TextMorph.prototype.maxLineWidth = 0;

  TextMorph.prototype.backgroundColor = null;

  TextMorph.prototype.receiver = null;

  function TextMorph(text, fontSize, fontStyle, isBold, isItalic, alignment, maxWidth, fontName, shadowOffset, shadowColor) {
    this.fontSize = fontSize != null ? fontSize : 12;
    this.fontStyle = fontStyle != null ? fontStyle : "sans-serif";
    this.isBold = isBold != null ? isBold : false;
    this.isItalic = isItalic != null ? isItalic : false;
    this.alignment = alignment != null ? alignment : "left";
    this.maxWidth = maxWidth != null ? maxWidth : 0;
    this.shadowColor = shadowColor != null ? shadowColor : null;
    TextMorph.__super__.constructor.call(this);
    this.markedTextColor = new Color(255, 255, 255);
    this.markedBackgoundColor = new Color(60, 60, 120);
    this.text = text || (text === "" ? text : "TextMorph");
    this.fontName = fontName || WorldMorph.MorphicPreferences.globalFontFamily;
    this.shadowOffset = shadowOffset || new Point(0, 0);
    this.color = new Color(0, 0, 0);
    this.noticesTransparentClick = true;
    this.updateRendering();
  }

  TextMorph.prototype.toString = function() {
    return "a TextMorph" + "(\"" + this.text.slice(0, 30) + "...\")";
  };

  TextMorph.prototype.parse = function() {
    var canvas, context, oldline, paragraphs, slot,
      _this = this;
    paragraphs = this.text.split("\n");
    canvas = newCanvas();
    context = canvas.getContext("2d");
    oldline = "";
    slot = 0;
    context.font = this.font();
    this.maxLineWidth = 0;
    this.lines = [];
    this.lineSlots = [0];
    this.words = [];
    paragraphs.forEach(function(p) {
      _this.words = _this.words.concat(p.split(" "));
      return _this.words.push("\n");
    });
    return this.words.forEach(function(word) {
      var newline, w;
      if (word === "\n") {
        _this.lines.push(oldline);
        _this.lineSlots.push(slot);
        _this.maxLineWidth = Math.max(_this.maxLineWidth, context.measureText(oldline).width);
        return oldline = "";
      } else {
        if (_this.maxWidth > 0) {
          newline = oldline + word + " ";
          w = context.measureText(newline).width;
          if (w > _this.maxWidth) {
            _this.lines.push(oldline);
            _this.lineSlots.push(slot);
            _this.maxLineWidth = Math.max(_this.maxLineWidth, context.measureText(oldline).width);
            oldline = word + " ";
          } else {
            oldline = newline;
          }
        } else {
          oldline = oldline + word + " ";
        }
        return slot += word.length + 1;
      }
    });
  };

  TextMorph.prototype.updateRendering = function() {
    var c, context, height, i, line, offx, offy, p, shadowHeight, shadowWidth, start, stop, width, x, y, _i, _j, _k, _len, _len1, _ref, _ref1;
    this.image = newCanvas();
    context = this.image.getContext("2d");
    context.font = this.font();
    this.parse();
    shadowWidth = Math.abs(this.shadowOffset.x);
    shadowHeight = Math.abs(this.shadowOffset.y);
    height = this.lines.length * (fontHeight(this.fontSize) + shadowHeight);
    if (this.maxWidth === 0) {
      this.bounds = this.bounds.origin.extent(new Point(this.maxLineWidth + shadowWidth, height));
    } else {
      this.bounds = this.bounds.origin.extent(new Point(this.maxWidth + shadowWidth, height));
    }
    this.image.width = this.width();
    this.image.height = this.height();
    context = this.image.getContext("2d");
    context.font = this.font();
    context.textAlign = "left";
    context.textBaseline = "bottom";
    if (this.backgroundColor) {
      context.fillStyle = this.backgroundColor.toString();
      context.fillRect(0, 0, this.width(), this.height());
    }
    if (this.shadowColor) {
      offx = Math.max(this.shadowOffset.x, 0);
      offy = Math.max(this.shadowOffset.y, 0);
      context.fillStyle = this.shadowColor.toString();
      i = 0;
      _ref = this.lines;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        width = context.measureText(line).width + shadowWidth;
        if (this.alignment === "right") {
          x = this.width() - width;
        } else if (this.alignment === "center") {
          x = (this.width() - width) / 2;
        } else {
          x = 0;
        }
        y = (i + 1) * (fontHeight(this.fontSize) + shadowHeight) - shadowHeight;
        i++;
        context.fillText(line, x + offx, y + offy);
      }
    }
    offx = Math.abs(Math.min(this.shadowOffset.x, 0));
    offy = Math.abs(Math.min(this.shadowOffset.y, 0));
    context.fillStyle = this.color.toString();
    i = 0;
    _ref1 = this.lines;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      line = _ref1[_j];
      width = context.measureText(line).width + shadowWidth;
      if (this.alignment === "right") {
        x = this.width() - width;
      } else if (this.alignment === "center") {
        x = (this.width() - width) / 2;
      } else {
        x = 0;
      }
      y = (i + 1) * (fontHeight(this.fontSize) + shadowHeight) - shadowHeight;
      i++;
      context.fillText(line, x + offx, y + offy);
    }
    start = Math.min(this.startMark, this.endMark);
    stop = Math.max(this.startMark, this.endMark);
    for (i = _k = start; start <= stop ? _k < stop : _k > stop; i = start <= stop ? ++_k : --_k) {
      p = this.slotPosition(i).subtract(this.position());
      c = this.text.charAt(i);
      context.fillStyle = this.markedBackgoundColor.toString();
      context.fillRect(p.x, p.y, context.measureText(c).width + 1, fontHeight(this.fontSize));
      context.fillStyle = this.markedTextColor.toString();
      context.fillText(c, p.x, p.y + fontHeight(this.fontSize));
    }
    if (this.parent ? this.parent.layoutChanged : void 0) {
      return this.parent.layoutChanged();
    }
  };

  TextMorph.prototype.setExtent = function(aPoint) {
    this.maxWidth = Math.max(aPoint.x, 0);
    this.changed();
    return this.updateRendering();
  };

  TextMorph.prototype.columnRow = function(slot) {
    var col, idx, row, _i, _j, _ref, _ref1;
    idx = 0;
    for (row = _i = 0, _ref = this.lines.length; 0 <= _ref ? _i < _ref : _i > _ref; row = 0 <= _ref ? ++_i : --_i) {
      idx = this.lineSlots[row];
      for (col = _j = 0, _ref1 = this.lines[row].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
        if (idx === slot) {
          return new Point(col, row);
        }
        idx += 1;
      }
    }
    return new Point(this.lines[this.lines.length - 1].length - 1, this.lines.length - 1);
  };

  TextMorph.prototype.slotPosition = function(slot) {
    var colRow, context, idx, shadowHeight, x, xOffset, y, yOffset, _i, _ref;
    colRow = this.columnRow(slot);
    context = this.image.getContext("2d");
    shadowHeight = Math.abs(this.shadowOffset.y);
    xOffset = 0;
    yOffset = colRow.y * (fontHeight(this.fontSize) + shadowHeight);
    for (idx = _i = 0, _ref = colRow.x; 0 <= _ref ? _i < _ref : _i > _ref; idx = 0 <= _ref ? ++_i : --_i) {
      xOffset += context.measureText(this.lines[colRow.y][idx]).width;
    }
    x = this.left() + xOffset;
    y = this.top() + yOffset;
    return new Point(x, y);
  };

  TextMorph.prototype.slotAt = function(aPoint) {
    var charX, col, context, row, shadowHeight;
    charX = 0;
    row = 0;
    col = 0;
    shadowHeight = Math.abs(this.shadowOffset.y);
    context = this.image.getContext("2d");
    while (aPoint.y - this.top() > ((fontHeight(this.fontSize) + shadowHeight) * row)) {
      row += 1;
    }
    row = Math.max(row, 1);
    while (aPoint.x - this.left() > charX) {
      charX += context.measureText(this.lines[row - 1][col]).width;
      col += 1;
    }
    return this.lineSlots[Math.max(row - 1, 0)] + col - 1;
  };

  TextMorph.prototype.upFrom = function(slot) {
    var above, colRow;
    colRow = this.columnRow(slot);
    if (colRow.y < 1) {
      return slot;
    }
    above = this.lines[colRow.y - 1];
    if (above.length < colRow.x - 1) {
      return this.lineSlots[colRow.y - 1] + above.length;
    }
    return this.lineSlots[colRow.y - 1] + colRow.x;
  };

  TextMorph.prototype.downFrom = function(slot) {
    var below, colRow;
    colRow = this.columnRow(slot);
    if (colRow.y > this.lines.length - 2) {
      return slot;
    }
    below = this.lines[colRow.y + 1];
    if (below.length < colRow.x - 1) {
      return this.lineSlots[colRow.y + 1] + below.length;
    }
    return this.lineSlots[colRow.y + 1] + colRow.x;
  };

  TextMorph.prototype.startOfLine = function(slot) {
    return this.lineSlots[this.columnRow(slot).y];
  };

  TextMorph.prototype.endOfLine = function(slot) {
    return this.startOfLine(slot) + this.lines[this.columnRow(slot).y].length - 1;
  };

  TextMorph.prototype.developersMenu = function() {
    var menu;
    menu = TextMorph.__super__.developersMenu.call(this);
    menu.addLine();
    menu.addItem("edit", "edit");
    menu.addItem("font size...", (function() {
      return this.prompt(menu.title + "\nfont\nsize:", this.setFontSize, this, this.fontSize.toString(), null, 6, 100, true);
    }), "set this Text's\nfont point size");
    if (this.alignment !== "left") {
      menu.addItem("align left", "setAlignmentToLeft");
    }
    if (this.alignment !== "right") {
      menu.addItem("align right", "setAlignmentToRight");
    }
    if (this.alignment !== "center") {
      menu.addItem("align center", "setAlignmentToCenter");
    }
    menu.addLine();
    if (this.fontStyle !== "serif") {
      menu.addItem("serif", "setSerif");
    }
    if (this.fontStyle !== "sans-serif") {
      menu.addItem("sans-serif", "setSansSerif");
    }
    if (this.isBold) {
      menu.addItem("normal weight", "toggleWeight");
    } else {
      menu.addItem("bold", "toggleWeight");
    }
    if (this.isItalic) {
      menu.addItem("normal style", "toggleItalic");
    } else {
      menu.addItem("italic", "toggleItalic");
    }
    return menu;
  };

  TextMorph.prototype.setAlignmentToLeft = function() {
    this.alignment = "left";
    this.updateRendering();
    return this.changed();
  };

  TextMorph.prototype.setAlignmentToRight = function() {
    this.alignment = "right";
    this.updateRendering();
    return this.changed();
  };

  TextMorph.prototype.setAlignmentToCenter = function() {
    this.alignment = "center";
    this.updateRendering();
    return this.changed();
  };

  TextMorph.prototype.evaluationMenu = function() {
    var menu;
    menu = new MenuMorph(this, null);
    menu.addItem("do it", "doIt", "evaluate the\nselected expression");
    menu.addItem("show it", "showIt", "evaluate the\nselected expression\nand show the result");
    menu.addItem("inspect it", "inspectIt", "evaluate the\nselected expression\nand inspect the result");
    menu.addLine();
    menu.addItem("select all", "selectAllAndEdit");
    return menu;
  };

  TextMorph.prototype.selectAllAndEdit = function() {
    this.edit();
    return this.selectAll();
  };

  TextMorph.prototype.setReceiver = function(obj) {
    this.receiver = obj;
    return this.customContextMenu = this.evaluationMenu();
  };

  TextMorph.prototype.doIt = function() {
    this.receiver.evaluateString(this.selection());
    return this.edit();
  };

  TextMorph.prototype.showIt = function() {
    var result;
    result = this.receiver.evaluateString(this.selection());
    if (result != null) {
      return this.inform(result);
    }
  };

  TextMorph.prototype.inspectIt = function() {
    var inspector, result, world;
    result = this.receiver.evaluateString(this.selection());
    world = this.world();
    if (result != null) {
      inspector = new InspectorMorph(result);
      inspector.setPosition(world.hand.position());
      inspector.keepWithin(world);
      world.add(inspector);
      return inspector.changed();
    }
  };

  return TextMorph;

})(StringMorph);

WorldMorph = (function(_super) {

  __extends(WorldMorph, _super);

  WorldMorph.MorphicPreferences = standardSettings;

  WorldMorph.currentTime = null;

  WorldMorph.showRedraws = false;

  WorldMorph.prototype.systemTestsRecorderAndPlayer = null;

  function WorldMorph(aCanvas, fillPage) {
    WorldMorph.__super__.constructor.call(this);
    this.color = new Color(205, 205, 205);
    this.alpha = 1;
    this.bounds = new Rectangle(0, 0, aCanvas.width, aCanvas.height);
    this.updateRendering();
    this.isVisible = true;
    this.isDraggable = false;
    this.currentKey = null;
    this.worldCanvas = aCanvas;
    this.useFillPage = fillPage;
    if (this.useFillPage === undefined) {
      this.useFillPage = true;
    }
    this.isDevMode = false;
    this.broken = [];
    this.hand = new HandMorph(this);
    this.keyboardReceiver = null;
    this.lastEditedText = null;
    this.caret = null;
    this.activeMenu = null;
    this.activeHandle = null;
    this.virtualKeyboard = null;
    this.initEventListeners();
    this.systemTestsRecorderAndPlayer = new SystemTestsRecorderAndPlayer(this, this.hand);
  }

  WorldMorph.prototype.brokenFor = function(aMorph) {
    var fb;
    fb = aMorph.boundsIncludingChildren();
    return this.broken.filter(function(rect) {
      return rect.intersects(fb);
    });
  };

  WorldMorph.prototype.recursivelyBlit = function(aCanvas, aRect) {
    WorldMorph.__super__.recursivelyBlit.call(this, aCanvas, aRect);
    return this.hand.recursivelyBlit(aCanvas, aRect);
  };

  WorldMorph.prototype.updateBroken = function() {
    var _this = this;
    this.broken.forEach(function(rect) {
      if (rect.isNotEmpty()) {
        return _this.recursivelyBlit(_this.worldCanvas, rect);
      }
    });
    return this.broken = [];
  };

  WorldMorph.prototype.doOneCycle = function() {
    WorldMorph.currentTime = Date.now();
    this.runChildrensStepFunction();
    return this.updateBroken();
  };

  WorldMorph.prototype.fillPage = function() {
    var clientHeight, clientWidth, pos,
      _this = this;
    pos = getDocumentPositionOf(this.worldCanvas);
    clientHeight = window.innerHeight;
    clientWidth = window.innerWidth;
    if (pos.x > 0) {
      this.worldCanvas.style.position = "absolute";
      this.worldCanvas.style.left = "0px";
      pos.x = 0;
    }
    if (pos.y > 0) {
      this.worldCanvas.style.position = "absolute";
      this.worldCanvas.style.top = "0px";
      pos.y = 0;
    }
    if (document.body.scrollTop) {
      clientHeight = document.documentElement.clientHeight;
    }
    if (document.body.scrollLeft) {
      clientWidth = document.documentElement.clientWidth;
    }
    if (this.worldCanvas.width !== clientWidth) {
      this.worldCanvas.width = clientWidth;
      this.setWidth(clientWidth);
    }
    if (this.worldCanvas.height !== clientHeight) {
      this.worldCanvas.height = clientHeight;
      this.setHeight(clientHeight);
    }
    return this.children.forEach(function(child) {
      if (child.reactToWorldResize) {
        return child.reactToWorldResize(_this.bounds.copy());
      }
    });
  };

  WorldMorph.prototype.getGlobalPixelColor = function(point) {
    var dta;
    dta = this.worldCanvas.getContext("2d").getImageData(point.x, point.y, 1, 1).data;
    return new Color(dta[0], dta[1], dta[2]);
  };

  WorldMorph.prototype.initVirtualKeyboard = function() {
    var _this = this;
    if (this.virtualKeyboard) {
      document.body.removeChild(this.virtualKeyboard);
      this.virtualKeyboard = null;
    }
    if (!WorldMorph.MorphicPreferences.useVirtualKeyboard) {
      return;
    }
    this.virtualKeyboard = document.createElement("input");
    this.virtualKeyboard.type = "text";
    this.virtualKeyboard.style.color = "transparent";
    this.virtualKeyboard.style.backgroundColor = "transparent";
    this.virtualKeyboard.style.border = "none";
    this.virtualKeyboard.style.outline = "none";
    this.virtualKeyboard.style.position = "absolute";
    this.virtualKeyboard.style.top = "0px";
    this.virtualKeyboard.style.left = "0px";
    this.virtualKeyboard.style.width = "0px";
    this.virtualKeyboard.style.height = "0px";
    document.body.appendChild(this.virtualKeyboard);
    this.virtualKeyboard.addEventListener("keydown", (function(event) {
      _this.currentKey = event.keyCode;
      if (_this.keyboardReceiver) {
        _this.keyboardReceiver.processKeyDown(event);
      }
      if (event.keyIdentifier === "U+0008" || event.keyIdentifier === "Backspace") {
        event.preventDefault();
      }
      if (event.keyIdentifier === "U+0009" || event.keyIdentifier === "Tab") {
        if (_this.keyboardReceiver) {
          _this.keyboardReceiver.processKeyPress(event);
        }
        return event.preventDefault();
      }
    }), false);
    this.virtualKeyboard.addEventListener("keyup", (function(event) {
      _this.currentKey = null;
      if (_this.keyboardReceiver) {
        if (_this.keyboardReceiver.processKeyUp) {
          _this.keyboardReceiver.processKeyUp(event);
        }
      }
      return event.preventDefault();
    }), false);
    return this.virtualKeyboard.addEventListener("keypress", (function(event) {
      if (_this.keyboardReceiver) {
        _this.keyboardReceiver.processKeyPress(event);
      }
      return event.preventDefault();
    }), false);
  };

  WorldMorph.prototype.initEventListeners = function() {
    var canvas,
      _this = this;
    canvas = this.worldCanvas;
    if (this.useFillPage) {
      this.fillPage();
    } else {
      this.changed();
    }
    canvas.addEventListener("mousedown", (function(event) {
      return _this.hand.processMouseDown(event.button, event.ctrlKey);
    }), false);
    canvas.addEventListener("touchstart", (function(event) {
      return _this.hand.processTouchStart(event);
    }), false);
    canvas.addEventListener("mouseup", (function(event) {
      event.preventDefault();
      return _this.hand.processMouseUp(event);
    }), false);
    canvas.addEventListener("touchend", (function(event) {
      return _this.hand.processTouchEnd(event);
    }), false);
    canvas.addEventListener("mousemove", (function(event) {
      return _this.hand.processMouseMove(event.pageX, event.pageY);
    }), false);
    canvas.addEventListener("touchmove", (function(event) {
      return _this.hand.processTouchMove(event);
    }), false);
    canvas.addEventListener("contextmenu", (function(event) {
      return event.preventDefault();
    }), false);
    canvas.addEventListener("keydown", (function(event) {
      _this.currentKey = event.keyCode;
      if (_this.keyboardReceiver) {
        _this.keyboardReceiver.processKeyDown(event);
      }
      if (event.keyIdentifier === "U+0008" || event.keyIdentifier === "Backspace") {
        event.preventDefault();
      }
      if (event.keyIdentifier === "U+0009" || event.keyIdentifier === "Tab") {
        if (_this.keyboardReceiver) {
          _this.keyboardReceiver.processKeyPress(event);
        }
        return event.preventDefault();
      }
    }), false);
    canvas.addEventListener("keyup", (function(event) {
      _this.currentKey = null;
      if (_this.keyboardReceiver) {
        if (_this.keyboardReceiver.processKeyUp) {
          _this.keyboardReceiver.processKeyUp(event);
        }
      }
      return event.preventDefault();
    }), false);
    canvas.addEventListener("keypress", (function(event) {
      if (_this.keyboardReceiver) {
        _this.keyboardReceiver.processKeyPress(event);
      }
      return event.preventDefault();
    }), false);
    canvas.addEventListener("mousewheel", (function(event) {
      _this.hand.processMouseScroll(event);
      return event.preventDefault();
    }), false);
    canvas.addEventListener("DOMMouseScroll", (function(event) {
      _this.hand.processMouseScroll(event);
      return event.preventDefault();
    }), false);
    document.body.addEventListener("copy", (function(event) {
      var selectedText, setStatus;
      if (_this.caret) {
        selectedText = _this.caret.target.selection();
        if (event.clipboardData) {
          event.preventDefault();
          setStatus = event.clipboardData.setData("text/plain", selectedText);
        }
        if (window.clipboardData) {
          event.returnValue = false;
          return setStatus = window.clipboardData.setData("Text", selectedText);
        }
      }
    }), false);
    document.body.addEventListener("paste", (function(event) {
      var text;
      if (_this.caret) {
        if (event.clipboardData) {
          text = event.clipboardData.getData("text/plain");
        }
        if (window.clipboardData) {
          text = window.clipboardData.getData("Text");
        }
        return window.setTimeout((function() {
          return _this.caret.insert(text);
        }), 50, true);
      }
    }), false);
    console.log("binding wit mousetrap");
    Mousetrap.bind(["command+k", "ctrl+k"], function(e) {
      _this.systemTestsRecorderAndPlayer.takeScreenshot();
      return false;
    });
    window.addEventListener("dragover", (function(event) {
      return event.preventDefault();
    }), false);
    window.addEventListener("drop", (function(event) {
      _this.hand.processDrop(event);
      return event.preventDefault();
    }), false);
    window.addEventListener("resize", (function() {
      if (_this.useFillPage) {
        return _this.fillPage();
      }
    }), false);
    return window.onbeforeunload = function(evt) {
      var e, msg;
      e = evt || window.event;
      msg = "Are you sure you want to leave?";
      if (e) {
        e.returnValue = msg;
      }
      return msg;
    };
  };

  WorldMorph.prototype.mouseDownLeft = function() {
    return noOperation;
  };

  WorldMorph.prototype.mouseClickLeft = function() {
    return noOperation;
  };

  WorldMorph.prototype.mouseDownRight = function() {
    return noOperation;
  };

  WorldMorph.prototype.mouseClickRight = function() {
    return noOperation;
  };

  WorldMorph.prototype.wantsDropOf = function() {
    return this.acceptsDrops;
  };

  WorldMorph.prototype.droppedImage = function() {
    return null;
  };

  WorldMorph.prototype.droppedSVG = function() {
    return null;
  };

  WorldMorph.prototype.nextTab = function(editField) {
    var next;
    next = this.nextEntryField(editField);
    if (next) {
      editField.clearSelection();
      next.selectAll();
      return next.edit();
    }
  };

  WorldMorph.prototype.previousTab = function(editField) {
    var prev;
    prev = this.previousEntryField(editField);
    if (prev) {
      editField.clearSelection();
      prev.selectAll();
      return prev.edit();
    }
  };

  WorldMorph.prototype.testsList = function() {
    console.log(Object.keys(window));
    return (Object.keys(window)).filter(function(i) {
      console.log(i.indexOf("SystemTest_"));
      return i.indexOf("SystemTest_") === 0;
    });
  };

  WorldMorph.prototype.runSystemTests = function() {
    var i, _i, _len, _ref, _results;
    console.log(this.testsList());
    _ref = this.testsList();
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      console.log(window[i]);
      this.systemTestsRecorderAndPlayer.eventQueue = window[i].testData;
      this.changed();
      this.destroyAll();
      _results.push(this.systemTestsRecorderAndPlayer.startPlaying());
    }
    return _results;
  };

  WorldMorph.prototype.contextMenu = function() {
    var menu;
    if (this.isDevMode) {
      menu = new MenuMorph(this, this.constructor.name || this.constructor.toString().split(" ")[1].split("(")[0]);
    } else {
      menu = new MenuMorph(this, "Morphic");
    }
    if (this.isDevMode) {
      menu.addItem("demo...", "userCreateMorph", "sample morphs");
      menu.addLine();
      menu.addItem("hide all...", "hideAll");
      menu.addItem("delete all...", "destroyAll");
      menu.addItem("show all...", "showAllHiddens");
      menu.addItem("move all inside...", "keepAllSubmorphsWithin", "keep all submorphs\nwithin and visible");
      menu.addItem("inspect...", "inspect", "open a window on\nall properties");
      menu.addLine();
      menu.addItem("restore display", "changed", "redraw the\nscreen once");
      menu.addItem("fill page...", "fillPage", "let the World automatically\nadjust to browser resizings");
      if (useBlurredShadows) {
        menu.addItem("sharp shadows...", "toggleBlurredShadows", "sharp drop shadows\nuse for old browsers");
      } else {
        menu.addItem("blurred shadows...", "toggleBlurredShadows", "blurry shades,\n use for new browsers");
      }
      menu.addItem("color...", (function() {
        return this.pickColor(menu.title + "\ncolor:", this.setColor, this, this.color);
      }), "choose the World's\nbackground color");
      if (WorldMorph.MorphicPreferences === standardSettings) {
        menu.addItem("touch screen settings", "togglePreferences", "bigger menu fonts\nand sliders");
      } else {
        menu.addItem("standard settings", "togglePreferences", "smaller menu fonts\nand sliders");
      }
      menu.addLine();
    }
    menu.addItem("run system tests", "runSystemTests", "runs all the system tests");
    menu.addLine();
    if (this.isDevMode) {
      menu.addItem("user mode...", "toggleDevMode", "disable developers'\ncontext menus");
    } else {
      menu.addItem("development mode...", "toggleDevMode");
    }
    menu.addItem("about morphic.js...", "about");
    return menu;
  };

  WorldMorph.prototype.userCreateMorph = function() {
    var create, menu,
      _this = this;
    create = function(aMorph) {
      aMorph.isDraggable = true;
      return aMorph.pickUp(_this);
    };
    menu = new MenuMorph(this, "make a morph");
    menu.addItem("rectangle", function() {
      return create(new Morph());
    });
    menu.addItem("box", function() {
      return create(new BoxMorph());
    });
    menu.addItem("circle box", function() {
      return create(new CircleBoxMorph());
    });
    menu.addLine();
    menu.addItem("slider", function() {
      return create(new SliderMorph());
    });
    menu.addItem("frame", function() {
      var newMorph;
      newMorph = new FrameMorph();
      newMorph.setExtent(new Point(350, 250));
      return create(newMorph);
    });
    menu.addItem("scroll frame", function() {
      var newMorph;
      newMorph = new ScrollFrameMorph();
      newMorph.contents.acceptsDrops = true;
      newMorph.contents.adjustBounds();
      newMorph.setExtent(new Point(350, 250));
      return create(newMorph);
    });
    menu.addItem("handle", function() {
      return create(new HandleMorph());
    });
    menu.addLine();
    menu.addItem("string", function() {
      var newMorph;
      newMorph = new StringMorph("Hello, World!");
      newMorph.isEditable = true;
      return create(newMorph);
    });
    menu.addItem("text", function() {
      var newMorph;
      newMorph = new TextMorph("Ich weiß nicht, was soll es bedeuten, dass ich so " + "traurig bin, ein Märchen aus uralten Zeiten, das " + "kommt mir nicht aus dem Sinn. Die Luft ist kühl " + "und es dunkelt, und ruhig fließt der Rhein; der " + "Gipfel des Berges funkelt im Abendsonnenschein. " + "Die schönste Jungfrau sitzet dort oben wunderbar, " + "ihr gold'nes Geschmeide blitzet, sie kämmt ihr " + "goldenes Haar, sie kämmt es mit goldenem Kamme, " + "und singt ein Lied dabei; das hat eine wundersame, " + "gewalt'ge Melodei. Den Schiffer im kleinen " + "Schiffe, ergreift es mit wildem Weh; er schaut " + "nicht die Felsenriffe, er schaut nur hinauf in " + "die Höh'. Ich glaube, die Wellen verschlingen " + "am Ende Schiffer und Kahn, und das hat mit ihrem " + "Singen, die Loreley getan.");
      newMorph.isEditable = true;
      newMorph.maxWidth = 300;
      newMorph.updateRendering();
      return create(newMorph);
    });
    menu.addItem("speech bubble", function() {
      var newMorph;
      newMorph = new SpeechBubbleMorph("Hello, World!");
      return create(newMorph);
    });
    menu.addLine();
    menu.addItem("gray scale palette", function() {
      return create(new GrayPaletteMorph());
    });
    menu.addItem("color palette", function() {
      return create(new ColorPaletteMorph());
    });
    menu.addItem("color picker", function() {
      return create(new ColorPickerMorph());
    });
    menu.addLine();
    menu.addItem("sensor demo", function() {
      var newMorph;
      newMorph = new MouseSensorMorph();
      newMorph.setColor(new Color(230, 200, 100));
      newMorph.edge = 35;
      newMorph.border = 15;
      newMorph.borderColor = new Color(200, 100, 50);
      newMorph.alpha = 0.2;
      newMorph.setExtent(new Point(100, 100));
      return create(newMorph);
    });
    menu.addItem("animation demo", function() {
      var bar, baz, foo, fred, garply;
      foo = new BouncerMorph();
      foo.setPosition(new Point(50, 20));
      foo.setExtent(new Point(300, 200));
      foo.alpha = 0.9;
      foo.speed = 3;
      bar = new BouncerMorph();
      bar.setColor(new Color(50, 50, 50));
      bar.setPosition(new Point(80, 80));
      bar.setExtent(new Point(80, 250));
      bar.type = "horizontal";
      bar.direction = "right";
      bar.alpha = 0.9;
      bar.speed = 5;
      baz = new BouncerMorph();
      baz.setColor(new Color(20, 20, 20));
      baz.setPosition(new Point(90, 140));
      baz.setExtent(new Point(40, 30));
      baz.type = "horizontal";
      baz.direction = "right";
      baz.speed = 3;
      garply = new BouncerMorph();
      garply.setColor(new Color(200, 20, 20));
      garply.setPosition(new Point(90, 140));
      garply.setExtent(new Point(20, 20));
      garply.type = "vertical";
      garply.direction = "up";
      garply.speed = 8;
      fred = new BouncerMorph();
      fred.setColor(new Color(20, 200, 20));
      fred.setPosition(new Point(120, 140));
      fred.setExtent(new Point(20, 20));
      fred.type = "vertical";
      fred.direction = "down";
      fred.speed = 4;
      bar.add(garply);
      bar.add(baz);
      foo.add(fred);
      foo.add(bar);
      return create(foo);
    });
    menu.addItem("pen", function() {
      return create(new PenMorph());
    });
    menu.addLine();
    menu.addItem("view all...", function() {
      var newMorph;
      newMorph = new MorphsListMorph();
      return create(newMorph);
    });
    if (this.customMorphs) {
      menu.addLine();
      this.customMorphs().forEach(function(morph) {
        return menu.addItem(morph.toString(), function() {
          return create(morph);
        });
      });
    }
    return menu.popUpAtHand(this);
  };

  WorldMorph.prototype.toggleDevMode = function() {
    return this.isDevMode = !this.isDevMode;
  };

  WorldMorph.prototype.hideAll = function() {
    return this.children.forEach(function(child) {
      return child.hide();
    });
  };

  WorldMorph.prototype.showAllHiddens = function() {
    return this.forAllChildren(function(child) {
      if (!child.isVisible) {
        return child.show();
      }
    });
  };

  WorldMorph.prototype.about = function() {
    var module, versions;
    versions = "";
    for (module in modules) {
      if (modules.hasOwnProperty(module)) {
        versions += "\n" + module + " (" + modules[module] + ")";
      }
    }
    if (versions !== "") {
      versions = "\n\nmodules:\n\n" + "morphic (" + morphicVersion + ")" + versions;
    }
    return this.inform("morphic.js\n\n" + "a lively Web GUI\ninspired by Squeak\n" + morphicVersion + "\n\original from Jens Mönig's (jens@moenig.org) morphic.js\n" + "\n\nported and extended by Davide Della Casa\n" + versions);
  };

  WorldMorph.prototype.edit = function(aStringOrTextMorph) {
    var pos;
    pos = getDocumentPositionOf(this.worldCanvas);
    if (!aStringOrTextMorph.isEditable) {
      return null;
    }
    if (this.caret) {
      this.caret.destroy();
    }
    if (this.lastEditedText) {
      this.lastEditedText.clearSelection();
    }
    this.caret = new CaretMorph(aStringOrTextMorph);
    aStringOrTextMorph.parent.add(this.caret);
    this.keyboardReceiver = this.caret;
    this.initVirtualKeyboard();
    if (WorldMorph.MorphicPreferences.useVirtualKeyboard) {
      this.virtualKeyboard.style.top = this.caret.top() + pos.y + "px";
      this.virtualKeyboard.style.left = this.caret.left() + pos.x + "px";
      this.virtualKeyboard.focus();
    }
    if (WorldMorph.MorphicPreferences.useSliderForInput) {
      if (!aStringOrTextMorph.parentThatIsA(MenuMorph)) {
        return this.slide(aStringOrTextMorph);
      }
    }
  };

  WorldMorph.prototype.slide = function(aStringOrTextMorph) {
    var menu, slider, val;
    val = parseFloat(aStringOrTextMorph.text);
    if (isNaN(val)) {
      val = 0;
    }
    menu = new MenuMorph();
    slider = new SliderMorph(val - 25, val + 25, val, 10, "horizontal");
    slider.alpha = 1;
    slider.color = new Color(225, 225, 225);
    slider.button.color = menu.borderColor;
    slider.button.highlightColor = slider.button.color.copy();
    slider.button.highlightColor.b += 100;
    slider.button.pressColor = slider.button.color.copy();
    slider.button.pressColor.b += 150;
    slider.silentSetHeight(WorldMorph.MorphicPreferences.scrollBarSize);
    slider.silentSetWidth(WorldMorph.MorphicPreferences.menuFontSize * 10);
    slider.updateRendering();
    slider.action = function(num) {
      aStringOrTextMorph.changed();
      aStringOrTextMorph.text = Math.round(num).toString();
      aStringOrTextMorph.updateRendering();
      aStringOrTextMorph.changed();
      return aStringOrTextMorph.escalateEvent('reactToSliderEdit', aStringOrTextMorph);
    };
    menu.items.push(slider);
    return menu.popup(this, aStringOrTextMorph.bottomLeft().add(new Point(0, 5)));
  };

  WorldMorph.prototype.stopEditing = function() {
    if (this.caret) {
      this.lastEditedText = this.caret.target;
      this.caret.destroy();
      this.caret = null;
      this.lastEditedText.escalateEvent("reactToEdit", this.lastEditedText);
    }
    this.keyboardReceiver = null;
    if (this.virtualKeyboard) {
      this.virtualKeyboard.blur();
      document.body.removeChild(this.virtualKeyboard);
      this.virtualKeyboard = null;
    }
    return this.worldCanvas.focus();
  };

  WorldMorph.prototype.toggleBlurredShadows = function() {
    return useBlurredShadows = !useBlurredShadows;
  };

  WorldMorph.prototype.togglePreferences = function() {
    if (WorldMorph.MorphicPreferences === standardSettings) {
      return WorldMorph.MorphicPreferences = touchScreenSettings;
    } else {
      return WorldMorph.MorphicPreferences = standardSettings;
    }
  };

  return WorldMorph;

})(FrameMorph);

BlinkerMorph = (function(_super) {

  __extends(BlinkerMorph, _super);

  function BlinkerMorph(fps) {
    this.fps = fps != null ? fps : 2;
    BlinkerMorph.__super__.constructor.call(this);
    this.color = new Color(0, 0, 0);
    this.updateRendering();
  }

  BlinkerMorph.prototype.step = function() {
    return this.toggleVisibility();
  };

  return BlinkerMorph;

})(Morph);

HandMorph = (function(_super) {

  __extends(HandMorph, _super);

  HandMorph.prototype.world = null;

  HandMorph.prototype.mouseButton = null;

  HandMorph.prototype.mouseDownMorph = null;

  HandMorph.prototype.morphToGrab = null;

  HandMorph.prototype.grabOrigin = null;

  HandMorph.prototype.mouseOverList = null;

  HandMorph.prototype.temporaries = null;

  HandMorph.prototype.touchHoldTimeout = null;

  function HandMorph(world) {
    this.world = world;
    this.mouseOverList = [];
    this.temporaries = [];
    HandMorph.__super__.constructor.call(this);
    this.bounds = new Rectangle();
  }

  HandMorph.prototype.changed = function() {
    var b;
    if (this.world !== null) {
      b = this.boundsIncludingChildren();
      if (!b.extent().eq(new Point())) {
        return this.world.broken.push(this.boundsIncludingChildren().spread());
      }
    }
  };

  HandMorph.prototype.morphAtPointer = function() {
    var morphs, result,
      _this = this;
    morphs = this.world.allChildren().slice(0).reverse();
    result = null;
    morphs.forEach(function(m) {
      if (m.visibleBounds().containsPoint(_this.bounds.origin) && result === null && m.isVisible && (m.noticesTransparentClick || (!m.isTransparentAt(_this.bounds.origin))) && (!(m instanceof ShadowMorph))) {
        return result = m;
      }
    });
    if (result !== null) {
      return result;
    }
    return this.world;
  };

  HandMorph.prototype.allMorphsAtPointer = function() {
    var morphs,
      _this = this;
    morphs = this.world.allChildren();
    return morphs.filter(function(m) {
      return m.isVisible && m.visibleBounds().containsPoint(_this.bounds.origin);
    });
  };

  HandMorph.prototype.dropTargetFor = function(aMorph) {
    var target;
    target = this.morphAtPointer();
    while (!target.wantsDropOf(aMorph)) {
      target = target.parent;
    }
    return target;
  };

  HandMorph.prototype.grab = function(aMorph) {
    var oldParent;
    oldParent = aMorph.parent;
    if (aMorph instanceof WorldMorph) {
      return null;
    }
    if (!this.children.length) {
      this.world.stopEditing();
      this.grabOrigin = aMorph.situation();
      aMorph.addShadow();
      if (aMorph.prepareToBeGrabbed) {
        aMorph.prepareToBeGrabbed(this);
      }
      this.add(aMorph);
      this.changed();
      if (oldParent && oldParent.reactToGrabOf) {
        return oldParent.reactToGrabOf(aMorph);
      }
    }
  };

  HandMorph.prototype.drop = function() {
    var morphToDrop, target;
    if (this.children.length) {
      morphToDrop = this.children[0];
      target = this.dropTargetFor(morphToDrop);
      this.changed();
      target.add(morphToDrop);
      morphToDrop.changed();
      morphToDrop.removeShadow();
      this.children = [];
      this.setExtent(new Point());
      if (morphToDrop.justDropped) {
        morphToDrop.justDropped(this);
      }
      if (target.reactToDropOf) {
        target.reactToDropOf(morphToDrop, this);
      }
      return this.dragOrigin = null;
    }
  };

  HandMorph.prototype.processMouseDown = function(button, ctrlKey) {
    var actualClick, expectedClick, morph;
    this.world.systemTestsRecorderAndPlayer.addMouseDownEvent(button, ctrlKey);
    this.destroyTemporaries();
    this.morphToGrab = null;
    if (this.children.length) {
      this.drop();
      return this.mouseButton = null;
    } else {
      morph = this.morphAtPointer();
      if (this.world.activeMenu) {
        if (!contains(morph.allParents(), this.world.activeMenu)) {
          this.world.activeMenu.destroy();
        } else {
          clearInterval(this.touchHoldTimeout);
        }
      }
      if (this.world.activeHandle) {
        if (morph !== this.world.activeHandle) {
          this.world.activeHandle.destroy();
        }
      }
      if (this.world.cursor) {
        if (morph !== this.world.cursor.target) {
          this.world.stopEditing();
        }
      }
      if (!morph.mouseMove) {
        this.morphToGrab = morph.rootForGrab();
      }
      if (button === 2 || ctrlKey) {
        this.mouseButton = "right";
        actualClick = "mouseDownRight";
        expectedClick = "mouseClickRight";
      } else {
        this.mouseButton = "left";
        actualClick = "mouseDownLeft";
        expectedClick = "mouseClickLeft";
      }
      this.mouseDownMorph = morph;
      while (!this.mouseDownMorph[expectedClick]) {
        this.mouseDownMorph = this.mouseDownMorph.parent;
      }
      while (!morph[actualClick]) {
        morph = morph.parent;
      }
      return morph[actualClick](this.bounds.origin);
    }
  };

  HandMorph.prototype.processTouchStart = function(event) {
    var _this = this;
    clearInterval(this.touchHoldTimeout);
    if (event.touches.length === 1) {
      this.touchHoldTimeout = setInterval(function() {
        _this.processMouseDown({
          button: 2
        });
        _this.processMouseUp({
          button: 2
        });
        event.preventDefault();
        return clearInterval(_this.touchHoldTimeout);
      }, 400);
      this.processMouseMove(event.touches[0]);
      this.processMouseDown({
        button: 0
      });
      return event.preventDefault();
    }
  };

  HandMorph.prototype.processTouchMove = function(event) {
    var touch;
    if (event.touches.length === 1) {
      touch = event.touches[0];
      this.processMouseMove(touch);
      return clearInterval(this.touchHoldTimeout);
    }
  };

  HandMorph.prototype.processTouchEnd = function(event) {
    clearInterval(this.touchHoldTimeout);
    return this.processMouseUp({
      button: 0
    });
  };

  HandMorph.prototype.processMouseUp = function() {
    var context, contextMenu, expectedClick, morph;
    this.world.systemTestsRecorderAndPlayer.addMouseUpEvent();
    morph = this.morphAtPointer();
    this.destroyTemporaries();
    if (this.children.length) {
      this.drop();
    } else {
      if (this.mouseButton === "left") {
        expectedClick = "mouseClickLeft";
      } else {
        expectedClick = "mouseClickRight";
        if (this.mouseButton) {
          context = morph;
          contextMenu = context.contextMenu();
          while ((!contextMenu) && context.parent) {
            context = context.parent;
            contextMenu = context.contextMenu();
          }
          if (contextMenu) {
            contextMenu.popUpAtHand(this.world);
          }
        }
      }
      while (!morph[expectedClick]) {
        morph = morph.parent;
      }
      morph[expectedClick](this.bounds.origin);
    }
    return this.mouseButton = null;
  };

  HandMorph.prototype.processMouseScroll = function(event) {
    var morph;
    morph = this.morphAtPointer();
    while (morph && !morph.mouseScroll) {
      morph = morph.parent;
    }
    if (morph) {
      return morph.mouseScroll((event.detail / -3) || (event.hasOwnProperty("wheelDeltaY") ? event.wheelDeltaY / 120 : event.wheelDelta / 120), event.wheelDeltaX / 120 || 0);
    }
  };

  HandMorph.prototype.processDrop = function(event) {
    var file, files, img, parseImgURL, readAudio, readBinary, readImage, readSVG, readText, src, targetDrop, txt, _i, _len, _results;
    files = (event instanceof FileList ? event : event.target.files || event.dataTransfer.files);
    txt = (event.dataTransfer ? event.dataTransfer.getData("Text/HTML") : null);
    targetDrop = this.morphAtPointer();
    img = new Image();
    readSVG = function(aFile) {
      var frd, pic, target;
      pic = new Image();
      frd = new FileReader();
      while (!target.droppedSVG) {
        target = target.parent;
      }
      pic.onload = function() {
        return target.droppedSVG(pic, aFile.name);
      };
      frd = new FileReader();
      frd.onloadend = function(e) {
        return pic.src = e.target.result;
      };
      return frd.readAsDataURL(aFile);
    };
    readImage = function(aFile) {
      var frd, pic;
      pic = new Image();
      frd = new FileReader();
      while (!targetDrop.droppedImage) {
        targetDrop = targetDrop.parent;
      }
      pic.onload = function() {
        var canvas;
        canvas = newCanvas(new Point(pic.width, pic.height));
        canvas.getContext("2d").drawImage(pic, 0, 0);
        return targetDrop.droppedImage(canvas, aFile.name);
      };
      frd = new FileReader();
      frd.onloadend = function(e) {
        return pic.src = e.target.result;
      };
      return frd.readAsDataURL(aFile);
    };
    readAudio = function(aFile) {
      var frd, snd;
      snd = new Audio();
      frd = new FileReader();
      while (!targetDrop.droppedAudio) {
        targetDrop = targetDrop.parent;
      }
      frd.onloadend = function(e) {
        snd.src = e.target.result;
        return targetDrop.droppedAudio(snd, aFile.name);
      };
      return frd.readAsDataURL(aFile);
    };
    readText = function(aFile) {
      var frd;
      frd = new FileReader();
      while (!targetDrop.droppedText) {
        targetDrop = targetDrop.parent;
      }
      frd.onloadend = function(e) {
        return targetDrop.droppedText(e.target.result, aFile.name);
      };
      return frd.readAsText(aFile);
    };
    readBinary = function(aFile) {
      var frd;
      frd = new FileReader();
      while (!targetDrop.droppedBinary) {
        targetDrop = targetDrop.parent;
      }
      frd.onloadend = function(e) {
        return targetDrop.droppedBinary(e.target.result, aFile.name);
      };
      return frd.readAsArrayBuffer(aFile);
    };
    parseImgURL = function(html) {
      var c, i, start, url, _i, _ref;
      url = "";
      start = html.indexOf("<img src=\"");
      if (start === -1) {
        return null;
      }
      start += 10;
      for (i = _i = start, _ref = html.length; start <= _ref ? _i < _ref : _i > _ref; i = start <= _ref ? ++_i : --_i) {
        c = html[i];
        if (c === "\"") {
          return url;
        }
        url = url.concat(c);
      }
      return null;
    };
    if (files.length) {
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        if (file.type.indexOf("svg") !== -1 && !WorldMorph.MorphicPreferences.rasterizeSVGs) {
          _results.push(readSVG(file));
        } else if (file.type.indexOf("image") === 0) {
          _results.push(readImage(file));
        } else if (file.type.indexOf("audio") === 0) {
          _results.push(readAudio(file));
        } else if (file.type.indexOf("text") === 0) {
          _results.push(readText(file));
        } else {
          _results.push(readBinary(file));
        }
      }
      return _results;
    } else if (txt) {
      while (!targetDrop.droppedImage) {
        targetDrop = targetDrop.parent;
      }
      img = new Image();
      img.onload = function() {
        var canvas;
        canvas = newCanvas(new Point(img.width, img.height));
        canvas.getContext("2d").drawImage(img, 0, 0);
        return targetDrop.droppedImage(canvas);
      };
      src = parseImgURL(txt);
      if (src) {
        return img.src = src;
      }
    }
  };

  HandMorph.prototype.destroyTemporaries = function() {
    var _this = this;
    return this.temporaries.forEach(function(morph) {
      if (!(morph.isClickable && morph.bounds.containsPoint(_this.position()))) {
        morph.destroy();
        return _this.temporaries.splice(_this.temporaries.indexOf(morph), 1);
      }
    });
  };

  HandMorph.prototype.moveBy = function(delta) {
    Morph.prototype.trackChanges = false;
    HandMorph.__super__.moveBy.call(this, delta);
    Morph.prototype.trackChanges = true;
    return this.fullChanged();
  };

  HandMorph.prototype.processMouseMove = function(pageX, pageY) {
    var fb, morph, mouseOverNew, pos, posInDocument, topMorph,
      _this = this;
    this.world.systemTestsRecorderAndPlayer.addMouseMoveEvent(pageX, pageY);
    posInDocument = getDocumentPositionOf(this.world.worldCanvas);
    pos = new Point(pageX - posInDocument.x, pageY - posInDocument.y);
    this.setPosition(pos);
    mouseOverNew = this.morphAtPointer().allParents();
    if ((!this.children.length) && (this.mouseButton === "left")) {
      topMorph = this.morphAtPointer();
      morph = topMorph.rootForGrab();
      if (topMorph.mouseMove) {
        topMorph.mouseMove(pos);
      }
      if (this.morphToGrab) {
        if (this.morphToGrab.isDraggable) {
          morph = this.morphToGrab;
          this.grab(morph);
        } else if (this.morphToGrab.isTemplate) {
          morph = this.morphToGrab.fullCopy();
          morph.isTemplate = false;
          morph.isDraggable = true;
          this.grab(morph);
          this.grabOrigin = this.morphToGrab.situation();
        }
        fb = morph.boundsIncludingChildren();
        if (!fb.containsPoint(pos)) {
          this.bounds.origin = fb.center();
          this.grab(morph);
          this.setPosition(pos);
        }
      }
    }
    this.mouseOverList.forEach(function(old) {
      if (!contains(mouseOverNew, old)) {
        if (old.mouseLeave) {
          old.mouseLeave();
        }
        if (old.mouseLeaveDragging && this.mouseButton) {
          return old.mouseLeaveDragging();
        }
      }
    });
    mouseOverNew.forEach(function(newMorph) {
      if (!contains(_this.mouseOverList, newMorph)) {
        if (newMorph.mouseEnter) {
          newMorph.mouseEnter();
        }
        if (newMorph.mouseEnterDragging && _this.mouseButton) {
          newMorph.mouseEnterDragging();
        }
      }
      if (_this.children.length) {
        if (newMorph instanceof ScrollFrameMorph) {
          if (!newMorph.bounds.insetBy(WorldMorph.MorphicPreferences.scrollBarSize * 3).containsPoint(_this.bounds.origin)) {
            return newMorph.startAutoScrolling();
          }
        }
      }
    });
    return this.mouseOverList = mouseOverNew;
  };

  return HandMorph;

})(Morph);

MouseSensorMorph = (function(_super) {

  __extends(MouseSensorMorph, _super);

  function MouseSensorMorph(edge, border, borderColor) {
    MouseSensorMorph.__super__.constructor.apply(this, arguments);
    this.edge = edge || 4;
    this.border = border || 2;
    this.color = new Color(255, 255, 255);
    this.borderColor = borderColor || new Color();
    this.isTouched = false;
    this.upStep = 0.05;
    this.downStep = 0.02;
    this.noticesTransparentClick = false;
    this.updateRendering();
  }

  MouseSensorMorph.prototype.touch = function() {
    var _this = this;
    if (!this.isTouched) {
      this.isTouched = true;
      this.alpha = 0.6;
      return this.step = function() {
        if (_this.isTouched) {
          if (_this.alpha < 1) {
            _this.alpha = _this.alpha + _this.upStep;
          }
        } else if (_this.alpha > _this.downStep) {
          _this.alpha = _this.alpha - _this.downStep;
        } else {
          _this.alpha = 0;
          _this.step = null;
        }
        return _this.changed();
      };
    }
  };

  MouseSensorMorph.prototype.unTouch = function() {
    return this.isTouched = false;
  };

  MouseSensorMorph.prototype.mouseEnter = function() {
    return this.touch();
  };

  MouseSensorMorph.prototype.mouseLeave = function() {
    return this.unTouch();
  };

  MouseSensorMorph.prototype.mouseDownLeft = function() {
    return this.touch();
  };

  MouseSensorMorph.prototype.mouseClickLeft = function() {
    return this.unTouch();
  };

  return MouseSensorMorph;

})(BoxMorph);

Point = (function() {

  Point.prototype.x = null;

  Point.prototype.y = null;

  function Point(x, y) {
    this.x = x != null ? x : 0;
    this.y = y != null ? y : 0;
  }

  Point.prototype.toString = function() {
    return Math.round(this.x.toString()) + "@" + Math.round(this.y.toString());
  };

  Point.prototype.copy = function() {
    return new Point(this.x, this.y);
  };

  Point.prototype.eq = function(aPoint) {
    return this.x === aPoint.x && this.y === aPoint.y;
  };

  Point.prototype.lt = function(aPoint) {
    return this.x < aPoint.x && this.y < aPoint.y;
  };

  Point.prototype.gt = function(aPoint) {
    return this.x > aPoint.x && this.y > aPoint.y;
  };

  Point.prototype.ge = function(aPoint) {
    return this.x >= aPoint.x && this.y >= aPoint.y;
  };

  Point.prototype.le = function(aPoint) {
    return this.x <= aPoint.x && this.y <= aPoint.y;
  };

  Point.prototype.max = function(aPoint) {
    return new Point(Math.max(this.x, aPoint.x), Math.max(this.y, aPoint.y));
  };

  Point.prototype.min = function(aPoint) {
    return new Point(Math.min(this.x, aPoint.x), Math.min(this.y, aPoint.y));
  };

  Point.prototype.round = function() {
    return new Point(Math.round(this.x), Math.round(this.y));
  };

  Point.prototype.abs = function() {
    return new Point(Math.abs(this.x), Math.abs(this.y));
  };

  Point.prototype.neg = function() {
    return new Point(-this.x, -this.y);
  };

  Point.prototype.mirror = function() {
    return new Point(this.y, this.x);
  };

  Point.prototype.floor = function() {
    return new Point(Math.max(Math.floor(this.x), 0), Math.max(Math.floor(this.y), 0));
  };

  Point.prototype.ceil = function() {
    return new Point(Math.ceil(this.x), Math.ceil(this.y));
  };

  Point.prototype.add = function(other) {
    if (other instanceof Point) {
      return new Point(this.x + other.x, this.y + other.y);
    }
    return new Point(this.x + other, this.y + other);
  };

  Point.prototype.subtract = function(other) {
    if (other instanceof Point) {
      return new Point(this.x - other.x, this.y - other.y);
    }
    return new Point(this.x - other, this.y - other);
  };

  Point.prototype.multiplyBy = function(other) {
    if (other instanceof Point) {
      return new Point(this.x * other.x, this.y * other.y);
    }
    return new Point(this.x * other, this.y * other);
  };

  Point.prototype.divideBy = function(other) {
    if (other instanceof Point) {
      return new Point(this.x / other.x, this.y / other.y);
    }
    return new Point(this.x / other, this.y / other);
  };

  Point.prototype.floorDivideBy = function(other) {
    if (other instanceof Point) {
      return new Point(Math.floor(this.x / other.x), Math.floor(this.y / other.y));
    }
    return new Point(Math.floor(this.x / other), Math.floor(this.y / other));
  };

  Point.prototype.r = function() {
    var t;
    t = this.multiplyBy(this);
    return Math.sqrt(t.x + t.y);
  };

  Point.prototype.degrees = function() {
    var tan, theta;
    if (this.x === 0) {
      if (this.y >= 0) {
        return 90;
      }
      return 270;
    }
    tan = this.y / this.x;
    theta = Math.atan(tan);
    if (this.x >= 0) {
      if (this.y >= 0) {
        return degrees(theta);
      }
      return 360 + (degrees(theta));
    }
    return 180 + degrees(theta);
  };

  Point.prototype.theta = function() {
    var tan, theta;
    if (this.x === 0) {
      if (this.y >= 0) {
        return radians(90);
      }
      return radians(270);
    }
    tan = this.y / this.x;
    theta = Math.atan(tan);
    if (this.x >= 0) {
      if (this.y >= 0) {
        return theta;
      }
      return radians(360) + theta;
    }
    return radians(180) + theta;
  };

  Point.prototype.crossProduct = function(aPoint) {
    return this.multiplyBy(aPoint.mirror());
  };

  Point.prototype.distanceTo = function(aPoint) {
    return (aPoint.subtract(this)).r();
  };

  Point.prototype.rotate = function(direction, center) {
    var offset;
    offset = this.subtract(center);
    if (direction === "right") {
      return new Point(-offset.y, offset.y).add(center);
    }
    if (direction === "left") {
      return new Point(offset.y, -offset.y).add(center);
    }
    return center.subtract(offset);
  };

  Point.prototype.flip = function(direction, center) {
    if (direction === "vertical") {
      return new Point(this.x, center.y * 2 - this.y);
    }
    return new Point(center.x * 2 - this.x, this.y);
  };

  Point.prototype.distanceAngle = function(dist, angle) {
    var deg, x, y;
    deg = angle;
    if (deg > 270) {
      deg = deg - 360;
    } else {
      if (deg < -270) {
        deg = deg + 360;
      }
    }
    if (-90 <= deg && deg <= 90) {
      x = Math.sin(radians(deg)) * dist;
      y = Math.sqrt((dist * dist) - (x * x));
      return new Point(x + this.x, this.y - y);
    }
    x = Math.sin(radians(180 - deg)) * dist;
    y = Math.sqrt((dist * dist) - (x * x));
    return new Point(x + this.x, this.y + y);
  };

  Point.prototype.scaleBy = function(scalePoint) {
    return this.multiplyBy(scalePoint);
  };

  Point.prototype.translateBy = function(deltaPoint) {
    return this.add(deltaPoint);
  };

  Point.prototype.rotateBy = function(angle, centerPoint) {
    var center, p, r, theta;
    center = centerPoint || new Point(0, 0);
    p = this.subtract(center);
    r = p.r();
    theta = angle - p.theta();
    return new Point(center.x + (r * Math.cos(theta)), center.y - (r * Math.sin(theta)));
  };

  Point.prototype.asArray = function() {
    return [this.x, this.y];
  };

  Point.prototype.corner = function(cornerPoint) {
    return new Rectangle(this.x, this.y, cornerPoint.x, cornerPoint.y);
  };

  Point.prototype.rectangle = function(aPoint) {
    var crn, org;
    org = this.min(aPoint);
    crn = this.max(aPoint);
    return new Rectangle(org.x, org.y, crn.x, crn.y);
  };

  Point.prototype.extent = function(aPoint) {
    var crn;
    crn = this.add(aPoint);
    return new Rectangle(this.x, this.y, crn.x, crn.y);
  };

  return Point;

})();

Rectangle = (function() {

  Rectangle.prototype.origin = null;

  Rectangle.prototype.corner = null;

  function Rectangle(left, top, right, bottom) {
    this.origin = new Point(left || 0, top || 0);
    this.corner = new Point(right || 0, bottom || 0);
  }

  Rectangle.prototype.toString = function() {
    return "[" + this.origin.toString() + " | " + this.extent().toString() + "]";
  };

  Rectangle.prototype.copy = function() {
    return new Rectangle(this.left(), this.top(), this.right(), this.bottom());
  };

  Rectangle.prototype.setTo = function(left, top, right, bottom) {
    this.origin = new Point(left || (left === 0 ? 0 : this.left()), top || (top === 0 ? 0 : this.top()));
    return this.corner = new Point(right || (right === 0 ? 0 : this.right()), bottom || (bottom === 0 ? 0 : this.bottom()));
  };

  Rectangle.prototype.area = function() {
    var w;
    w = this.width();
    if (w < 0) {
      return 0;
    }
    return Math.max(w * this.height(), 0);
  };

  Rectangle.prototype.bottom = function() {
    return this.corner.y;
  };

  Rectangle.prototype.bottomCenter = function() {
    return new Point(this.center().x, this.bottom());
  };

  Rectangle.prototype.bottomLeft = function() {
    return new Point(this.origin.x, this.corner.y);
  };

  Rectangle.prototype.bottomRight = function() {
    return this.corner.copy();
  };

  Rectangle.prototype.boundingBox = function() {
    return this;
  };

  Rectangle.prototype.center = function() {
    return this.origin.add(this.corner.subtract(this.origin).floorDivideBy(2));
  };

  Rectangle.prototype.corners = function() {
    return [this.origin, this.bottomLeft(), this.corner, this.topRight()];
  };

  Rectangle.prototype.extent = function() {
    return this.corner.subtract(this.origin);
  };

  Rectangle.prototype.isEmpty = function() {
    var theExtent;
    theExtent = this.corner.subtract(this.origin);
    return theExtent.x = 0 || (theExtent.y = 0);
  };

  Rectangle.prototype.isNotEmpty = function() {
    var theExtent;
    theExtent = this.corner.subtract(this.origin);
    return theExtent.x > 0 && theExtent.y > 0;
  };

  Rectangle.prototype.height = function() {
    return this.corner.y - this.origin.y;
  };

  Rectangle.prototype.left = function() {
    return this.origin.x;
  };

  Rectangle.prototype.leftCenter = function() {
    return new Point(this.left(), this.center().y);
  };

  Rectangle.prototype.right = function() {
    return this.corner.x;
  };

  Rectangle.prototype.rightCenter = function() {
    return new Point(this.right(), this.center().y);
  };

  Rectangle.prototype.top = function() {
    return this.origin.y;
  };

  Rectangle.prototype.topCenter = function() {
    return new Point(this.center().x, this.top());
  };

  Rectangle.prototype.topLeft = function() {
    return this.origin;
  };

  Rectangle.prototype.topRight = function() {
    return new Point(this.corner.x, this.origin.y);
  };

  Rectangle.prototype.width = function() {
    return this.corner.x - this.origin.x;
  };

  Rectangle.prototype.position = function() {
    return this.origin;
  };

  Rectangle.prototype.eq = function(aRect) {
    return this.origin.eq(aRect.origin) && this.corner.eq(aRect.corner);
  };

  Rectangle.prototype.abs = function() {
    var newCorner, newOrigin;
    newOrigin = this.origin.abs();
    newCorner = this.corner.max(newOrigin);
    return newOrigin.corner(newCorner);
  };

  Rectangle.prototype.insetBy = function(delta) {
    var result;
    result = new Rectangle();
    result.origin = this.origin.add(delta);
    result.corner = this.corner.subtract(delta);
    return result;
  };

  Rectangle.prototype.expandBy = function(delta) {
    var result;
    result = new Rectangle();
    result.origin = this.origin.subtract(delta);
    result.corner = this.corner.add(delta);
    return result;
  };

  Rectangle.prototype.growBy = function(delta) {
    var result;
    result = new Rectangle();
    result.origin = this.origin.copy();
    result.corner = this.corner.add(delta);
    return result;
  };

  Rectangle.prototype.intersect = function(aRect) {
    var result;
    result = new Rectangle();
    result.origin = this.origin.max(aRect.origin);
    result.corner = this.corner.min(aRect.corner);
    return result;
  };

  Rectangle.prototype.merge = function(aRect) {
    var result;
    result = new Rectangle();
    result.origin = this.origin.min(aRect.origin);
    result.corner = this.corner.max(aRect.corner);
    return result;
  };

  Rectangle.prototype.round = function() {
    return this.origin.round().corner(this.corner.round());
  };

  Rectangle.prototype.spread = function() {
    return this.origin.floor().corner(this.corner.ceil());
  };

  Rectangle.prototype.amountToTranslateWithin = function(aRect) {
    var dx, dy;
    if (this.right() > aRect.right()) {
      dx = aRect.right() - this.right();
    }
    if (this.bottom() > aRect.bottom()) {
      dy = aRect.bottom() - this.bottom();
    }
    if ((this.left() + dx) < aRect.left()) {
      dx = aRect.left() - this.right();
    }
    if ((this.top() + dy) < aRect.top()) {
      dy = aRect.top() - this.top();
    }
    return new Point(dx, dy);
  };

  Rectangle.prototype.containsPoint = function(aPoint) {
    return this.origin.le(aPoint) && aPoint.lt(this.corner);
  };

  Rectangle.prototype.containsRectangle = function(aRect) {
    return aRect.origin.gt(this.origin) && aRect.corner.lt(this.corner);
  };

  Rectangle.prototype.intersects = function(aRect) {
    var rc, ro;
    ro = aRect.origin;
    rc = aRect.corner;
    return (rc.x >= this.origin.x) && (rc.y >= this.origin.y) && (ro.x <= this.corner.x) && (ro.y <= this.corner.y);
  };

  Rectangle.prototype.scaleBy = function(scale) {
    var c, o;
    o = this.origin.multiplyBy(scale);
    c = this.corner.multiplyBy(scale);
    return new Rectangle(o.x, o.y, c.x, c.y);
  };

  Rectangle.prototype.translateBy = function(factor) {
    var c, o;
    o = this.origin.add(factor);
    c = this.corner.add(factor);
    return new Rectangle(o.x, o.y, c.x, c.y);
  };

  Rectangle.prototype.asArray = function() {
    return [this.left(), this.top(), this.right(), this.bottom()];
  };

  Rectangle.prototype.asArray_xywh = function() {
    return [this.left(), this.top(), this.width(), this.height()];
  };

  return Rectangle;

})();

ShadowMorph = (function(_super) {

  __extends(ShadowMorph, _super);

  function ShadowMorph() {
    ShadowMorph.__super__.constructor.call(this);
  }

  return ShadowMorph;

})(Morph);

CaretMorph = (function(_super) {

  __extends(CaretMorph, _super);

  CaretMorph.prototype.keyDownEventUsed = false;

  CaretMorph.prototype.target = null;

  CaretMorph.prototype.originalContents = null;

  CaretMorph.prototype.slot = null;

  CaretMorph.prototype.viewPadding = 1;

  function CaretMorph(target) {
    var ls;
    this.target = target;
    this.originalContents = this.target.text;
    this.originalAlignment = this.target.alignment;
    this.slot = this.target.text.length;
    CaretMorph.__super__.constructor.call(this);
    ls = fontHeight(this.target.fontSize);
    this.setExtent(new Point(Math.max(Math.floor(ls / 20), 1), ls));
    this.updateRendering();
    this.image.getContext("2d").font = this.target.font();
    if (this.target instanceof TextMorph && (this.target.alignment !== 'left')) {
      this.target.setAlignmentToLeft();
    }
    this.gotoSlot(this.slot);
  }

  CaretMorph.prototype.processKeyPress = function(event) {
    if (this.keyDownEventUsed) {
      this.keyDownEventUsed = false;
      return null;
    }
    if ((event.keyCode === 40) || event.charCode === 40) {
      this.insert("(");
      return null;
    }
    if ((event.keyCode === 37) || event.charCode === 37) {
      this.insert("%");
      return null;
    }
    if (event.keyCode) {
      if (event.ctrlKey) {
        this.ctrl(event.keyCode);
      } else if (event.metaKey) {
        this.cmd(event.keyCode);
      } else {
        this.insert(String.fromCharCode(event.keyCode), event.shiftKey);
      }
    } else if (event.charCode) {
      if (event.ctrlKey) {
        this.ctrl(event.charCode);
      } else if (event.metaKey) {
        this.cmd(event.keyCode);
      } else {
        this.insert(String.fromCharCode(event.charCode), event.shiftKey);
      }
    }
    return this.target.escalateEvent("reactToKeystroke", event);
  };

  CaretMorph.prototype.processKeyDown = function(event) {
    var shift;
    shift = event.shiftKey;
    this.keyDownEventUsed = false;
    if (event.ctrlKey) {
      this.ctrl(event.keyCode);
      this.target.escalateEvent("reactToKeystroke", event);
      return;
    } else if (event.metaKey) {
      this.cmd(event.keyCode);
      this.target.escalateEvent("reactToKeystroke", event);
      return;
    }
    switch (event.keyCode) {
      case 37:
        this.goLeft(shift);
        this.keyDownEventUsed = true;
        break;
      case 39:
        this.goRight(shift);
        this.keyDownEventUsed = true;
        break;
      case 38:
        this.goUp(shift);
        this.keyDownEventUsed = true;
        break;
      case 40:
        this.goDown(shift);
        this.keyDownEventUsed = true;
        break;
      case 36:
        this.goHome(shift);
        this.keyDownEventUsed = true;
        break;
      case 35:
        this.goEnd(shift);
        this.keyDownEventUsed = true;
        break;
      case 46:
        this.deleteRight();
        this.keyDownEventUsed = true;
        break;
      case 8:
        this.deleteLeft();
        this.keyDownEventUsed = true;
        break;
      case 13:
        if (this.target.constructor.name === "StringMorph") {
          this.accept();
        } else {
          this.insert("\n");
        }
        this.keyDownEventUsed = true;
        break;
      case 27:
        this.cancel();
        this.keyDownEventUsed = true;
        break;
    }
    return this.target.escalateEvent("reactToKeystroke", event);
  };

  CaretMorph.prototype.gotoSlot = function(slot) {
    var left, length, pos, right;
    length = this.target.text.length;
    pos = this.target.slotPosition(slot);
    this.slot = (slot < 0 ? 0 : (slot > length ? length : slot));
    if (this.parent && this.target.isScrollable) {
      right = this.parent.right() - this.viewPadding;
      left = this.parent.left() + this.viewPadding;
      if (pos.x > right) {
        this.target.setLeft(this.target.left() + right - pos.x);
        pos.x = right;
      }
      if (pos.x < left) {
        left = Math.min(this.parent.left(), left);
        this.target.setLeft(this.target.left() + left - pos.x);
        pos.x = left;
      }
      if (this.target.right() < right && right - this.target.width() < left) {
        pos.x += right - this.target.right();
        this.target.setRight(right);
      }
    }
    this.show();
    this.setPosition(pos);
    if (this.parent && this.parent.parent instanceof ScrollFrameMorph && this.target.isScrollable) {
      return this.parent.parent.scrollCaretIntoView(this);
    }
  };

  CaretMorph.prototype.goLeft = function(shift) {
    this.updateSelection(shift);
    this.gotoSlot(this.slot - 1);
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.goRight = function(shift, howMany) {
    this.updateSelection(shift);
    this.gotoSlot(this.slot + (howMany || 1));
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.goUp = function(shift) {
    this.updateSelection(shift);
    this.gotoSlot(this.target.upFrom(this.slot));
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.goDown = function(shift) {
    this.updateSelection(shift);
    this.gotoSlot(this.target.downFrom(this.slot));
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.goHome = function(shift) {
    this.updateSelection(shift);
    this.gotoSlot(this.target.startOfLine(this.slot));
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.goEnd = function(shift) {
    this.updateSelection(shift);
    this.gotoSlot(this.target.endOfLine(this.slot));
    return this.updateSelection(shift);
  };

  CaretMorph.prototype.gotoPos = function(aPoint) {
    this.gotoSlot(this.target.slotAt(aPoint));
    return this.show();
  };

  CaretMorph.prototype.updateSelection = function(shift) {
    if (shift) {
      if (!this.target.endMark && !this.target.startMark) {
        this.target.startMark = this.slot;
        return this.target.endMark = this.slot;
      } else if (this.target.endMark !== this.slot) {
        this.target.endMark = this.slot;
        this.target.updateRendering();
        return this.target.changed();
      }
    } else {
      return this.target.clearSelection();
    }
  };

  CaretMorph.prototype.accept = function() {
    var world;
    world = this.root();
    if (world) {
      world.stopEditing();
    }
    return this.escalateEvent("accept", null);
  };

  CaretMorph.prototype.cancel = function() {
    var world;
    world = this.root();
    this.undo();
    if (world) {
      world.stopEditing();
    }
    return this.escalateEvent('cancel', null);
  };

  CaretMorph.prototype.undo = function() {
    this.target.text = this.originalContents;
    this.target.changed();
    this.target.updateRendering();
    this.target.changed();
    return this.gotoSlot(0);
  };

  CaretMorph.prototype.insert = function(aChar, shiftKey) {
    var text;
    if (aChar === "\t") {
      this.target.escalateEvent('reactToEdit', this.target);
      if (shiftKey) {
        return this.target.backTab(this.target);
      }
      return this.target.tab(this.target);
    }
    if (!this.target.isNumeric || !isNaN(parseFloat(aChar)) || contains(["-", "."], aChar)) {
      if (this.target.selection() !== "") {
        this.gotoSlot(this.target.selectionStartSlot());
        this.target.deleteSelection();
      }
      text = this.target.text;
      text = text.slice(0, this.slot) + aChar + text.slice(this.slot);
      this.target.text = text;
      this.target.updateRendering();
      this.target.changed();
      return this.goRight(false, aChar.length);
    }
  };

  CaretMorph.prototype.ctrl = function(aChar) {
    if ((aChar === 97) || (aChar === 65)) {
      return this.target.selectAll();
    } else if (aChar === 90) {
      return this.undo();
    } else if (aChar === 123) {
      return this.insert("{");
    } else if (aChar === 125) {
      return this.insert("}");
    } else if (aChar === 91) {
      return this.insert("[");
    } else if (aChar === 93) {
      return this.insert("]");
    } else if (aChar === 64) {
      return this.insert("@");
    }
  };

  CaretMorph.prototype.cmd = function(aChar) {
    if (aChar === 65) {
      return this.target.selectAll();
    } else if (aChar === 90) {
      return this.undo();
    }
  };

  CaretMorph.prototype.deleteRight = function() {
    var text;
    if (this.target.selection() !== "") {
      this.gotoSlot(this.target.selectionStartSlot());
      return this.target.deleteSelection();
    } else {
      text = this.target.text;
      this.target.changed();
      text = text.slice(0, this.slot) + text.slice(this.slot + 1);
      this.target.text = text;
      return this.target.updateRendering();
    }
  };

  CaretMorph.prototype.deleteLeft = function() {
    var text;
    if (this.target.selection()) {
      this.gotoSlot(this.target.selectionStartSlot());
      return this.target.deleteSelection();
    }
    text = this.target.text;
    this.target.changed();
    this.target.text = text.substring(0, this.slot - 1) + text.substr(this.slot);
    this.target.updateRendering();
    return this.goLeft();
  };

  CaretMorph.prototype.destroy = function() {
    if (this.target.alignment !== this.originalAlignment) {
      this.target.alignment = this.originalAlignment;
      this.target.updateRendering();
      this.target.changed();
    }
    return CaretMorph.__super__.destroy.apply(this, arguments);
  };

  CaretMorph.prototype.inspectKeyEvent = function(event) {
    return this.inform("Key pressed: " + String.fromCharCode(event.charCode) + "\n------------------------" + "\ncharCode: " + event.charCode.toString() + "\nkeyCode: " + event.keyCode.toString() + "\naltKey: " + event.altKey.toString() + "\nctrlKey: " + event.ctrlKey.toString() + "\ncmdKey: " + event.metaKey.toString());
  };

  return CaretMorph;

})(BlinkerMorph);

HandleMorph = (function(_super) {
  var step;

  __extends(HandleMorph, _super);

  HandleMorph.prototype.target = null;

  HandleMorph.prototype.minExtent = null;

  HandleMorph.prototype.inset = null;

  HandleMorph.prototype.type = null;

  function HandleMorph(target, minX, minY, insetX, insetY, type) {
    var size;
    this.target = target != null ? target : null;
    if (minX == null) {
      minX = 0;
    }
    if (minY == null) {
      minY = 0;
    }
    this.type = type != null ? type : "resize";
    this.minExtent = new Point(minX, minY);
    this.inset = new Point(insetX || 0, insetY || insetX || 0);
    HandleMorph.__super__.constructor.call(this);
    this.color = new Color(255, 255, 255);
    this.noticesTransparentClick = true;
    size = WorldMorph.MorphicPreferences.handleSize;
    this.setExtent(new Point(size, size));
  }

  HandleMorph.prototype.updateRendering = function() {
    this.normalImage = newCanvas(this.extent());
    this.highlightImage = newCanvas(this.extent());
    this.handleMorphRenderingHelper(this.normalImage, this.color, new Color(100, 100, 100));
    this.handleMorphRenderingHelper(this.highlightImage, new Color(100, 100, 255), new Color(255, 255, 255));
    this.image = this.normalImage;
    if (this.target) {
      this.setPosition(this.target.bottomRight().subtract(this.extent().add(this.inset)));
      this.target.add(this);
      return this.target.changed();
    }
  };

  HandleMorph.prototype.handleMorphRenderingHelper = function(aCanvas, color, shadowColor) {
    var context, i, p1, p11, p2, p22, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3, _results;
    context = aCanvas.getContext("2d");
    context.lineWidth = 1;
    context.lineCap = "round";
    context.strokeStyle = color.toString();
    if (this.type === "move") {
      p1 = this.bottomLeft().subtract(this.position());
      p11 = p1.copy();
      p2 = this.topRight().subtract(this.position());
      p22 = p2.copy();
      for (i = _i = 0, _ref = this.height(); _i <= _ref; i = _i += 6) {
        p11.y = p1.y - i;
        p22.y = p2.y - i;
        context.beginPath();
        context.moveTo(p11.x, p11.y);
        context.lineTo(p22.x, p22.y);
        context.closePath();
        context.stroke();
      }
    }
    p1 = this.bottomLeft().subtract(this.position());
    p11 = p1.copy();
    p2 = this.topRight().subtract(this.position());
    p22 = p2.copy();
    for (i = _j = 0, _ref1 = this.width(); _j <= _ref1; i = _j += 6) {
      p11.x = p1.x + i;
      p22.x = p2.x + i;
      context.beginPath();
      context.moveTo(p11.x, p11.y);
      context.lineTo(p22.x, p22.y);
      context.closePath();
      context.stroke();
    }
    context.strokeStyle = shadowColor.toString();
    if (this.type === "move") {
      p1 = this.bottomLeft().subtract(this.position());
      p11 = p1.copy();
      p2 = this.topRight().subtract(this.position());
      p22 = p2.copy();
      for (i = _k = -1, _ref2 = this.height(); _k <= _ref2; i = _k += 6) {
        p11.y = p1.y - i;
        p22.y = p2.y - i;
        context.beginPath();
        context.moveTo(p11.x, p11.y);
        context.lineTo(p22.x, p22.y);
        context.closePath();
        context.stroke();
      }
    }
    p1 = this.bottomLeft().subtract(this.position());
    p11 = p1.copy();
    p2 = this.topRight().subtract(this.position());
    p22 = p2.copy();
    _results = [];
    for (i = _l = 2, _ref3 = this.width(); _l <= _ref3; i = _l += 6) {
      p11.x = p1.x + i;
      p22.x = p2.x + i;
      context.beginPath();
      context.moveTo(p11.x, p11.y);
      context.lineTo(p22.x, p22.y);
      context.closePath();
      _results.push(context.stroke());
    }
    return _results;
  };

  step = null;

  HandleMorph.prototype.mouseDownLeft = function(pos) {
    var offset, world,
      _this = this;
    world = this.root();
    offset = pos.subtract(this.bounds.origin);
    if (!this.target) {
      return null;
    }
    this.step = function() {
      var newExt, newPos;
      if (world.hand.mouseButton) {
        newPos = world.hand.bounds.origin.copy().subtract(offset);
        if (_this.type === "resize") {
          newExt = newPos.add(_this.extent().add(_this.inset)).subtract(_this.target.bounds.origin);
          newExt = newExt.max(_this.minExtent);
          _this.target.setExtent(newExt);
          return _this.setPosition(_this.target.bottomRight().subtract(_this.extent().add(_this.inset)));
        } else {
          return _this.target.setPosition(newPos.subtract(_this.target.extent()).add(_this.extent()));
        }
      } else {
        return _this.step = null;
      }
    };
    if (!this.target.step) {
      return this.target.step = noOperation;
    }
  };

  HandleMorph.prototype.rootForGrab = function() {
    return this;
  };

  HandleMorph.prototype.mouseEnter = function() {
    this.image = this.highlightImage;
    return this.changed();
  };

  HandleMorph.prototype.mouseLeave = function() {
    this.image = this.normalImage;
    return this.changed();
  };

  HandleMorph.prototype.copyRecordingReferences = function(dict) {
    var c;
    c = HandleMorph.__super__.copyRecordingReferences.call(this, dict);
    if (c.target && dict[this.target]) {
      c.target = dict[this.target];
    }
    return c;
  };

  HandleMorph.prototype.attach = function() {
    var choices, menu,
      _this = this;
    choices = this.overlappedMorphs();
    menu = new MenuMorph(this, "choose target:");
    choices.forEach(function(each) {
      return menu.addItem(each.toString().slice(0, 50), function() {
        this.isDraggable = false;
        this.target = each;
        this.updateRendering();
        return this.noticesTransparentClick = true;
      });
    });
    if (choices.length) {
      return menu.popUpAtHand(this.world());
    }
  };

  return HandleMorph;

})(Morph);

SliderMorph = (function(_super) {

  __extends(SliderMorph, _super);

  SliderMorph.prototype.target = null;

  SliderMorph.prototype.action = null;

  SliderMorph.prototype.start = null;

  SliderMorph.prototype.stop = null;

  SliderMorph.prototype.value = null;

  SliderMorph.prototype.size = null;

  SliderMorph.prototype.offset = null;

  SliderMorph.prototype.button = null;

  SliderMorph.prototype.step = null;

  function SliderMorph(start, stop, value, size, orientation, color) {
    this.start = start != null ? start : 1;
    this.stop = stop != null ? stop : 100;
    this.value = value != null ? value : 50;
    this.size = size != null ? size : 10;
    this.button = new SliderButtonMorph();
    this.button.isDraggable = false;
    this.button.color = new Color(200, 200, 200);
    this.button.highlightColor = new Color(210, 210, 255);
    this.button.pressColor = new Color(180, 180, 255);
    SliderMorph.__super__.constructor.call(this, orientation);
    this.add(this.button);
    this.alpha = 0.3;
    this.color = color || new Color(0, 0, 0);
    this.setExtent(new Point(20, 100));
  }

  SliderMorph.prototype.autoOrientation = function() {
    return noOperation;
  };

  SliderMorph.prototype.rangeSize = function() {
    return this.stop - this.start;
  };

  SliderMorph.prototype.ratio = function() {
    return this.size / this.rangeSize();
  };

  SliderMorph.prototype.unitSize = function() {
    if (this.orientation === "vertical") {
      return (this.height() - this.button.height()) / this.rangeSize();
    }
    return (this.width() - this.button.width()) / this.rangeSize();
  };

  SliderMorph.prototype.updateRendering = function() {
    var bh, bw, posX, posY;
    SliderMorph.__super__.updateRendering.call(this);
    this.button.orientation = this.orientation;
    if (this.orientation === "vertical") {
      bw = this.width() - 2;
      bh = Math.max(bw, Math.round(this.height() * this.ratio()));
      this.button.silentSetExtent(new Point(bw, bh));
      posX = 1;
      posY = Math.min(Math.round((this.value - this.start) * this.unitSize()), this.height() - this.button.height());
    } else {
      bh = this.height() - 2;
      bw = Math.max(bh, Math.round(this.width() * this.ratio()));
      this.button.silentSetExtent(new Point(bw, bh));
      posY = 1;
      posX = Math.min(Math.round((this.value - this.start) * this.unitSize()), this.width() - this.button.width());
    }
    this.button.setPosition(new Point(posX, posY).add(this.bounds.origin));
    this.button.updateRendering();
    return this.button.changed();
  };

  SliderMorph.prototype.updateValue = function() {
    var relPos;
    if (this.orientation === "vertical") {
      relPos = this.button.top() - this.top();
    } else {
      relPos = this.button.left() - this.left();
    }
    this.value = Math.round(relPos / this.unitSize() + this.start);
    return this.updateTarget();
  };

  SliderMorph.prototype.updateTarget = function() {
    if (this.action) {
      if (typeof this.action === "function") {
        return this.action.call(this.target, this.value);
      } else {
        return this.target[this.action](this.value);
      }
    }
  };

  SliderMorph.prototype.copyRecordingReferences = function(dict) {
    var c;
    c = SliderMorph.__super__.copyRecordingReferences.call(this, dict);
    if (c.target && dict[this.target]) {
      c.target = dict[this.target];
    }
    if (c.button && dict[this.button]) {
      c.button = dict[this.button];
    }
    return c;
  };

  SliderMorph.prototype.developersMenu = function() {
    var menu;
    menu = SliderMorph.__super__.developersMenu.call(this);
    menu.addItem("show value...", "showValue", "display a dialog box\nshowing the selected number");
    menu.addItem("floor...", (function() {
      return this.prompt(menu.title + "\nfloor:", this.setStart, this, this.start.toString(), null, 0, this.stop - this.size, true);
    }), "set the minimum value\nwhich can be selected");
    menu.addItem("ceiling...", (function() {
      return this.prompt(menu.title + "\nceiling:", this.setStop, this, this.stop.toString(), null, this.start + this.size, this.size * 100, true);
    }), "set the maximum value\nwhich can be selected");
    menu.addItem("button size...", (function() {
      return this.prompt(menu.title + "\nbutton size:", this.setSize, this, this.size.toString(), null, 1, this.stop - this.start, true);
    }), "set the range\ncovered by\nthe slider button");
    menu.addLine();
    menu.addItem("set target", "setTarget", "select another morph\nwhose numerical property\nwill be " + "controlled by this one");
    return menu;
  };

  SliderMorph.prototype.showValue = function() {
    return this.inform(this.value);
  };

  SliderMorph.prototype.userSetStart = function(num) {
    return this.start = Math.max(num, this.stop);
  };

  SliderMorph.prototype.setStart = function(num) {
    var newStart;
    if (typeof num === "number") {
      this.start = Math.min(Math.max(num, 0), this.stop - this.size);
    } else {
      newStart = parseFloat(num);
      if (!isNaN(newStart)) {
        this.start = Math.min(Math.max(newStart, 0), this.stop - this.size);
      }
    }
    this.value = Math.max(this.value, this.start);
    this.updateTarget();
    this.updateRendering();
    return this.changed();
  };

  SliderMorph.prototype.setStop = function(num) {
    var newStop;
    if (typeof num === "number") {
      this.stop = Math.max(num, this.start + this.size);
    } else {
      newStop = parseFloat(num);
      if (!isNaN(newStop)) {
        this.stop = Math.max(newStop, this.start + this.size);
      }
    }
    this.value = Math.min(this.value, this.stop);
    this.updateTarget();
    this.updateRendering();
    return this.changed();
  };

  SliderMorph.prototype.setSize = function(num) {
    var newSize;
    if (typeof num === "number") {
      this.size = Math.min(Math.max(num, 1), this.stop - this.start);
    } else {
      newSize = parseFloat(num);
      if (!isNaN(newSize)) {
        this.size = Math.min(Math.max(newSize, 1), this.stop - this.start);
      }
    }
    this.value = Math.min(this.value, this.stop - this.size);
    this.updateTarget();
    this.updateRendering();
    return this.changed();
  };

  SliderMorph.prototype.setTarget = function() {
    var choices, menu,
      _this = this;
    choices = this.overlappedMorphs();
    menu = new MenuMorph(this, "choose target:");
    choices.push(this.world());
    choices.forEach(function(each) {
      return menu.addItem(each.toString().slice(0, 50), function() {
        _this.target = each;
        return _this.setTargetSetter();
      });
    });
    if (choices.length === 1) {
      this.target = choices[0];
      return this.setTargetSetter();
    } else {
      if (choices.length) {
        return menu.popUpAtHand(this.world());
      }
    }
  };

  SliderMorph.prototype.setTargetSetter = function() {
    var choices, menu,
      _this = this;
    choices = this.target.numericalSetters();
    menu = new MenuMorph(this, "choose target property:");
    choices.forEach(function(each) {
      return menu.addItem(each, function() {
        return _this.action = each;
      });
    });
    if (choices.length === 1) {
      return this.action = choices[0];
    } else {
      if (choices.length) {
        return menu.popUpAtHand(this.world());
      }
    }
  };

  SliderMorph.prototype.numericalSetters = function() {
    var list;
    list = SliderMorph.__super__.numericalSetters.call(this);
    list.push("setStart", "setStop", "setSize");
    return list;
  };

  SliderMorph.prototype.mouseDownLeft = function(pos) {
    var world,
      _this = this;
    if (!this.button.bounds.containsPoint(pos)) {
      this.offset = new Point();
    } else {
      this.offset = pos.subtract(this.button.bounds.origin);
    }
    world = this.root();
    return this.step = function() {
      var mousePos, newX, newY;
      if (world.hand.mouseButton) {
        mousePos = world.hand.bounds.origin;
        if (_this.orientation === "vertical") {
          newX = _this.button.bounds.origin.x;
          newY = Math.max(Math.min(mousePos.y - _this.offset.y, _this.bottom() - _this.button.height()), _this.top());
        } else {
          newY = _this.button.bounds.origin.y;
          newX = Math.max(Math.min(mousePos.x - _this.offset.x, _this.right() - _this.button.width()), _this.left());
        }
        _this.button.setPosition(new Point(newX, newY));
        return _this.updateValue();
      } else {
        return _this.step = null;
      }
    };
  };

  return SliderMorph;

})(CircleBoxMorph);

MenuMorph = (function(_super) {

  __extends(MenuMorph, _super);

  MenuMorph.prototype.target = null;

  MenuMorph.prototype.title = null;

  MenuMorph.prototype.environment = null;

  MenuMorph.prototype.fontSize = null;

  MenuMorph.prototype.items = null;

  MenuMorph.prototype.label = null;

  MenuMorph.prototype.world = null;

  MenuMorph.prototype.isListContents = false;

  function MenuMorph(target, title, environment, fontSize) {
    this.target = target;
    this.title = title != null ? title : null;
    this.environment = environment != null ? environment : null;
    this.fontSize = fontSize != null ? fontSize : null;
    this.items = [];
    MenuMorph.__super__.constructor.call(this);
    this.border = null;
  }

  MenuMorph.prototype.addItem = function(labelString, action, hint, color) {
    return this.items.push([localize(labelString || "close"), action || nop, hint, color]);
  };

  MenuMorph.prototype.addLine = function(width) {
    return this.items.push([0, width || 1]);
  };

  MenuMorph.prototype.createLabel = function() {
    var text;
    if (this.label !== null) {
      this.label.destroy();
    }
    text = new TextMorph(localize(this.title), this.fontSize || WorldMorph.MorphicPreferences.menuFontSize, WorldMorph.MorphicPreferences.menuFontName, true, false, "center");
    text.alignment = "center";
    text.color = new Color(255, 255, 255);
    text.backgroundColor = this.borderColor;
    text.updateRendering();
    this.label = new BoxMorph(3, 0);
    this.label.color = this.borderColor;
    this.label.borderColor = this.borderColor;
    this.label.setExtent(text.extent().add(4));
    this.label.updateRendering();
    this.label.add(text);
    return this.label.text = text;
  };

  MenuMorph.prototype.updateRendering = function() {
    var fb, isLine, x, y,
      _this = this;
    isLine = false;
    this.children.forEach(function(m) {
      return m.destroy();
    });
    this.children = [];
    if (!this.isListContents) {
      this.edge = 5;
      this.border = 2;
    }
    this.color = new Color(255, 255, 255);
    this.borderColor = new Color(60, 60, 60);
    this.silentSetExtent(new Point(0, 0));
    y = 2;
    x = this.left() + 4;
    if (!this.isListContents) {
      if (this.title) {
        this.createLabel();
        this.label.setPosition(this.bounds.origin.add(4));
        this.add(this.label);
        y = this.label.bottom();
      } else {
        y = this.top() + 4;
      }
    }
    y += 1;
    this.items.forEach(function(tuple) {
      var item;
      isLine = false;
      if (tuple instanceof StringFieldMorph || tuple instanceof ColorPickerMorph || tuple instanceof SliderMorph) {
        item = tuple;
      } else if (tuple[0] === 0) {
        isLine = true;
        item = new Morph();
        item.color = _this.borderColor;
        item.setHeight(tuple[1]);
      } else {
        item = new MenuItemMorph(_this.target, tuple[1], tuple[0], _this.fontSize || WorldMorph.MorphicPreferences.menuFontSize, WorldMorph.MorphicPreferences.menuFontName, _this.environment, tuple[2], tuple[3]);
      }
      if (isLine) {
        y += 1;
      }
      item.setPosition(new Point(x, y));
      _this.add(item);
      y = y + item.height();
      if (isLine) {
        return y += 1;
      }
    });
    fb = this.boundsIncludingChildren();
    this.silentSetExtent(fb.extent().add(4));
    this.adjustWidths();
    return MenuMorph.__super__.updateRendering.call(this);
  };

  MenuMorph.prototype.maxWidth = function() {
    var w;
    w = 0;
    if (this.parent instanceof FrameMorph) {
      if (this.parent.scrollFrame instanceof ScrollFrameMorph) {
        w = this.parent.scrollFrame.width();
      }
    }
    this.children.forEach(function(item) {
      if (item instanceof MenuItemMorph) {
        return w = Math.max(w, item.children[0].width() + 8);
      } else if ((item instanceof StringFieldMorph) || (item instanceof ColorPickerMorph) || (item instanceof SliderMorph)) {
        return w = Math.max(w, item.width());
      }
    });
    if (this.label) {
      w = Math.max(w, this.label.width());
    }
    return w;
  };

  MenuMorph.prototype.adjustWidths = function() {
    var w,
      _this = this;
    w = this.maxWidth();
    return this.children.forEach(function(item) {
      var isSelected;
      item.silentSetWidth(w);
      if (item instanceof MenuItemMorph) {
        isSelected = item.image === item.pressImage;
        item.createBackgrounds();
        if (isSelected) {
          return item.image = item.pressImage;
        }
      } else {
        item.updateRendering();
        if (item === _this.label) {
          return item.text.setPosition(item.center().subtract(item.text.extent().floorDivideBy(2)));
        }
      }
    });
  };

  MenuMorph.prototype.unselectAllItems = function() {
    this.children.forEach(function(item) {
      if (item instanceof MenuItemMorph) {
        return item.image = item.normalImage;
      }
    });
    return this.changed();
  };

  MenuMorph.prototype.popup = function(world, pos) {
    this.updateRendering();
    this.setPosition(pos);
    this.addShadow(new Point(2, 2), 80);
    this.keepWithin(world);
    if (world.activeMenu) {
      world.activeMenu.destroy();
    }
    world.add(this);
    world.activeMenu = this;
    return this.fullChanged();
  };

  MenuMorph.prototype.popUpAtHand = function(world) {
    var wrrld;
    wrrld = world || this.world;
    return this.popup(wrrld, wrrld.hand.position());
  };

  MenuMorph.prototype.popUpCenteredAtHand = function(world) {
    var wrrld;
    wrrld = world || this.world;
    this.updateRendering();
    return this.popup(wrrld, wrrld.hand.position().subtract(this.extent().floorDivideBy(2)));
  };

  MenuMorph.prototype.popUpCenteredInWorld = function(world) {
    var wrrld;
    wrrld = world || this.world;
    this.updateRendering();
    return this.popup(wrrld, wrrld.center().subtract(this.extent().floorDivideBy(2)));
  };

  return MenuMorph;

})(BoxMorph);

/*
Copyright 2013 Craig Campbell
coffeescript port by Davide Della Casa

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Mousetrap is a simple keyboard shortcut library for Javascript with
no external dependencies

@version 1.3.1
@url craig.is/killing/mice
*/


/*
mapping of special keycodes to their corresponding keys

everything in this dictionary cannot use keypress events
so it has to be here to map to the correct keycodes for
keyup/keydown events

@type {Object}
*/


_MAP = {
  8: "backspace",
  9: "tab",
  13: "enter",
  16: "shift",
  17: "ctrl",
  18: "alt",
  20: "capslock",
  27: "esc",
  32: "space",
  33: "pageup",
  34: "pagedown",
  35: "end",
  36: "home",
  37: "left",
  38: "up",
  39: "right",
  40: "down",
  45: "ins",
  46: "del",
  91: "meta",
  93: "meta",
  224: "meta"
};

/*
mapping for special characters so they can support

this dictionary is only used incase you want to bind a
keyup or keydown event to one of these keys

@type {Object}
*/


_KEYCODE_MAP = {
  106: "*",
  107: "+",
  109: "-",
  110: ".",
  111: "/",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};

/*
this is a mapping of keys that require shift on a US keypad
back to the non shift equivelents

this is so you can use keyup events with these keys

note that this will only work reliably on US keyboards

@type {Object}
*/


_SHIFT_MAP = {
  "~": "`",
  "!": "1",
  "@": "2",
  "#": "3",
  $: "4",
  "%": "5",
  "^": "6",
  "&": "7",
  "*": "8",
  "(": "9",
  ")": "0",
  _: "-",
  "+": "=",
  ":": ";",
  "\"": "'",
  "<": ",",
  ">": ".",
  "?": "/",
  "|": "\\"
};

/*
this is a list of special strings you can use to map
to modifier keys when you specify your keyboard shortcuts

@type {Object}
*/


_SPECIAL_ALIASES = {
  option: "alt",
  command: "meta",
  "return": "enter",
  escape: "esc"
};

/*
variable to store the flipped version of _MAP from above
needed to check if we should use keypress or not when no action
is specified

@type {Object|undefined}
*/


_REVERSE_MAP = void 0;

/*
a list of all the callbacks setup via Mousetrap.bind()

@type {Object}
*/


_callbacks = {};

/*
direct map of string combinations to callbacks used for trigger()

@type {Object}
*/


_directMap = {};

/*
keeps track of what level each sequence is at since multiple
sequences can start out with the same sequence

@type {Object}
*/


_sequenceLevels = {};

/*
variable to store the setTimeout call

@type {null|number}
*/


_resetTimer = void 0;

/*
temporary state where we will ignore the next keyup

@type {boolean|string}
*/


_ignoreNextKeyup = false;

/*
are we currently inside of a sequence?
type of action ("keyup" or "keydown" or "keypress") or false

@type {boolean|string}
*/


_sequenceType = false;

/*
loop through the f keys, f1 to f19 and add them to the map
programatically
*/


i = 1;

while (i < 20) {
  _MAP[111 + i] = "f" + i;
  ++i;
}

/*
loop through to map numbers on the numeric keypad
*/


i = 0;

while (i <= 9) {
  _MAP[i + 96] = i;
  ++i;
}

/*
cross browser add event method

@param {Element|HTMLDocument} object
@param {string} type
@param {Function} callback
@returns void
*/


_addEvent = function(object, type, callback) {
  if (object.addEventListener) {
    object.addEventListener(type, callback, false);
    return;
  }
  return object.attachEvent("on" + type, callback);
};

/*
takes the event and returns the key character

@param {Event} e
@return {string}
*/


_characterFromEvent = function(e) {
  if (e.type === "keypress") {
    return String.fromCharCode(e.which);
  }
  if (_MAP[e.which]) {
    return _MAP[e.which];
  }
  if (_KEYCODE_MAP[e.which]) {
    return _KEYCODE_MAP[e.which];
  }
  return String.fromCharCode(e.which).toLowerCase();
};

/*
checks if two arrays are equal

@param {Array} modifiers1
@param {Array} modifiers2
@returns {boolean}
*/


_modifiersMatch = function(modifiers1, modifiers2) {
  return modifiers1.sort().join(",") === modifiers2.sort().join(",");
};

/*
resets all sequence counters except for the ones passed in

@param {Object} doNotReset
@returns void
*/


_resetSequences = function(doNotReset, maxLevel) {
  var activeSequences, key;
  doNotReset = doNotReset || {};
  activeSequences = false;
  key = void 0;
  for (key in _sequenceLevels) {
    if (doNotReset[key] && _sequenceLevels[key] > maxLevel) {
      activeSequences = true;
      continue;
    }
    _sequenceLevels[key] = 0;
  }
  if (!activeSequences) {
    return _sequenceType = false;
  }
};

/*
finds all callbacks that match based on the keycode, modifiers,
and action

@param {string} character
@param {Array} modifiers
@param {Event|Object} e
@param {boolean=} remove - should we remove any matches
@param {string=} combination
@returns {Array}
*/


_getMatches = function(character, modifiers, e, remove, combination) {
  var action, callback, matches, _i, _ref;
  i = void 0;
  callback = void 0;
  matches = [];
  action = e.type;
  if (!_callbacks[character]) {
    return [];
  }
  if (action === "keyup" && _isModifier(character)) {
    modifiers = [character];
  }
  for (i = _i = 0, _ref = _callbacks[character].length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    callback = _callbacks[character][i];
    if (callback.seq && _sequenceLevels[callback.seq] !== callback.level) {
      continue;
    }
    if (action !== callback.action) {
      continue;
    }
    if ((action === "keypress" && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {
      if (remove && callback.combo === combination) {
        _callbacks[character].splice(i, 1);
      }
      matches.push(callback);
    }
  }
  return matches;
};

/*
takes a key event and figures out what the modifiers are

@param {Event} e
@returns {Array}
*/


_eventModifiers = function(e) {
  var modifiers;
  modifiers = [];
  if (e.shiftKey) {
    modifiers.push("shift");
  }
  if (e.altKey) {
    modifiers.push("alt");
  }
  if (e.ctrlKey) {
    modifiers.push("ctrl");
  }
  if (e.metaKey) {
    modifiers.push("meta");
  }
  return modifiers;
};

/*
actually calls the callback function

if your callback function returns false this will use the jquery
convention - prevent default and stop propogation on the event

@param {Function} callback
@param {Event} e
@returns void
*/


_fireCallback = function(callback, e, combo) {
  if (Mousetrap.stopCallback(e, e.target || e.srcElement, combo)) {
    return;
  }
  if (callback(e, combo) === false) {
    if (e.preventDefault) {
      e.preventDefault();
    }
    if (e.stopPropagation) {
      e.stopPropagation();
    }
    e.returnValue = false;
    return e.cancelBubble = true;
  }
};

/*
handles a character key event

@param {string} character
@param {Event} e
@returns void
*/


_handleCharacter = function(character, e) {
  var callbacks, doNotReset, maxLevel, processedSequenceCallback;
  callbacks = _getMatches(character, _eventModifiers(e), e);
  i = void 0;
  doNotReset = {};
  maxLevel = 0;
  processedSequenceCallback = false;
  i = 0;
  while (i < callbacks.length) {
    if (callbacks[i].seq) {
      processedSequenceCallback = true;
      maxLevel = Math.max(maxLevel, callbacks[i].level);
      doNotReset[callbacks[i].seq] = 1;
      _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
      continue;
    }
    if (!processedSequenceCallback && !_sequenceType) {
      _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
    }
    ++i;
  }
  if (e.type === _sequenceType && !_isModifier(character)) {
    return _resetSequences(doNotReset, maxLevel);
  }
};

/*
handles a keydown event

@param {Event} e
@returns void
*/


_handleKey = function(e) {
  var character;
  if (typeof e.which !== "number") {
    e.which = e.keyCode;
  }
  character = _characterFromEvent(e);
  if (!character) {
    return;
  }
  if (e.type === "keyup" && _ignoreNextKeyup === character) {
    _ignoreNextKeyup = false;
    return;
  }
  return _handleCharacter(character, e);
};

/*
determines if the keycode specified is a modifier key or not

@param {string} key
@returns {boolean}
*/


_isModifier = function(key) {
  return key === "shift" || key === "ctrl" || key === "alt" || key === "meta";
};

/*
called to set a 1 second timeout on the specified sequence

this is so after each key press in the sequence you have 1 second
to press the next key before you have to start over

@returns void
*/


_resetSequenceTimer = function() {
  clearTimeout(_resetTimer);
  return _resetTimer = setTimeout(_resetSequences, 1000);
};

/*
reverses the map lookup so that we can look for specific keys
to see what can and can't use keypress

@return {Object}
*/


_getReverseMap = function() {
  var key;
  if (!_REVERSE_MAP) {
    _REVERSE_MAP = {};
    for (key in _MAP) {
      if (key > 95 && key < 112) {
        continue;
      }
      if (_MAP.hasOwnProperty(key)) {
        _REVERSE_MAP[_MAP[key]] = key;
      }
    }
  }
  return _REVERSE_MAP;
};

/*
picks the best action based on the key combination

@param {string} key - character for key
@param {Array} modifiers
@param {string=} action passed in
*/


_pickBestAction = function(key, modifiers, action) {
  if (!action) {
    action = (_getReverseMap()[key] ? "keydown" : "keypress");
  }
  if (action === "keypress" && modifiers.length) {
    action = "keydown";
  }
  return action;
};

/*
binds a key sequence to an event

@param {string} combo - combo specified in bind call
@param {Array} keys
@param {Function} callback
@param {string=} action
@returns void
*/


_bindSequence = function(combo, keys, callback, action) {
  var _callbackAndReset, _increaseSequence, _results;
  _sequenceLevels[combo] = 0;
  if (!action) {
    action = _pickBestAction(keys[0], []);
  }
  /*
    callback to increase the sequence level for this sequence and reset
    all other sequences that were active
    
    @param {Event} e
    @returns void
  */

  _increaseSequence = function() {
    _sequenceType = action;
    ++_sequenceLevels[combo];
    return _resetSequenceTimer();
  };
  /*
    wraps the specified callback inside of another function in order
    to reset all sequence counters as soon as this sequence is done
    
    @param {Event} e
    @returns void
  */

  _callbackAndReset = function(e) {
    _fireCallback(callback, e, combo);
    if (action !== "keyup") {
      _ignoreNextKeyup = _characterFromEvent(e);
    }
    return setTimeout(_resetSequences, 10);
  };
  i = void 0;
  i = 0;
  _results = [];
  while (i < keys.length) {
    _bindSingle(keys[i], (i < keys.length - 1 ? _increaseSequence : _callbackAndReset), action, combo, i);
    _results.push(++i);
  }
  return _results;
};

/*
binds a single keyboard combination

@param {string} combination
@param {Function} callback
@param {string=} action
@param {string=} sequenceName - name of sequence if part of sequence
@param {number=} level - what part of the sequence the command is
@returns void
*/


_bindSingle = function(combination, callback, action, sequenceName, level) {
  var key, keys, modifiers, sequence;
  _directMap[combination + ":" + action] = callback;
  combination = combination.replace(/\s+/g, " ");
  sequence = combination.split(" ");
  i = void 0;
  key = void 0;
  keys = void 0;
  modifiers = [];
  if (sequence.length > 1) {
    _bindSequence(combination, sequence, callback, action);
    return;
  }
  keys = (combination === "+" ? ["+"] : combination.split("+"));
  i = 0;
  while (i < keys.length) {
    key = keys[i];
    if (_SPECIAL_ALIASES[key]) {
      key = _SPECIAL_ALIASES[key];
    }
    if (action && action !== "keypress" && _SHIFT_MAP[key]) {
      key = _SHIFT_MAP[key];
      modifiers.push("shift");
    }
    if (_isModifier(key)) {
      modifiers.push(key);
    }
    ++i;
  }
  action = _pickBestAction(key, modifiers, action);
  if (!_callbacks[key]) {
    _callbacks[key] = [];
  }
  _getMatches(key, modifiers, {
    type: action
  }, !sequenceName, combination);
  return _callbacks[key][(sequenceName ? "unshift" : "push")]({
    callback: callback,
    modifiers: modifiers,
    action: action,
    seq: sequenceName,
    level: level,
    combo: combination
  });
};

/*
binds multiple combinations to the same callback

@param {Array} combinations
@param {Function} callback
@param {string|undefined} action
@returns void
*/


_bindMultiple = function(combinations, callback, action) {
  var _results;
  i = 0;
  _results = [];
  while (i < combinations.length) {
    _bindSingle(combinations[i], callback, action);
    _results.push(++i);
  }
  return _results;
};

_addEvent(document, "keypress", _handleKey);

_addEvent(document, "keydown", _handleKey);

_addEvent(document, "keyup", _handleKey);

Mousetrap = {
  /*
    binds an event to mousetrap
    
    can be a single key, a combination of keys separated with +,
    an array of keys, or a sequence of keys separated by spaces
    
    be sure to list the modifier keys first to make sure that the
    correct key ends up getting bound (the last key in the pattern)
    
    @param {string|Array} keys
    @param {Function} callback
    @param {string=} action - 'keypress', 'keydown', or 'keyup'
    @returns void
  */

  bind: function(keys, callback, action) {
    keys = (keys instanceof Array ? keys : [keys]);
    _bindMultiple(keys, callback, action);
    return this;
  },
  /*
    unbinds an event to mousetrap
    
    the unbinding sets the callback function of the specified key combo
    to an empty function and deletes the corresponding key in the
    _directMap dict.
    
    TODO: actually remove this from the _callbacks dictionary instead
    of binding an empty function
    
    the keycombo+action has to be exactly the same as
    it was defined in the bind method
    
    @param {string|Array} keys
    @param {string} action
    @returns void
  */

  unbind: function(keys, action) {
    return Mousetrap.bind(keys, (function() {}), action);
  },
  /*
    triggers an event that has already been bound
    
    @param {string} keys
    @param {string=} action
    @returns void
  */

  trigger: function(keys, action) {
    if (_directMap[keys + ":" + action]) {
      _directMap[keys + ":" + action]({}, keys);
    }
    return this;
  },
  /*
    resets the library back to its initial state.  this is useful
    if you want to clear out the current keyboard shortcuts and bind
    new ones - for example if you switch to another page
    
    @returns void
  */

  reset: function() {
    _callbacks = {};
    _directMap = {};
    return this;
  },
  /*
    should we stop this event before firing off callbacks
    
    @param {Event} e
    @param {Element} element
    @return {boolean}
  */

  stopCallback: function(e, element) {
    if ((" " + element.className + " ").indexOf(" mousetrap ") > -1) {
      return false;
    }
    return element.tagName === "INPUT" || element.tagName === "SELECT" || element.tagName === "TEXTAREA" || (element.contentEditable && element.contentEditable === "true");
  }
};

window.Mousetrap = Mousetrap;

PenMorph = (function(_super) {

  __extends(PenMorph, _super);

  PenMorph.prototype.heading = 0;

  PenMorph.prototype.penSize = null;

  PenMorph.prototype.isWarped = false;

  PenMorph.prototype.isDown = true;

  PenMorph.prototype.wantsRedraw = false;

  PenMorph.prototype.penPoint = 'tip';

  function PenMorph() {
    this.penSize = WorldMorph.MorphicPreferences.handleSize * 4;
    PenMorph.__super__.constructor.call(this);
    this.setExtent(new Point(this.penSize, this.penSize));
    this.penSize = 1;
  }

  PenMorph.staticVariable = 1;

  PenMorph.staticFunction = function() {
    return 3.14;
  };

  PenMorph.prototype.changed = function() {
    var w;
    if (this.isWarped === false) {
      w = this.root();
      if (w instanceof WorldMorph) {
        w.broken.push(this.visibleBounds().spread());
      }
      if (this.parent) {
        return this.parent.childChanged(this);
      }
    }
  };

  PenMorph.prototype.updateRendering = function(facing) {
    var context, dest, direction, left, len, right, start;
    direction = facing || this.heading;
    if (this.isWarped) {
      this.wantsRedraw = true;
      return;
    }
    this.image = newCanvas(this.extent());
    context = this.image.getContext("2d");
    len = this.width() / 2;
    start = this.center().subtract(this.bounds.origin);
    if (this.penPoint === "tip") {
      dest = start.distanceAngle(len * 0.75, direction - 180);
      left = start.distanceAngle(len, direction + 195);
      right = start.distanceAngle(len, direction - 195);
    } else {
      dest = start.distanceAngle(len * 0.75, direction);
      left = start.distanceAngle(len * 0.33, direction + 230);
      right = start.distanceAngle(len * 0.33, direction - 230);
    }
    context.fillStyle = this.color.toString();
    context.beginPath();
    context.moveTo(start.x, start.y);
    context.lineTo(left.x, left.y);
    context.lineTo(dest.x, dest.y);
    context.lineTo(right.x, right.y);
    context.closePath();
    context.strokeStyle = "white";
    context.lineWidth = 3;
    context.stroke();
    context.strokeStyle = "black";
    context.lineWidth = 1;
    context.stroke();
    context.fill();
    return this.wantsRedraw = false;
  };

  PenMorph.prototype.setHeading = function(degrees) {
    this.heading = parseFloat(degrees) % 360;
    this.updateRendering();
    return this.changed();
  };

  PenMorph.prototype.drawLine = function(start, dest) {
    var context, from, to;
    context = this.parent.penTrails().getContext("2d");
    from = start.subtract(this.parent.bounds.origin);
    to = dest.subtract(this.parent.bounds.origin);
    if (this.isDown) {
      context.lineWidth = this.penSize;
      context.strokeStyle = this.color.toString();
      context.lineCap = "round";
      context.lineJoin = "round";
      context.beginPath();
      context.moveTo(from.x, from.y);
      context.lineTo(to.x, to.y);
      context.stroke();
      if (this.isWarped === false) {
        return this.world().broken.push(start.rectangle(dest).expandBy(Math.max(this.penSize / 2, 1)).intersect(this.parent.visibleBounds()).spread());
      }
    }
  };

  PenMorph.prototype.turn = function(degrees) {
    return this.setHeading(this.heading + parseFloat(degrees));
  };

  PenMorph.prototype.forward = function(steps) {
    var dest, dist, start;
    start = this.center();
    dist = parseFloat(steps);
    if (dist >= 0) {
      dest = this.position().distanceAngle(dist, this.heading);
    } else {
      dest = this.position().distanceAngle(Math.abs(dist), this.heading - 180);
    }
    this.setPosition(dest);
    return this.drawLine(start, this.center());
  };

  PenMorph.prototype.down = function() {
    return this.isDown = true;
  };

  PenMorph.prototype.up = function() {
    return this.isDown = false;
  };

  PenMorph.prototype.clear = function() {
    this.parent.updateRendering();
    return this.parent.changed();
  };

  PenMorph.prototype.startWarp = function() {
    this.wantsRedraw = false;
    return this.isWarped = true;
  };

  PenMorph.prototype.endWarp = function() {
    this.isWarped = false;
    if (this.wantsRedraw) {
      this.updateRendering();
      this.wantsRedraw = false;
    }
    return this.parent.changed();
  };

  PenMorph.prototype.warp = function(fun) {
    this.startWarp();
    fun.call(this);
    return this.endWarp();
  };

  PenMorph.prototype.warpOp = function(selector, argsArray) {
    this.startWarp();
    this[selector].apply(this, argsArray);
    return this.endWarp();
  };

  PenMorph.prototype.warpSierpinski = function(length, min) {
    return this.warpOp("sierpinski", [length, min]);
  };

  PenMorph.prototype.sierpinski = function(length, min) {
    var _i, _results;
    if (length > min) {
      _results = [];
      for (i = _i = 0; _i < 3; i = ++_i) {
        this.sierpinski(length * 0.5, min);
        this.turn(120);
        _results.push(this.forward(length));
      }
      return _results;
    }
  };

  PenMorph.prototype.warpTree = function(level, length, angle) {
    return this.warpOp("tree", [level, length, angle]);
  };

  PenMorph.prototype.tree = function(level, length, angle) {
    if (level > 0) {
      this.penSize = level;
      this.forward(length);
      this.turn(angle);
      this.tree(level - 1, length * 0.75, angle);
      this.turn(angle * -2);
      this.tree(level - 1, length * 0.75, angle);
      this.turn(angle);
      return this.forward(-length);
    }
  };

  return PenMorph;

})(Morph);

SystemTest_SimpleMenuTest = (function() {

  function SystemTest_SimpleMenuTest() {}

  SystemTest_SimpleMenuTest.testData = [
    {
      type: "systemInfo",
      time: 0,
      systemInfo: {
        zombieKernelTestHarnessVersionMajor: 0,
        zombieKernelTestHarnessVersionMinor: 1,
        zombieKernelTestHarnessVersionRelease: 0,
        userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.43 Safari/537.31",
        screenWidth: 1920,
        screenHeight: 1080,
        screenColorDepth: 24,
        screenPixelRatio: 1,
        appCodeName: "Mozilla",
        appName: "Netscape",
        appVersion: "5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.43 Safari/537.31",
        cookieEnabled: true,
        platform: "MacIntel"
      }
    }, {
      type: "mouseMove",
      mouseX: 604,
      mouseY: 4,
      time: 1742
    }, {
      type: "mouseMove",
      mouseX: 592,
      mouseY: 14,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 581,
      mouseY: 21,
      time: 16
    }, {
      type: "mouseMove",
      mouseX: 556,
      mouseY: 25,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 544,
      mouseY: 28,
      time: 16
    }, {
      type: "mouseMove",
      mouseX: 529,
      mouseY: 37,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 513,
      mouseY: 44,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 492,
      mouseY: 55,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 482,
      mouseY: 59,
      time: 16
    }, {
      type: "mouseMove",
      mouseX: 472,
      mouseY: 64,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 464,
      mouseY: 66,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 461,
      mouseY: 67,
      time: 16
    }, {
      type: "mouseMove",
      mouseX: 460,
      mouseY: 68,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 460,
      mouseY: 69,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 458,
      mouseY: 70,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 456,
      mouseY: 72,
      time: 18
    }, {
      type: "mouseMove",
      mouseX: 455,
      mouseY: 72,
      time: 15
    }, {
      type: "mouseMove",
      mouseX: 452,
      mouseY: 74,
      time: 16
    }, {
      type: "mouseMove",
      mouseX: 450,
      mouseY: 74,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 449,
      mouseY: 75,
      time: 50
    }, {
      type: "mouseMove",
      mouseX: 448,
      mouseY: 76,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 447,
      mouseY: 77,
      time: 16
    }, {
      type: "mouseMove",
      mouseX: 445,
      mouseY: 79,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 444,
      mouseY: 80,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 444,
      mouseY: 81,
      time: 16
    }, {
      type: "mouseMove",
      mouseX: 442,
      mouseY: 83,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 436,
      mouseY: 91,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 433,
      mouseY: 95,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 423,
      mouseY: 106,
      time: 16
    }, {
      type: "mouseMove",
      mouseX: 417,
      mouseY: 115,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 414,
      mouseY: 118,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 408,
      mouseY: 123,
      time: 16
    }, {
      type: "mouseMove",
      mouseX: 396,
      mouseY: 131,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 387,
      mouseY: 135,
      time: 16
    }, {
      type: "mouseMove",
      mouseX: 380,
      mouseY: 138,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 379,
      mouseY: 139,
      time: 66
    }, {
      type: "mouseMove",
      mouseX: 378,
      mouseY: 141,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 375,
      mouseY: 142,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 373,
      mouseY: 145,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 368,
      mouseY: 149,
      time: 16
    }, {
      type: "mouseMove",
      mouseX: 365,
      mouseY: 154,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 364,
      mouseY: 154,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 364,
      mouseY: 155,
      time: 16
    }, {
      type: "mouseDown",
      time: 145,
      button: 2,
      ctrlKey: false
    }, {
      type: "mouseUp",
      time: 113
    }, {
      type: "mouseMove",
      mouseX: 364,
      mouseY: 156,
      time: 1809
    }, {
      type: "takeScreenshot",
      time: 801,
      screenShotImageData: [
        [
          {
            zombieKernelTestHarnessVersionMajor: 0,
            zombieKernelTestHarnessVersionMinor: 1,
            zombieKernelTestHarnessVersionRelease: 0,
            userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.43 Safari/537.31",
            screenWidth: 1920,
            screenHeight: 1080,
            screenColorDepth: 24,
            screenPixelRatio: 1,
            appCodeName: "Mozilla",
            appName: "Netscape",
            appVersion: "5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.43 Safari/537.31",
            cookieEnabled: true,
            platform: "MacIntel"
          }, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyAAAAJYCAYAAACadoJwAAAgAElEQVR4XuzdCZhU1Z338T+KLKIgOrggjMiAoyDLgASIedkGRxxAEGVTUAMBF5AJIxNlBzPRQFRAGRWBCYtsKoJBgUQWFUSRfVE0rogsIkuUsBhF3vf3n7n1Fk03Vd1ddauq63ufpx8a6t5zzv2cmzz185xzT7F169adMA4EEEAAAQQQQAABBBBAIASBYgSQEJSpAgEEEEAAAQQQQAABBFyAAMKDgAACCCCAAAIIIIAAAqEJEEBCo6YiBBBAAAEEEEAAAQQQIIDwDCCAAAIIIIAAAggggEBoAgSQ0KipCAEEEEAAAQQQQAABBAggPAMIIIAAAggggAACCCAQmgABJDRqKkIAAQQQQAABBBBAAAECCM8AAggggAACCCCAAAIIhCZAAAmNmooQQAABBBBAAAEEEECAAMIzgAACCCCAAAIIIIAAAqEJEEBCo6YiBBBAAAEEEEAAAQQQIIDwDCCAAAIIIIAAAggggEBoAgSQ0KipCAEEEEAAAQQQQAABBAggPAMIIIAAAggggAACCCAQmgABJDRqKkIAAQQQQAABBBBAAAECCM8AAggggAACCCCAAAIIhCZAAAmNmooQQAABBBBAAAEEEECAAMIzgAACCCCAAAIIIIAAAqEJEEBCo6YiBBBAAAEEEEAAAQQQIIDwDCCAAAIIIIAAAggggEBoAgSQ0KipCAEEEEAAAQQQQAABBAggPAMIIIAAAggggAACCCAQmgABJDRqKkIAAQQQQAABBBBAAAECCM8AAggggAACCCCAAAIIhCZAAAmNmooQQAABBBBAAAEEEECAAMIzgAACCCCAAAIIIIAAAqEJEEBCo6YiBBBAAAEEEEAAAQQQIIDwDCCAAAIIIIAAAggggEBoAgSQ0KipCAEEEEAAAQQQQAABBAggPAMIIIAAAggggAACCCAQmgABJDRqKkIAAQQQQAABBBBAAAECCM8AAggggAACCCCAAAIIhCZAAAmNmooQQAABBBBAAAEEEECAAMIzgAACCCCAAAIIIIAAAqEJEEBCo6YiBBBAAAEEEEAAAQQQIIDwDCCAAAIIIIAAAggggEBoAgSQ0KipCAEEEEAAAQQQQAABBAggPAMIIIAAAggggAACCCAQmgABJDRqKkIAAQQQQAABBBBAAAECCM8AAggggAACCCCAAAIIhCZAAAmNmooQQAABBBBAAAEEEECAAMIzgAACCCCAAAIIIIAAAqEJEEBCo6YiBBBAAAEEEEAAAQQQIIDwDCCAAAIIIIAAAggggEBoAgSQ0KipCAEEEEAAAQQQQAABBAggPAMIIIAAAggggAACCCAQmgABJDRqKkIAAQQQQAABBBBAAAECCM8AAggggAACCCCAAAIIhCZAAAmNmooQQAABBBBAAAEEEECAAMIzgAACCCCAAAIIIIAAAqEJEEBCo6YiBBBAAAEEEEAAAQQQIIDwDCCAAAIIIIAAAggggEBoAgSQ0KipCAEEEEAAAQQQQAABBAggPAMIIIAAAggggAACCCAQmgABJDRqKkIAAQQQQAABBBBAAAECCM8AAggggAACCCCAAAIIhCZAAAmNmooQQAABBBBAAAEEEECAAMIzgAACCCCAAAIIIIAAAqEJEEBCo6YiBBBAAAEEEEAAAQQQIIDwDCCAAAIIIIAAAggggEBoAgSQ0KipCAEEEEAAAQQQQAABBAggPAMIIIAAAggggAACCCAQmgABJDRqKkIAAQQQQAABBBBAAAECCM8AAggggAACCCCAAAIIhCZAAAmNmooQQAABBBBAAAEEEECAAMIzgAACCCCAAAIIIIAAAqEJEEBCo6YiBBBAAAEEEEAAAQQQIIDwDCCAAAIIIIAAAggggEBoAgSQ0KipCAEEEEAAAQQQQAABBAggPAMIIIAAAggggAACCCAQmgABJDRqKkIAAQQQQAABBBBAAAECCM8AAggggAACCCCAAAIIhCZAAAmNmooQQAABBBBAAAEEEECAAMIzgAACCCCAAAIIIIAAAqEJEEBCo6YiBBBAAAEEEEAAAQQQIIDwDCCAAAIIIIAAAggggEBoAgSQ0KipCAEEEEAAAQQQQAABBAggPAMIIIAAAggggAACCCAQmgABJDRqKkIAAQQQQAABBBBAAAECCM8AAggggAACCCCAAAIIhCZAAAmNmooQQAABBBBAAAEEEECAAMIzgAACCCCAAAIIIIAAAqEJEEBCo6YiBBBAAAEEEEAAAQQQIIDwDCCAAAIIIIAAAggggEBoAgSQ0KipCAEEEEAAAQQQQAABBAggPAMIIIAAAggggAACCCAQmgABJDRqKkIAAQQQQAABBBBAAAECCM8AAggggAACCCCAAAIIhCZAAAmNmooQQAABBBBAAAEEEECAAMIzgAACCCCAAAIIIIAAAqEJEEBCo6YiBBBAAAEEEEAAAQQQIIDwDCCAAAIIIIAAAggggEBoAgSQ0KipCAEEEEAAAQQQQAABBAggPAMIIIAAAggggAACCCAQmgABJDRqKkIAAQQQQAABBBBAAAECCM8AAggggAACCCCAAAIIhCZAAAmNmooQQAABBBBAAAEEEECAAMIzgAACCCCAAAIIIIAAAqEJEEBCo6YiBBBAAAEEEEAAAQQQIIDwDCCAAAIIIIAAAggggEBoAgSQ0KipCAEEEEAAAQQQQAABBAggPAMIIIAAAggggAACCCAQmgABJDRqKkIAAQQQQAABBBBAAAECCM8AAggggAACCCCAAAIIhCZAAAmNmooQQAABBBBAAAEEEECAAMIzgAACCCCAAAIIIIAAAqEJEEBCo6YiBBBAAAEEEEAAAQQQIIDwDCCAAAIIIIAAAggggEBoAgSQ0KipCAEEEEAAAQQQQAABBAggPAMIIIAAAggggAACCCAQmgABJDRqKkIAAQQQQAABBBBAAAECCM8AAggggAACCCCAAAIIhCZAAAmNmooQQAABBBBAAAEEEECAAMIzgAACCCCAAAIIIIAAAqEJEEBCo6YiBBBAAAEEEEAAAQQQIIDwDCCAAAIIIIAAAggggEBoAgSQ0KipCAEEEEAAAQQQQAABBAggPAMIIIAAAggggAACCCAQmgABJDRqKkIAAQQQQAABBBBAAAECCM8AAggggAACCCCAAAIIhCZAAAmNmooQQAABBBBAAAEEEECAAMIzgAACCCCAAAIIIIAAAqEJEEBCo6YiBBBAAAEEEEAAAQQQIIDwDCCAAAIIIIAAAggggEBoAgSQ0KipCAEEEEAAAQQQQAABBAggPAMIIIAAAggggAACCCAQmgABJDRqKkIAAQQQQAABBBBAAAECCM8AAggggAACCCCAAAIIhCZAAAmNmooQQAABBBBAAAEEEECAAMIzgAACCCCAAAIIIIAAAqEJEEBCo6YiBBBAAAEEEEAAAQQQIIDwDCCAAAIIIIAAAggggEBoAgSQ0KipCAEEEEAAAQQQQAABBAggPAMIIIAAAggggAACCCAQmgABJDRqKkIAAQQQQAABBBBAAAECCM8AAggggAACCCCAAAIIhCZAAAmNmooQQAABBBBAAAEEEECAAMIz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A0jWwWTpDRNAsrTjuW0EioAAAaQIdCK3gAAC2SFAAMmOfo73Lgkg8UpxHgIIpJsAASTdeoT2IIAAAnkIEEB4NKIFCCA8DwggkKkCBJBM7TnajQACWSeQM4AEX0CzDiLLb3jFihUuQADJ8geB20cggwUIIBnceTQdAQSyS4ARkOzq71h3SwCJJcTnCCCQrgIEkHTtGdqFAAII5BAggPBIRAsQQHgeEEAgUwUIIJnac7QbAQSyToAAknVdftobJoDwPCCAQKYKEEAytedoNwIIZJ1ArACSc0PBaKBt27b5buebN2+2M8888yQ77ZLeqFEj39G8fPnyhXb9+OOPrXnz5vb+++/bV199Ffn93HPPLXTZFPD/BQggPA0IIJCpAgSQTO052o0AAlknEE8AUcjYuHGjFStW7CQfbUCoHdEbN258itvnn39u2u08kQHk2muv9fL2799vwe+JCDdZ1+mnuWECCE8DAghkqgABJFN7jnYjgEDWCcQTQFq1amUDBw60Xr16WaVKley1116zK6+80r788kubM2eO9e/f33dJf/fdd61r1652wQUXeECYOXNmJIBoROT++++3efPmWb9+/WzYsGF+Xs7j9ddft549e9qnn35qnTp1sjFjxljFihVNIyAEkOQ/ngSQ5BtTAwIIJEeAAJIcV0pFAAEEEi4QK4Doi3/16tWtY8eONnjwYJsyZYqtW7fOFBQ+/PBD69Kli61fv96nRtWuXdsDg6ZetWvXztuqEQsdCiwKHipn6NChtnv3blu2bJkVL148ck8KNJUrV7ZZs2b5qMrYsWNt79699txzz9knn3xCAEl4759aIAEkBGSqQACBpAgQQJLCSqEIIIBA4gXiCSD16tUzTak6//zz/c9gatW+fft8DciGDRs8NCxcuNBmzJgRCR5Nmzb1ALJkyRIbMmSIT9dS4FD40KiGRjkuv/zyyE1pSpdGUVq0aGHff/+9TZ8+3aZNm2bLly83jaAwApL4/s9ZIgEk+cbUgAACyREggCTHlVIRQACBhAvECiBahN6+ffvIQvPoqVDRAeTuu++2a665xnr37u1tjD5v6dKlPvKR81izZo1fExxHjhyxRx991IYPHx75t7Zt29r8+fM9rBBAEt79pxRIAEm+MTUggEByBAggyXGlVAQQQCDhAvEEkGCUQ+s88gogWt+hNR0a6dAR/RYsjYxM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FiCAJBiU4hBAAIFkCcQKIHrTlfbr0B4a2m1cr7bVpoPRu43rzVHRGwgmq62Um3wBAkjyjakBAQSSI0AASY4rpSKAAAIJF4gVQB555BHf2K9evXq+i7k2+9PO49oLIwgdeQWQHTt22JNPPmkXX3yx7yB+/fXX+y7ql112md+H9ubQHh0qq1OnTr4pYcWKFf0zbVT485//3F9127t3b9/YT5sA6u8afVF52tiwX79+NmzYMN8JnaPwAgSQwhtSAgIIpEaAAJIad2pFAAEE8i0QK4AocOjNTpp+pSDRo0cP0w7lCgGxAohGSbTBn67RxoOayvXWW2/5a2oVWipXruzlakRl7NixtnfvXt/BXGFD1z377LNWs2ZNr0f7hWi/Dh0akVHw6Nixow0dOtR2795ty5Yti7mfSL5xsvACAkgWdjq3jEARESCAFJGO5DYQQKDoC8QKIJqCdfXVV3vo0AZ+2i9jw4YNcY2AfPTRR9aqVavIvhh63a3Cw6uvvmpXXHGFj3Jo4z7VMX36dJs2bZrvYK7fVZ92GNexZcsWa9mypQcQ7ZquMKOpYNr8T+FDoyYaRbn88suLfocl+Q4JIEkGpngEEEiaAAEkabQUjAACCCRWIFYA0cZ6derUsXfeece010V+A4imT2mHce1QrrLq169vU6dOtRo1atijjz7qoyLB0bZtW5s/f77ddtttvqhd1+qIXm+isjTykfNYs2aNr1HhKJwAAaRwflyNAAKpEyCApM6emhFAAIF8CSQ7gLRv395HMIIAoilVc+bMsS+//NLXcShQVKlSxVatWmUPPvigrwv53e9+Zz/88IMNHjzY70UjH02bNvU/Fy5c6OtINBKic/SjERlN4ypRokS+7p2TTxUggPBUIIBApgoQQDK152g3AghknUAyA0iwBuSll16ym266ySZNmmQjR460bdu2+a7hWlS+adMmO3TokLVu3drXeWgE5I033vDztV7k0ksv9Wlc27dv9wCitSfasXzlypVWu3Ztn641YMAA+/zzz+2ss87yhfLt2rXzUJPb79WqVcu6Ps7PDRNA8qPFuQggkE4CBJB06g3aggACCJxGIL8BRG+t0ihF8BYshQztA6KF4vo9eh+QIIBEV681HgoQGgHRqIbK0TFixAj/0bqP++67z8NKr169/LNGjRrZgQMHbOPGjVa6dOmTPtPna9eu9aldmuKlEZbZs2dbrVq1cv29QYMGPA+nESCA8HgggECmChBAMrXnaDcCCGSdQKwAUhgQjVjcc889Ps1Kb70655xzPEAEx/Hjxz1YKLTo9bpHjx71UQyNcuhHb98qVqyYL0jXK3k11UpTuXR8++23vni9XLlyvP2qMJ2U41oCSAIxKQoBBEIVIICEyk1lCCCAQMEFkhlANNVKi9a1c/qZZ54ZdyO1u7pGMrRAvWrVqnbHHXf463q7dOkSdxmcWDABAkjB3LgKAQRSL0AASX0f0AIEEEAgLoFkBhC9dlfTpjTlSiMZ+Tn0Ct/XXnvNdu7cirzqbQAAIABJREFUaW3atPFF5hzJFyCAJN+YGhBAIDkCBJDkuFIqAgggkHCBZAaQhDeWApMuQABJOjEVIIBAkgQIIEmCpVgEEEAg0QIEkESLZnZ5BJDM7j9aj0A2CxBAsrn3uXcEEMgogVgBRFOhgjdfBQvAgxvUW660YaDWbES//SqZAFqcrrdiaYF7+fLlY1Z1uvbHvDjqhPzWm5+y0+lcAkg69QZtQQCB/AgQQPKjxbkIIIBACgViBZDgTVbLli07ZR1H9A7l8YSBRNym9vto2LBhvgKIFsJrLUp+16FEtze/9SbiXlNRBgEkFerUiQACiRAggCRCkTIQQACBEARiBZAgZPziF7+whx9+2K6//np75plnfKO/6ADyzTff2Pjx42306NH+qlx9YQ/+roXkTz/9tG8cqPr0Wt6ZM2dG/q6Q85e//MV3Rp83b57169fPhg0bZhdccIELvPvuu9a1a1f/u/Yb0bU5R0C0I/qUKVMie4dMmzbNunXr5m3URoYDBw70zypVquSL26+88kovW3uaaIRH+5F06tTJxowZYxUrVoxZr14N3LFjR7+uR48eft/nn3++PfDAA3bjjTfaz372M1u9erU98sgj9txzz/kriHWO3u4lw9zaWpiAlKhHhQCSKEnKQQCBsAUIIGGLUx8CCCBQQIF4Akj16tXt3nvv9R9tFLhkyRLbunWrv6FKgUBhQJsRdu7c2ffs0Ct39W/B3zV9SWVop/OnnnrKatSo4T/B3/WlVxsHKnjoS/3QoUNt9+7dplEXvcpXwUXBQFOvtMu5jpwBZM2aNdahQwdbtGiR7xGidilcaCd11a1yBw8e7F/8161b55/t2rXLKleu7K/41Vu2xo4da3v37vXAoPvLq16FJb0eeOLEidayZUsvV5shvvfee972H3/80UaNGmW//e1vPfho9EX3W7duXQ9Pf/vb33JtqzZmTPVBAEl1D1A/AggUVIAAUlA5rkMAAQRCFogVQLSGQiMI+sKvTQIPHz7sX75fffVVO++88yIBZN++fb7nR7BZoK4L/q5Rgnr16vlohEKH/oz++wsvvGBDhgzxL/DFixf38KFRCF23atUqW7hwoc2YMSMSPPRFPWcAefnll61v3762ePFi/7KvOrTpoXZHV10akdEIRfRUKgUlja60aNHCNzWcPn26aeREu7VrN/W86p0/f76HsKBNCjwKOQpMGgnSSMumTZt8pEP/poCjNv/kJz+xP//5z/anP/0p17ZqdCbVBwEk1T1A/QggUFABAkhB5bgOAQQQCFkgngASvQhdX+jr169vU6dOPW0AUQC4+eabPZAoSAQjJVorknPtyIsvvugjFDkPjWo8++yzds0111jv3r3947zWnRw5csRHUCZPnuzn6fdBgwb5aEj79u0jmyFGX1+yZEl79NFHfcPD4Gjbtq0pYNx999151quRIC2+D9oUmGh0pVq1aj69S+FFn6vsP/zhDz4t65VXXvH7yautF110Uci9f2p1BJCUdwENQACBAgoQQAoIx2UIIIBA2ALxBBB9gd+yZYuv7dCXba1jmDNnzikBJPqLvsKD1nRoqlOsAKKRhAkTJviogtZy6EfBRdOitKZCaz80QqIjr7dR7dmzx0dPypQp49On+vTp41PA9MU/emQmOoC88cYb3katSdGaFo22PPjgg95m/Xte9Wpti9ZrBG0KRoU02qHRF4UpTR1r3bq1t1//pkOjKxoVyautqjPVBwEk1T1A/QggUFABAkhB5bgOAQQQCFkgVgDRF3ZNL5o7d67ddNNNPsKghdW5rQG56qqrfC2ERgGaNGlil112mY8mxAogWjei3dJXrlzp6y40FWrAgAE+XUpTpDQqoQXdmvqlUQ2t0cg5BUsBRkFGC8xLlCjhay8qVKhw2gCiUYqHHnrIp0sdOnTIA4OmiKnNb731Vp71bt682T9T2zTaofUpCiXBNDWt87jtttsiZpripVcVay3IJZdc4mErt7aqL8aNG+frXBSIcvtdtsk8CCDJ1KVsBBBIpgABJJm6lI0AAggkUCDeABJUqf0+NEIQrOHQ1CqFFL3lSaHh8ccf91Ov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CAQEDJBASSISIECAAAECBAgQWBEwQFaadAcBAgQIECBAgACBgIABEihJRAIECBAgQIAAAQIrAgbISpPuIECAAAECBAgQIBAQMEACJYlIgAABAgQIECBAYEXAAFlp0h0ECBAgQIAAAQIEAgIGSKAkEQkQIECAAAECBAisCBggK026gwABAgQIECBAgEBAwAAJlCQiAQIECBAgQIAAgRUBA2SlSXcQIECAAAECBAgQCAgYIIGSRCRAgAABAgQIECCwImCArDTpDgIECBAgQIAAAQIBAQMkUJKIBAgQIECAAAECBFYEDJCVJt1BgAABAgQIECBAICBggARKEpEAAQIECBAgQIDAioABstKkOwgQIECAAAECBAgEBAyQQEkiEiBAgAABAgQIEFgRMEBWmnQHAQIECBAgQIAAgYCAARIoSUQCBAgQIECAAAECKwIGyEqT7iBAgAABAgQIECAQEDBAAiWJSIAAAQIECBAgQGBFwABZadIdBAgQIECAAAECBAICBkigJBEJECBAgAABAgQIrAgYICtNuoMAAQIECBAgQIBAQMAACZQkIgECBAgQIECAAIEVAQNkpUl3ECBAgAABAgQIEAgIGCCBkkQkQIAAAQIECBAgsCJggKw06Q4CBAgQIECAAAECAQEDJFCSiAQIECBAgAABAgRWBAyQlSbdQYAAAQIECBAgQCAgYIAEShKRAAECBAgQIECAwIqAAbLSpDsIECBAgAABAgQIBAQMkEBJIhIgQIAAAQIECBBYETBAVpp0BwECBAgQIECAAIGAgAESKElEAgQIECBAgAABAisCBshKk+4gQIAAAQIECBAgEBAwQAIliUiAAAECBAgQIEBgRcAAWWnSHQQIECBAgAABAgQCAgZIoCQRCRAgQIAAAQIECKwIGCArTbqDAAECBAgQIECAQEDAAAmUJCIBAgQIECBAgACBFQEDZKVJdxAgQIAAAQIECBAICBgggZJEJECAAAECBAgQILAiYICsNOkOAgQIECBAgAABAgEBAyRQkogECBAgQIAAAQIEVgQMkJUm3UGAAAECBAgQIEAgIGCABEoSkQABAgQIECBAgMCKgAGy0qQ7CBAgQIAAAQIECAQEDJBASSISIECAAAECBAgQWBEwQFaadAcBAgQIECBAgACBgIABEihJRAIECBAgQIAAAQIrAgbISpPuIECAAAECBAgQIBAQMEACJYlIgAABAgQIECBAYEXAAFlp0h0ECBAgQIAAAQIEAgIGSKAkEQkQIECAAAECBAisCBggK026gwABAgQIECBAgEBAwAAJlCQiAQIECBAgQIAAgRUBA2SlSXcQIECAAAECBAgQCAgYIIGSRCRAgAABAgQIECCwImCArDTpDgIECBAgQIAAAQIBAQMkUJKIBAgQIECAAAECBFYEDJCVJt1BgAABAgQIECBAICBggARKEpEAAQIECBAgQIDAioABstKkOwgQIECAAAECBAgEBAyQQEkiEiBAgAABAgQIEFgRMEBWmnQHAQIECBAgQIAAgYCAARIoSUQCBAgQIECAAAECKwIGyEqT7iBAgAABAgQIECAQEDBAAiWJSIAAAQIECBAgQGBFwABZadIdBAgQIECAAAECBAICBkigJBEJECBAgAABAgQIrAgYICtNuoMAAQIECBAgQIBAQMAACZQkIgECBAgQIECAAIEVAQNkpUl3ECBAgAABAgQIEAgIGCCBkkQkQIAAAQIECBAgsCJggKw06Q4CBAgQIECAAAECAQEDJFCSiAQIECBAgAABAgRWBAyQlSbdQYAAAQIECBAgQCAgYIAEShKRAAECBAgQIECAwIqAAbLSpDsIECBAgAABAgQIBAQMkEBJIhIgQIAAAQIECBBYETBAVpp0BwECBAgQIECAAIGAgAESKElEAgQIECBAgAABAisCBshKk+4gQIAAAQIECBAgEBAwQAIliUiAAAECBAgQIEBgRcAAWWnSHQQIECBAgAABAgQCAgZIoCQRCRAgQIAAAQIECKwIGCArTbqDAAECBAgQIECAQEDAAAmUJCIBAgQIECBAgACBFQEDZKVJdxAgQIAAAQIECBAICBgggZJEJECAAAECBAgQILAiYICsNOkOAgQIECBAgAABAgEBAyRQkogECBAgQIAAAQIEVgQMkJUm3UGAAAECBAgQIEAgIGCABEoSkQABAgQIECBAgMCKgAGy0qQ7CBAgQIAAAQIECAQEDJBASSISIECAAAECBAgQWBEwQFaadAcBAgQIECBAgACBgIABEihJRAIECBAgQIAAAQIrAgbISpPuIECAAAECBAgQIBAQMEACJYlIgAABAgQIECBAYEXAAFlp0h0ECBAgQIAAAQIEAgIGSKAkEQkQIECAAAECBAisCBggK026gwABAgQIECBAgEBAwAAJlCQiAQIECBAgQIAAgRUBA2SlSXcQIECAAAECBAgQCAgYIIGSRCRAgAABAgQIECCwImCArDTpDgIECBAgQIAAAQIBAQMkUJKIBAgQIECAAAECBFYEDJCVJt1BgAABAgQIECBAICBggARKEpEAAQIECBAgQIDAioABstKkOwgQIECAAAECBAgEBAyQQEkiEiBAgAABAgQIEFgRMEBWmnQHAQIECBAgQIAAgYCAARIoSUQCBAgQIECAAAECKwIGyEqT7iBAgAABAgQIECAQEDBAAiWJSIAAAQIECBAgQGBFwABZadIdBAgQIECAAAECBAICBkigJBEJECBAgAABAgQIrAgYICtNuoMAAQIECBAgQIBAQMAACZQkIgECBAgQIECAAIEVAQNkpUl3ECBAgAABAgQIEAgIGCCBkkQkQIAAAQIECBAgsCJggKw06Q4CBAgQIECAAAECAQEDJFCSiAQIECBAgAABAgRWBAyQlSbdQYAAAQIECBAgQCAgYIAEShKRAAECBAgQIECAwIqAAbLSpDsIECBAgAABAgQIBAQMkEBJIhIgQIAAAQIECBBYETBAVpp0BwECBAgQIECAAIGAgAESKElEAgQIECBAgAABAisCBshKk+4gQIAAAQIECBAgEBAwQAIliUiAAAECBAgQIEBgRcAAWWnSHQQIECBAgAABAgQCAgZIoCQRCRAgQIAAAQIECKwIGCArTbqDAAECBAgQIECAQEDAAAmUJCIBAgQIECBAgACBFQEDZKVJdxAgQIAAAQIECBAICBgggZJEJECAAAECBAgQILAiYICsNOkOAgQIECBAgAABAgEBAyRQkogECBAgQIAAAQIEVgQMkJUm3UGAAAECBAgQIEAgIGCABEoSkQABAgQIECBAgMCKgAGy0qQ7CBAgQIAAAQIECAQEDJBASSISIECAAAECBAgQWBEwQFaadAcBAgQIECBAgACBgIABEihJRAIECBAgQIAAAQIrAgbISpPuIECAAAECBAgQIBAQMEACJYlIgAABAgQIECBAYEXAAFlp0h0ECBAgQIAAAQIEAgIGSKAkEQkQIECAAAECBAisCBggK026gwABAgQIECBAgEBAwAAJlCQiAQIECBAgQIAAgRUBA2SlSXcQIECAAAECBAgQCAgYIIGSRCRAgAABAgQIECCwImCArDTpDgIECBAgQIAAAQIBAQMkUJKIBAgQIECAAAECBFYEDJCVJt1BgAABAgQIECBAICBggARKEpEAAQIECBAgQIDAioABstKkOwgQIECAAAECBAgEBAyQQEkiEiBAgAABAgQIEFgRMEBWmnQHAQIECBAgQIAAgYCAARIoSUQCBAgQIECAAAECKwIGyEqT7iBAgAABAgQIECAQEDBAAiWJSIAAAQIECBAgQGBFwABZadIdBAgQIECAAAECBAICBkigJBEJECBAgAABAgQIrAgYICtNuoMAAQIECBAgQIBAQMAACZQkIgECBAgQIECAAIEVAQNkpUl3ECBAgAABAgQIEAgIGCCBkkQkQIAAAQIECBAgsCJggKw06Q4CBAgQIECAAAECAQEDJFCSiAQIECBAgAABAgRWBAyQlSbdQYAAAQIECBAgQCAgYIAEShKRAAECBAgQIECAwIqAAbLSpDsIECBAgAABAgQIBAQMkEBJIhIgQIAAAQIECBBYETBAVpp0BwECBAgQIECAAIGAgAESKElEAgQIECBAgAABAisCBshKk+4gQIAAAQIECBAgEBAwQAIliUiAAAECBAgQIEBgRcAAWWnSHQQIECBAgAABAgQCAgZIoCQRCRAgQIAAAQIECKwIGCArTbqDAAECBAgQIECAQEDAAAmUJCIBAgQIECBAgACBFQEDZKVJdxAgQIAAAQIECBAICBgggZJEJECAAAECBAgQILAiYICsNOkOAgQIECBAgAABAgEBAyRQkogECBAgQIAAAQIEVgQMkJUm3UGAAAECBAgQIEAgIGCABEoSkQABAgQIECBAgMCKgAGy0qQ7CBAgQIAAAQIECAQEDJBASSISIECAAAECBAgQWBH4DTLBE+1uQpVLAAAAAElFTkSuQmCC"
        ], [
          {
            zombieKernelTestHarnessVersionMajor: 0,
            zombieKernelTestHarnessVersionMinor: 1,
            zombieKernelTestHarnessVersionRelease: 0,
            userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/536.26.17 (KHTML, like Gecko) Version/6.0.2 Safari/536.26.17",
            screenWidth: 1920,
            screenHeight: 1080,
            screenColorDepth: 24,
            screenPixelRatio: 1,
            appCodeName: "Mozilla",
            appName: "Netscape",
            appVersion: "5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/536.26.17 (KHTML, like Gecko) Version/6.0.2 Safari/536.26.17",
            cookieEnabled: true,
            platform: "MacIntel"
          }, "data:image/png;base64,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kSOtWbNmftfqiqVgQ+NA1AUraAHRM0NCAAEEElWAhQgT9ZuhXggggMDfBGKn3NUuDThWUssHKX8JBN+5WkGU1DKmWdHOnj1r6pp1+fJl36dnhoQAAggkqgABSKJ+M9QLAQQQiBHQD83kiW5XyUXy/ueUvvPz58+bXpqkQGOFUnpW8r4Md4gAArlJgAAkN31b1BUBBPKlgLrT5OcuNRpQfbNSbhhL8e2335peGhOkACS/Py8361nhugggkH4BApD0W5ETAQQQuCkCifKD8tlnn7VRo0aFBrfffru9/fbb1rdv33Bfw4YNbdOmTRmaoatu3br2xhtvhGXEbmjGr4ULF/ouTTerWcCef/752Cy+PXHiRD9WuXLlHxzL7I4GDRrY7NmzM3t6ZOcFrR7qdqVXojwvkQFwIQQQyHUCBCC57iujwgggkB8FEqEF5MMPPzT9KA9SkyZNTAPj9R4kHddsXeoOlBNJP7a1CrgGXQdJMz/9+Mc/9laAYF9+e48NOhLhWclv/twvAghkTIAAJGNe5EYAAQTyrYACkBo1aoStGwo8FixY4EFJ0E1KAcif//xnN9JsXXPnzrU1a9aYWijuuOMO31+1alX793//d+vZs6e99NJLP/D8u7/7O3v11VftlVdesVatWv3guBbga9myZbi/efPmprrFDrxO77UVuIwYMcKGDRtm//u//2vTp0+3ihUrhmVrRfEhQ4bY4sWLvU66/0RLQfARvCda/agPAgggkFyAACS5CJ8RQAABBFIUOHDggM+4pMXvlBSA/OEPfzCt0K2uV0p6VzCg7lITJkzwAENdtDRT07/92795niJFingAoeDi9ddf933BH00j+//+3/+zt956y/7zP//TunTpEhzyd43J+P3vf29t2rQJ97du3dq7ghUo8Nf/pWXk2pq6VoHQN99842tsHDx40B577LGw7OrVq1upUqVs7Nixpvv/p3/6p/AYGwgggAACmRMgAMmcG2chgAAC+VJArRsKMqpUqeItDl9++aVt3brVgxH98Fcrx/bt233RvE8++cS2bNliZ86csddee83UUhFMH3vLLbf4Qnp//OMfb3Bs3Lix7dq1y958801vSQnGfwSZ1CKhFpB77rnHW2K0AJ8Coc2bNwdZMnxtraUxZ84cX1l8xowZptYTXUdJs0upVURB1pIlS3zV8fBCbCCAAAIIZErg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BAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBByQqzmVIUCAAAECBAgQINAWcEDa+0hHgAABAgQIECBA4ErAAbmaUxkCBAgQIECAAAECbQEHpL2PdAQIECBAgAABAgSuBAaU0YynAt9EwgAAAABJRU5ErkJggg=="
        ]
      ]
    }, {
      type: "mouseMove",
      mouseX: 335,
      mouseY: 134,
      time: 915
    }, {
      type: "mouseMove",
      mouseX: 318,
      mouseY: 129,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 302,
      mouseY: 128,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 218,
      mouseY: 120,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 156,
      mouseY: 121,
      time: 16
    }, {
      type: "mouseMove",
      mouseX: 97,
      mouseY: 130,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 42,
      mouseY: 134,
      time: 17
    }, {
      type: "mouseMove",
      mouseX: 12,
      mouseY: 135,
      time: 16
    }
  ];

  return SystemTest_SimpleMenuTest;

})();

GrayPaletteMorph = (function(_super) {

  __extends(GrayPaletteMorph, _super);

  function GrayPaletteMorph(target, sizePoint) {
    this.target = target != null ? target : null;
    GrayPaletteMorph.__super__.constructor.call(this, this.target, sizePoint || new Point(80, 10));
  }

  GrayPaletteMorph.prototype.updateRendering = function() {
    var context, ext, gradient;
    ext = this.extent();
    this.image = newCanvas(this.extent());
    context = this.image.getContext("2d");
    this.choice = new Color();
    gradient = context.createLinearGradient(0, 0, ext.x, ext.y);
    gradient.addColorStop(0, "black");
    gradient.addColorStop(1, "white");
    context.fillStyle = gradient;
    return context.fillRect(0, 0, ext.x, ext.y);
  };

  return GrayPaletteMorph;

})(ColorPaletteMorph);

ListMorph = (function(_super) {

  __extends(ListMorph, _super);

  ListMorph.prototype.elements = null;

  ListMorph.prototype.labelGetter = null;

  ListMorph.prototype.format = null;

  ListMorph.prototype.listContents = null;

  ListMorph.prototype.selected = null;

  ListMorph.prototype.action = null;

  function ListMorph(elements, labelGetter, format) {
    this.elements = elements != null ? elements : [];
    this.format = format != null ? format : [];
    ListMorph.__super__.constructor.call(this);
    this.contents.acceptsDrops = false;
    this.color = new Color(255, 255, 255);
    this.hBar.alpha = 0.6;
    this.vBar.alpha = 0.6;
    this.labelGetter = labelGetter || function(element) {
      if (isString(element)) {
        return element;
      }
      if (element.toSource) {
        return element.toSource();
      }
      return element.toString();
    };
    this.buildListContents();
  }

  ListMorph.prototype.buildListContents = function() {
    var _this = this;
    if (this.listContents) {
      this.listContents.destroy();
    }
    this.listContents = new MenuMorph(this.select, null, this);
    if (!this.elements.length) {
      this.elements = ["(empty)"];
    }
    this.elements.forEach(function(element) {
      var color;
      color = null;
      _this.format.forEach(function(pair) {
        if (pair[1].call(null, element)) {
          return color = pair[0];
        }
      });
      return _this.listContents.addItem(_this.labelGetter(element), element, null, color);
    });
    this.listContents.setPosition(this.contents.position());
    this.listContents.isListContents = true;
    this.listContents.updateRendering();
    return this.addContents(this.listContents);
  };

  ListMorph.prototype.select = function(item) {
    this.selected = item;
    if (this.action) {
      return this.action.call(null, item);
    }
  };

  ListMorph.prototype.setExtent = function(aPoint) {
    var lb, nb;
    lb = this.listContents.bounds;
    nb = this.bounds.origin.copy().corner(this.bounds.origin.add(aPoint));
    if (nb.right() > lb.right() && nb.width() <= lb.width()) {
      this.listContents.setRight(nb.right());
    }
    if (nb.bottom() > lb.bottom() && nb.height() <= lb.height()) {
      this.listContents.setBottom(nb.bottom());
    }
    return ListMorph.__super__.setExtent.call(this, aPoint);
  };

  return ListMorph;

})(ScrollFrameMorph);
