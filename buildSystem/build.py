#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
This script performs only some of the steps of the build:

1) For each class file (not all of the coffee files are class files), it
   generates a special string that contains the coffeescript source of the
   file itself.  This is so we can enable editing of the classes in
   coffeescript within the running system, and do something like
   generating the documentation on the fly.

2) Combines the files that DON'T contain classes. The classes will be loaded
   dynamically by the environment, these other non-class files are loaded
   at start instead.

3) Generates an index html file that also includes all the tests, which
   are javascripts in a special directory

"""

# These are included in order to make the script compatible both
# with Python 2 and 3.
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals
from __future__ import absolute_import

# standard library's imports
from datetime import datetime
from glob import glob
import codecs
import re
import os
import ntpath

# to find the multiple js test files
# recursively in the src/tests folder
import fnmatch

import argparse

# GLOBALS
FINAL_OUTPUT_FILE = '../Fizzygum-builds/latest/delete_me/fizzygum-boot.coffee'


DIRECTORY_WITH_TEST_FILES = "../Fizzygum-tests/tests/"
FILE_TO_BE_ADDED_TEST_INCLUDES = "src/index.html"
OUTPUT_FILE_WITH_TEST_INCLUDES = "../Fizzygum-builds/latest/worldWithSystemTestHarness.html"
DIRECTORY_WITH_AUTOMATOR_AND_TEST_HARNESS_CODE = "../Fizzygum-tests/Automator-and-test-harness-src"

# RegEx Patterns
# We precompile them in order to improve performance and increase
# code readability
IS_CLASS = re.compile(r"^class +(\w+)", re.MULTILINE)
IS_MIXIN = re.compile(r"^(\w+Mixin)[ ]*=", re.MULTILINE)

# regexps to exclude entire files or parts of files from the
# homepage build
HOMEPAGE_EXCLUSION_PARTS = re.compile(r"[ ]*# »>> this part is excluded from the fizzygum homepage build[^«]*«")
NOT_IN_FIZZYGUM_HOMEPAGE = re.compile(r"# this file is excluded from the fizzygum homepage build")


# we just need to detect a switch
# see https://stackoverflow.com/a/8259080
parser = argparse.ArgumentParser()
parser.add_argument('--homepage', action='store_true')
parser.add_argument('--notests', action='store_true')
args = parser.parse_args()


def generateHTMLFileIncludingTests(testsDirectory, srcHTMLFile, destHTMLFile):

    manifest = ""
    manifest = manifest + "// this file is generated by the build script by" + "\n"
    manifest = manifest + "// listing all the tests in the tests repository" + "\n"
    manifest = manifest + "// This file can be edited to manually change the" + "\n"
    manifest = manifest + "// order of the tests or limit the tests to a subset" + "\n"
    manifest = manifest + "// Just note that this file is loaded as soon as the" + "\n"
    manifest = manifest + "// world starts. Editing afterwards will have no effect." + "\n"
    manifest = manifest + "testsManifest = [];" + "\n\n"

    # create a list with the test files
    # src/tests/
    # filenames = sorted(glob(testsDirectory + "*.js"))

    if not (args.homepage or args.notests):

        # creating the manifest for the tests ------------------------------------
        # which only includes the test steps and not the
        # assets, so it's one js file for each test
        filenames2 = []
        for root, dirnames, fileNMS in os.walk("../Fizzygum-tests/tests/"):
          for filename in fnmatch.filter(fileNMS, 'SystemTest_*[!0123456789][!0123456789][!0123456789][!0123456789][!0123456789][!0123456789].js'):
              # the way to differentiate between files: the asset files contain a hash
              # in the filename that we can use to filter them in/out.
              # note that this is not a normal regexp but rather a unix bash regexp
              # as explained here:
              # http://fabiosantoscode.blogspot.co.uk/2012/12/wildcards-in-python-fnmatch-module.html
              filename = filename[:-3] # remove the last three chars i.e. the ".js" extension
              if filename.endswith("_automationCommands"):
                continue
              filenames2.append(os.path.join(filename))
              print("adding to test manifest: %s" % (filename))
        filenames2 = sorted(filenames2)


        for filename in filenames2:
            manifest = manifest + "testsManifest.push('"+ntpath.basename(filename)+"');\n"

    # 'build/indexWithTests.html'
    with codecs.open("../Fizzygum-builds/latest/js/tests/testsManifest.js", "w", "utf-8") as f:
        f.write(manifest)

    # -------------------------------------------------------------------------

    manifest = "testsAssetsManifest = [];\n\n"

    if not (args.homepage or args.notests):
        # creating the manifest for the tests ASSETS ------------------------------------
        # which only includes the test steps and not the
        # assets, so it's one js file for each test
        filenames2 = []
        #print("Tests assets ----------------------------")
        for root, dirnames, fileNMS in os.walk("../Fizzygum-tests/tests/"):
          for filename in fnmatch.filter(fileNMS, 'SystemTest_*[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789].js'):
              # the way to differentiate between files: the asset files contain a hash
              # in the filename that we can use to filter them in/out.
              # note that this is not a normal regexp but rather a unix bash regexp
              # as explained here:
              # http://fabiosantoscode.blogspot.co.uk/2012/12/wildcards-in-python-fnmatch-module.html
              filename = filename[:-3] # remove the last three chars i.e. the ".js" extension
              filenames2.append(os.path.join(root,filename).replace("../Fizzygum-tests/tests/",""))
              #print("%s" % (os.path.join(root,filename)))
        filenames2 = sorted(filenames2)


        for filename in filenames2:
            manifest = manifest + "testsAssetsManifest.push('"+filename+"');\n"

    # 'build/indexWithTests.html'
    with codecs.open("../Fizzygum-builds/latest/js/tests/testsAssetsManifest.js", "w", "utf-8") as f:
        f.write(manifest)
    # -------------------------------------------------------------------------

    target =  ""

    # put the tests inclusion in the right place

    # 'src/index.html'
    with codecs.open(srcHTMLFile, "r", "utf-8") as f:
        content = f.read()

    lines = content.split('\n')

    src = "<!--include test scripts here-->"

    replacedContent = ""
    for line in lines:
        replacedContent = replacedContent + line.replace(src, target) + "\n"

    # 'build/indexWithTests.html'
    with codecs.open(destHTMLFile, "w", "utf-8") as f:
        f.write(replacedContent)


def main():

    # create a list with the coffeescript files
    filenames = sorted(glob("src/*.coffee"))

    if not (args.homepage or args.notests):
        if os.path.exists("../Fizzygum-tests"):
            if os.path.exists(DIRECTORY_WITH_AUTOMATOR_AND_TEST_HARNESS_CODE):
                filenames = sorted(filenames + sorted(glob(DIRECTORY_WITH_AUTOMATOR_AND_TEST_HARNESS_CODE + "/*.coffee")))
                filenames = sorted(filenames + sorted(glob(DIRECTORY_WITH_AUTOMATOR_AND_TEST_HARNESS_CODE + "/AutomatorEventCommands/*.coffee")))

    # add the sources from the directories
    # the order here has no importance, just try to
    # give it some sense anyways, from most basic/necessary
    # to more elaborate/optional
    # note that the boot/ directory is not visited, those files are
    # concatenated by the shell script
    filenames = sorted(filenames + sorted(glob("src/mixins" + "/*.coffee")))
    filenames = sorted(filenames + sorted(glob("src/basic-data-structures" + "/*.coffee")))
    filenames = sorted(filenames + sorted(glob("src/basic-widgets" + "/*.coffee")))
    filenames = sorted(filenames + sorted(glob("src/basic-widgets/menu-system" + "/*.coffee")))
    filenames = sorted(filenames + sorted(glob("src/patch-programming" + "/*.coffee")))
    filenames = sorted(filenames + sorted(glob("src/buttons" + "/*.coffee")))
    filenames = sorted(filenames + sorted(glob("src/icons" + "/*.coffee")))
    filenames = sorted(filenames + sorted(glob("src/meta" + "/*.coffee")))
    filenames = sorted(filenames + sorted(glob("src/apps" + "/*.coffee")))
    filenames = sorted(filenames + sorted(glob("src/graphs-plots-charts" + "/*.coffee")))
    filenames = sorted(filenames + sorted(glob("src/maps" + "/*.coffee")))
    filenames = sorted(filenames + sorted(glob("src/fizzytiles" + "/*.coffee")))
    filenames = sorted(filenames + sorted(glob("src/event-commands" + "/*.coffee")))


    # so here we need to take a .coffee file and generate a js that
    # , when run, puts its contents as string into a variable.
    # There are three ways of doing this.
    # 1) generate a coffeescript that contains a multiline string
    #    with the file inside it, then do another pass to convert
    #    the .coffee into .js
    # 2) directly generate a .js file that uses JS multi-line strings
    # 3) directly generate a .js that contains a normal JS string
    #    (which requires us to turn the multi-line source into a normal
    #    js string)
    # 
    # We used 1) before, however 3) is the easiest of the three.
    # You'd think that 2) is easiest but that still requires some escaping
    # of the source contents (multiline JS delimiters and in-string variables).
    # 3) Only requires us to escape the " and the \ and to turn the newlines
    # into something else. The easiest way is to replace " and \ with
    # similarly-looking unicode characters and \n with another dedicated
    # character (⤶).
    # Of course we need to make sure that the obtained JS string is
    # transformed back to the original source, hence why we append the
    # three "replace"s to the string, so we undo the transformations
    # of above.
    #
    # Note that this mechanism fails if the "transformed to" characters
    # are already in the string, however we detect that and besides that's why
    # we picked some strange characters.
    #
    # Also note that we tried to use .json to store these strings rather
    # than using this js trick, however .json loading is not permitted from
    # filesystem, so we'd always need a server...
    STRING_BLOCK = 'window.%s = "%s".replace(/＂/g, "\\\"").replace(/⧹/g, "\\\\").replace(/⤶/g, "\\n");'
    sourcesManifest = "sourcesManifest = [\n"

    # now iterate through the source files and create
    # 1) the js files with the coffeescript sources, one for each
    # 2) a few the js files with A BATCH OF coffeescript sources
    #    (so we load like 12 source batches rathern tna 400 sources)
    # 3) the manifest for the files above, so the system knows what to load
    #    and also we put in the manifest the number of batches that we
    #    ended up creating
    # In theory you don't need both emitting/loading mechanisms 1) and 2),
    # we just generate sources in both ways for completeness even if we end
    # up loading the batches only (i.e. 2).
    
    batchedSources = ""
    numberOfSourceBatches = 0
    minimumSourcesBatchSize = 150000

    for filename in filenames:
        print(">>>> %s " % (filename))
        # open file and read its contents
        with codecs.open(filename, "r", "utf-8") as f:
            content = f.read()

        # if the file is a class, then we add its source code in a
        # *.coffee file as a window.SOURCENAME_coffeSource variable
        # (string block).
        # We check if the file is a class by searching its contents for a
        # class ... declaration.
        is_class_file = IS_CLASS.search(content)
        is_mixin_file = IS_MIXIN.search(content)


        # all the class and mixins files' coffeescript source is put
        # in .coffee files containing such sources as text.
        # later on in the build process these .coffee "source containers"
        # are going to be translated to javascript (still containing coffeescript
        # sources as text).
        # Also keep track of all the sources in a manifest.
        # The manifest will be loaded at start, and then the sources will be
        # dynamically and asynchronously loaded following the manifest entries.
        # This is so Fizzygum can dynamically (and possibly lazily) load all
        # the morph's classes as coffeescript source code.

        # the meaning of the first bracket is: if --homepage parameter
        # is passed to this script, then
        # there must be no "NOT_IN_FIZZYGUM_HOMEPAGE" directive in the source.
        # (since p -> q is identical to not p or q, you have what's in the
        # bracket).
        if (not args.homepage or not NOT_IN_FIZZYGUM_HOMEPAGE.search(content)) and (is_class_file or is_mixin_file):

            # backslashes and quotes and newlines all need
            # to be escaped. Quotes need to be escaped otherwise
            # they'll conflict with the starting and ending quote of
            # the complete string. Backslashes need to be escaped
            # otherwise that'll pair up with the next characters to
            # encode all kinds of escape sequences including backspace
            # and tabs and others (https://en.wikipedia.org/wiki/Escape_sequences_in_C)
            # finally, obviously newlines need to be turned into something else
            # since js (plain) strings can't span across multiple lines.

            if ("＂" in content) or ("⧹" in content) or ("⤶" in content): 
              print("ERROR: I'm replacing a special character with a character that is already present in " + filename + ". Likely to be a problem.")
              exit()

            escaped_content = content.replace('"',"＂")
            escaped_content = escaped_content.replace("\\","⧹")
            escaped_content = escaped_content.replace("\n","⤶")

            # if we are building for the homepage, we strip out all
            # sections of the file that don't belong to the homepage
            if args.homepage:
                escaped_content = re.sub(HOMEPAGE_EXCLUSION_PARTS, '', escaped_content)

            sourceFileName = ntpath.basename(filename).replace(".coffee","_coffeSource")
            escaped_content_with_declaration = STRING_BLOCK % (unicode(sourceFileName), unicode(escaped_content))

            with codecs.open("../Fizzygum-builds/latest/js/sourceCode/"+sourceFileName+".js", "w", "utf-8") as f:
                f.write(escaped_content_with_declaration)
                sourcesManifest += "  '" + sourceFileName.replace("_coffeSource","") + "',\n";

            # pile up the sources into a batch and save the batch
            # when is big enough
            batchedSources += "\n\n" + escaped_content_with_declaration
            if len(batchedSources) > minimumSourcesBatchSize:
                sourceFileName = ntpath.basename("sources_batch_"+str(numberOfSourceBatches))
                with codecs.open("../Fizzygum-builds/latest/js/sourceCode/"+sourceFileName+".js", "w", "utf-8") as f:
                    f.write(unicode(batchedSources))
                numberOfSourceBatches = numberOfSourceBatches + 1
                batchedSources = ""



    # take care of saving the last batch with the remainder
    # of the sources
    sourceFileName = ntpath.basename("sources_batch_"+str(numberOfSourceBatches))
    with codecs.open("../Fizzygum-builds/latest/js/sourceCode/"+sourceFileName+".js", "w", "utf-8") as f:
        f.write(unicode(batchedSources))
    numberOfSourceBatches = numberOfSourceBatches + 1

    sourcesManifest += "];\n\nnumberOfSourceBatches = " + str(numberOfSourceBatches) + ";\n"
    with codecs.open("../Fizzygum-builds/latest/js/sourceCode/sourceCodeManifest.js", "w", "utf-8") as f:
        f.write(sourcesManifest)



    # 4) a new HTML file is generated which also contains
    # all the loading of the test files
    generateHTMLFileIncludingTests(
            DIRECTORY_WITH_TEST_FILES,
            FILE_TO_BE_ADDED_TEST_INCLUDES,
            OUTPUT_FILE_WITH_TEST_INCLUDES)


if __name__ == "__main__":
    main()
